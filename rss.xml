<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://246859.github.io/my-blog-giscus/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://246859.github.io/my-blog-giscus/rss.xml" rel="self" type="application/rss+xml"/>
    <title>寒江蓑笠翁</title>
    <link>https://246859.github.io/my-blog-giscus/</link>
    <description>寒江蓑笠翁的个人博客</description>
    <language>zh-CN</language>
    <pubDate>Wed, 28 Aug 2024 05:41:06 GMT</pubDate>
    <lastBuildDate>Wed, 28 Aug 2024 05:41:06 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>go</category>
    <category>linux</category>
    <category>docker</category>
    <category>windows</category>
    <category>技术日志</category>
    <category>python</category>
    <category>生活随笔</category>
    <category>问题记录</category>
    <category>二叉树</category>
    <category>算法</category>
    <category>每日发现</category>
    <category>db</category>
    <category>git</category>
    <category>设计模式</category>
    <category>rust</category>
    <category>游戏杂谈</category>
    <item>
      <title>如何向Go贡献代码</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/contribute2go.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/contribute2go.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">如何向Go贡献代码</source>
      <description>如何向Go贡献代码</description>
      <category>go</category>
      <pubDate>Wed, 31 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 如何向Go贡献代码</h1>
<figure><img src="https://spf13.com/presentation/how-to-contribute-to-go/front.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<h2> 前言</h2>
<p>有一天我突发奇想，想自己编写一个契合我个人使用习惯的go版本管理命令行工具，方便随时切换不同的go版本。作为一个版本管理工具，首要的一个功能就是可以随时获取到最新的go版本，以及所有可用的版本列表，go官方有一个API可以查询所有可用的版本列表，如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在通过该接口得到数据后，我尝试用go在1.21新加的一个库<code>go/version</code>来进行排序，可排序后得到的结果让人非常的诧异，示例代码如下所示</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的输出是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>排第一的版本是<code>go1.9.2rc2</code>，而不是最老的版本<code>go1</code>，发现这个问题后我去研究了下<code>go/verison</code>的源代码，发现了下面这一段</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大致意思就是说，补丁的预发布版本很少会使用到，且可能会产生歧义就将其视为非法的版本，而非法的版本总是会小于合法的版本，这就是为什么<code>go.1.9.2rc2</code>是最小的版本，编写这个标准库的正是go团队的主要领头人Russ cox。</p>
<p>虽然官方是这样说，但我并不认为这样就是正确的，目前我发现的拥有预发布版本的补丁版本总共有三个：</p>
<ul>
<li>1.8.5rc5</li>
<li>1.8.5rc4</li>
<li>1.9.2rc2</li>
</ul>
<p>尤其是<code>1.9.2rc2</code>，它既然可以在官方接口中可以被查询到，那就说明它是一个可用的版本，但很遗憾的是下面这段代码的结果是false。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将一个对外可用的版本视为非法的版本，这很明显就是错误的，于是我便想着自己修改，给Go语言提了一个issue：<a href="https://github.com/golang/go/issues/68634" target="_blank" rel="noopener noreferrer">Issue #68634 · golang/go</a>，并且后续向go发起了一个Pull Request来修复这一错误，由于我是第一次向go仓库贡献代码，中间做了许多额外的准备，所以便写下本文做一个记录。</p>
<h2> 准备</h2>
<p>在真正开始写代码之前，你需要做一些准备来符合PR的规范，否则官方不会受理你的代码。官方文档详细地描述了如何正确地向Go提交代码<a href="https://go.dev/doc/contribute#commit_messages" target="_blank" rel="noopener noreferrer">Contribution Guide - The Go Programming Language</a>。</p>
<h3> CLA</h3>
<p>CLA（Contributor License Agreement），中文名为开源贡献者协议，一般有两种，</p>
<ul>
<li>DCO：由linux基金会提出，社区属性比较强，每次提交的时候都要签署</li>
<li>CLA：由公司法务指定，具有一定法律性质，一次性签署，社区属性弱</li>
</ul>
<p>go是谷歌公司的产品， 向其贡献代码前就必须要签署<a href="https://cla.developers.google.com/about" target="_blank" rel="noopener noreferrer">Google CLA</a>，如下图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408010102024.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>有个人版和企业版，对于个人版而言仅需要提供你的名字和邮件联系方式即可，如果你未签署CLA就直接提交PR，github上会有机器人来提醒你签署CLA，在此之前你的PR不会被受理。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408010105232.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> Geerit</h3>
<p>Gerrit是谷歌开源的一个代码评审平台，可以企业自托管。go的代码审查也是用的gerrit，地址在<a href="https://go-review.googlesource.com/dashboard/self" target="_blank" rel="noopener noreferrer">Go |Gerrit Code Review</a>，界面大致如下图。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408010115925.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>你需要在这里注册一个账号，因为所有的PR都会被机器人转发到gerrit，负责代码审查的人员会在这里对你的代码提出规范和建议，所以不要在GitHub的PR页面做出任何回复和评论，机器人会告诉你到哪里去查看。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408010116746.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果你后续需要修改代码，只需要提交到Github上即可，代码审查的工作在Gerrit上进行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>建议在本地安装go官方的一个review命令行工具，下面是一些简单的用法</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 冻结期</h3>
<p>每年的5-7月，11-1月是go语言的冻结期，这段时间一般是为了发布新的次级版本而做准备，在这段时间内代码审查的工作会放缓，只有一小部分比较重要的更改会被合并，在此期间只接受修复已有的bug和文档更新类的修改，如果你是在这个时间点内提交其他类型的PR，可能会要等一段时间才会有回应，直到冻结期结束。</p>
<h2> 编码</h2>
<p>当你做好上述准备工作以后，就可以开始着手准备写代码了。</p>
<h3> 仓库结构</h3>
<p>go语言有很多仓库，它们无一例外全都托管谷歌仓库中，你可以在<a href="https://go.googlesource.com/" target="_blank" rel="noopener noreferrer">Git repositories on go | Google</a>查看到所有和go有关的项目，你也可以在<a href="https://github.com/golang" target="_blank" rel="noopener noreferrer">github.com/golang</a>组织下看到这些项目的镜像，不过并不是所有项目都保持活跃，有些可能被遗弃了，在提交代码的时候记得注意这一点。下面简单介绍下最主要的几个，你需要弄清楚自己做出的修改要提交到哪里去才行。</p>
<p><strong>主仓库</strong></p>
<p>地址：<a href="http://go.googlesource.com/go" target="_blank" rel="noopener noreferrer">go.googlesource.com/go</a></p>
<p>镜像：<a href="http://github.com/golang/go" target="_blank" rel="noopener noreferrer">github.com/golang/go</a></p>
<p>主仓库存放了go语言绝大部分代码，大部分修改都在这里进行，比如语法，运行时，gc，和一些标准库之类的。</p>
<p><strong>proposal</strong></p>
<p>地址：<a href="http://go.googlesource.com/proposal" target="_blank" rel="noopener noreferrer">go.googlesource.com/proposal</a></p>
<p>镜像：<a href="http://github.com/golang/proposal" target="_blank" rel="noopener noreferrer">github.com/golang/proposal</a></p>
<p>go语言提案库，所有涉及到go语言特性的重大变更都必须先在这里发起一个提案</p>
<p><strong>tools</strong></p>
<p>地址：<a href="http://go.googlesource.com/tools" target="_blank" rel="noopener noreferrer">go.googlesource.com/tools</a></p>
<p>镜像：<a href="http://github.com/golang/tools" target="_blank" rel="noopener noreferrer">github.com/golang/tools</a></p>
<p>对应<code>golang.org/x/tools</code>，tools仓库存放着一些官方编写的工具，比如goimports，stringer，gopls之类</p>
<p><strong>net</strong></p>
<p>地址：<a href="http://go.googlesource.com/net" target="_blank" rel="noopener noreferrer">go.googlesource.com/net</a></p>
<p>镜像：<a href="http://github.com/golang/net" target="_blank" rel="noopener noreferrer">github.com/golang/net</a></p>
<p>对应<code>golang.org/x/net</code>，net库是官方对net标准库的一个补充</p>
<p><strong>crypot</strong></p>
<p>地址：<a href="http://go.googlesource.com/crypto" target="_blank" rel="noopener noreferrer">go.googlesource.com/crypto</a></p>
<p>镜像：<a href="http://github.com/golang/crypto" target="_blank" rel="noopener noreferrer">github.com/golang/crypto</a></p>
<p>对应<code>golang.org/x/crypto</code>，是对crypto标准库的一个补充</p>
<p><strong>gofrontend</strong></p>
<p>地址：<a href="http://go.googlesource.com/gofrontend" target="_blank" rel="noopener noreferrer">go.googlesource.com/gofrontend</a></p>
<p>镜像：<a href="http://github.com/golang/gofrontend" target="_blank" rel="noopener noreferrer">github.com/golang/gofrontend</a></p>
<p>gccgo，go编译器前端</p>
<p><strong>vscode-go</strong></p>
<p>地址：<a href="http://go.googlesource.com/vscode-go" target="_blank" rel="noopener noreferrer">go.googlesource.com/vscode-go</a></p>
<p>镜像：<a href="http://github.com/golang/vscode-go" target="_blank" rel="noopener noreferrer">github.com/golang/vscode-go</a></p>
<p>go语言的vscode插件</p>
<p>里面还有很多项目，这里就不一一列出了，可以前往谷歌仓库自行查阅。</p>
<h3> 安全漏洞</h3>
<p>这篇文章详细说明了如何报告安全漏洞：<a href="https://go.dev/doc/security/policy" target="_blank" rel="noopener noreferrer">Go Security Policy - The Go Programming Language</a></p>
<p>如果你发现了安全漏洞，不要在github上提issue或PR，go有一个专门处理安全问题的团队，将你遇到的问题详细描述（用英文）然后发邮件给这个地址：security@golang.org，团队成功会尽快在7天内做出回复，为了避免被当成垃圾邮件，请确保邮件里面包含了<strong>vulnerability</strong>这个单词，意思就是漏洞，或者也可以去这里<a href="https://bughunters.google.com/report" target="_blank" rel="noopener noreferrer">Report Overview | Google Bug Hunters - Google Bug Hunters</a>反馈安全漏洞。</p>
<h3> 本地编译</h3>
<p>在决定好向哪一个仓库贡献代码后，用git将其克隆到本地，比如我这里是主仓库，使用Github地址与谷歌的地址是等效的，单纯是因为我更习惯Github上的操作。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在将代码拉下来后，首先要做的第一件事就是先编译go项目，编译器用的是本地go自带的gc，进入src目录（必须在src目录执行），执行make脚本，如果你是windows平台，就执行<code>make.bat</code>，其他平台就执行<code>make.bash</code>，在编译完成后，二进制文件会存放在go/bin目录下，工具链会存放在go/pkg目录下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>go仓库光是go代码就有250w+行，还不包含其他的一些文件，不过整体编译时间并不需要很久，测了下平均耗时在一分半左右。</p>
<p>官方准备了三种类型的脚本，它们的作用如下</p>
<ul>
<li>make.bash，仅编译</li>
<li>run.bash，不编译，运行所有的测试用例</li>
<li>all.bash，先编译，然后再运行所有的测试用例</li>
</ul>
<p>可以看自己的需要来使用哪一个。</p>
<h3> 代码规范</h3>
<p>在开始写代码之前，你首先需要创建一个新的分支，然后在新分支上做出修改，分支名称并没有严格规范，像github平时那样就好</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你每新建一个go文件，就需要在文件头部加上如下的注释，其中的年份是你提交修改的年份，注释中不要提及任何人的姓名</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你新建了一个包，就需要在包级注释中说明这个包是干什么用的，就像标准库<code>bytes</code></p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就是提交规范，这是官方给的一个示例</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行需要标注出影响范围和对本次提交的简短总结，必须以冒号分隔，如果有多个影响范围可以用逗号隔开，总结必须小写字母开头且尽量精简到76个字母以内，示例如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后是主要内容，不能使用markdown，html，latex等任何标记语言，这一部分需要描述的尽可能详细，需要说明起因和结果，并且附上尽可能详细的数据，比如修改的代码涉及到性能，可以附上基准测试的数据。下面是一个示例，该提交涉及到了内存逃逸方面。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后就是需要引用相关的issue，最好每一个PR都与一个issue相关联，方便溯源。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 本地测试</h3>
<p>在完成所有的编码工作后，你需要编写相应的单元测试，这一点是必须要做的。然后在src目录下（必须在src目录下执行）执行<code>all.bash/bat</code>脚本，该脚本会编译go代码并执行所有的测试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于需要将go代码中所有的测试都执行完，耗时可能会比较久，大概在10分钟左右，所有测试通过后会显示下面一行内容</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果你只是对某一个标准库做了修改，你也可以不用执行全部的测试，你可以使用编译好后的go指定执行某一个标准库的测试用例，比如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过我还是建议执行所有的测试用例，因为单独执行测试用例我基本上就没怎么成功过。</p>
<h3> Pull Request</h3>
<p>在完成所有的修改后，将其推送到Github，然后向go仓库发起Pull Request，如下图</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408011203739.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>过一会儿会有机器人来告诉你PR已经被转发到Gerrit</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408011205270.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>之后的代码审查工作就是在gerrit进行，gerrit的评论也会同步到Github，不过不要在这里做出任何回复。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如果你使用<code>git codereview mail</code>来将这些修改推送到gerrit，可能会有如下错误，因为Gerrit不接受来自中国IP的任何提交</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>并不是因为Go团队有地域歧视，原因看这个<a href="https://github.com/golang/go/issues/20065" target="_blank" rel="noopener noreferrer">access to Gerrit denied because of location · Issue #20065 · golang/go (github.com)</a>。如果你不想换IP的话，可以在Github上发PR让机器人帮你推送到Gerrit上，这样是最简单的方式</p>
</div>
<h2> 代码审查</h2>
<p>代码审查的流程是最长的，如果你是社区贡献人员（谷歌员工的PR合并会快很多），并且改动比较大的话，那么通常需要好几轮审查才能确认将代码合并到主线当中，这一过程可能会耗时一两个星期甚至一个月。</p>
<p>大多数第一次提交代码的人会犯一些比较典型的错误</p>
<ul>
<li>提交信息不符合规范</li>
<li>缺少对Github Issue的引用</li>
<li>在冻结期提交修改</li>
</ul>
<p>第一点是最重要的，因为你的提交会被合并到主线当中，所以必须要符合规范。第二点的话如果你只是改了个注释或者什么其他微不足道的修改，也不需要引用issue。第三点其实也没那么重要，时间一过自然会发邮件通知审查你的代码的，无非只是等的时间长了点。</p>
<h3> 审查人员</h3>
<p>审查人员大多都是go团队的成员或者是谷歌公司的员工，以及部分社区人员组成，PR被转发到Gerrit后，如果你是第一次向Go贡献代码的话，为了避免这是垃圾邮件可能要过一段时间才会来审查的你的代码。如果有需要的话，你也可以直接指定谁来审查你的代码</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408011510744.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>你可以在Change Info部分中指定审查人员和CC</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408011511213.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>或者你也可以用命令行的方式</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通常来说对于第一次贡献代码的人来说，如果你不知道指定谁，可以先发个issue看看，有哪些人会回答你的问题，如果他刚好是维护者的话就可以指定他来审查。如果你没有指定，那么系统也会自动为你分配审查人员的。</p>
<h3> Trybots</h3>
<p>当一个审查人员初步浏览了你的代码后，会启动Trybots，来进行自动化测试，就跟之前在本地测试的一样，不同的是trybots会在各个不同的环境进行测试，就跟Github Actions差不多类似。如果运行失败了，就需要查明哪里出了问题，然后修改代码重新提交。</p>
<h3> 投票</h3>
<p>审查人员和其他无关的第三方人员都可以给你的PR投票，第三方人员可以投一个<code>+1</code>，表示这个代码写的还不错，但还需要审查人员来进行评审，只有在获得审查人员的<code>+2</code>投票后，代码才能被合并，如果审查人员给你投了一个<code>+1</code>的话表示代码整体可以，但还需要做一些小的修改。</p>
<p>总的来说，如果你的PR想要被合并，就必须要两名审查人员的参与，至少一个<code>+1</code>和<code>+2</code>投票才能继续流程。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408011536498.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>对于一个PR而言，通常决定能否提交的指标下面这几个</p>
<ul>
<li>CR（code-review）：表示codereview是否完成</li>
<li>NUC（non-unresolved-comment）：，没有未处理的审查</li>
<li>RE（Review-enforcement）：执行了codereview</li>
<li>TP（trybots-passes）：trybots测试通过</li>
</ul>
<p>如果你是其他类型的修改可能会需要完成更多的CI测试，比如KCP（kokoro-CI-Passes），LP（LUCI-Passes），LTP（legacy-trybos-passes）等等，如果对应的CI测试通过了就会加分，相应的如果失败了就会扣分。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408011541602.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 修改</h3>
<p>一般来说很少会有一次性通过的代码，审查人员会检查你代码中的逻辑错误，即便是一些注释问题也会指出来，这时候他们会留下评论，如下图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408011548843.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果你是通过Github机器人来与Gerrit交互的，那么你只需要将你本地的代码推送Github上就行了，机器人会自动更新修改，完成一个评论后点击Done按钮来告诉审查人员已解决。</p>
<h3> 合并</h3>
<p>当所有的工作都完成且通过，没有任何异议的时候，代码就会被合并，如下图所示。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408011543561.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>想要被顺利合并通常要花费不少时间，不要着急就对了。</p>
<h2> 总结</h2>
<p>给Go贡献代码并不只是简单的写代码做修改就完事了，要注意的流程和规范非常多，这样严格管理的好处是不容易出问题，能够保证代码质量。这一套codereview流程，对于刚接触的人来说会觉得很繁琐和麻烦，不过熟悉了过后就没什么了，了解这一套codereview流程也便于养成好的编程习惯，毕竟谷歌是由数万人组成的大型公司，良好的规范可以让屎山堆的更慢一些。</p>
]]></content:encoded>
      <enclosure url="https://spf13.com/presentation/how-to-contribute-to-go/front.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>使用Makefile来构建Go程序</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/makefile.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/makefile.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">使用Makefile来构建Go程序</source>
      <description>使用Makefile来构建Go程序</description>
      <category>go</category>
      <pubDate>Fri, 26 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 使用Makefile来构建Go程序</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408271022015.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<h2> 简介</h2>
<p>Make起源于1977年的贝尔实验室中，目的就是为了能更好的构建大型程序，贝尔实验室的大型程序自然就是Unix操作系统。在后来诞生了它的许多变种，比较知名是下面两个。</p>
<ul>
<li>GNU Make</li>
<li>BSD Make</li>
</ul>
<p>GNU Make应该是现在用的最多的一个，Linux和MacOS都是用的GNU Make，本文在讲解的时候也会使用这一个。Makefile在C/C++项目中用的比较多，但它并不限制于特定的语言，Go同样也可以使用Makefile来构建程序，不过由于Go是一个比较现代化的语言，在编译时它已经将大部分事情都做好了，不需要我们去处理依赖，链接等，所以也就很少会用到makefile中那些复杂的规则，用的最多的也就是<code>.PHONY</code>伪目标来执行特定的命令。</p>
<h2> 语法</h2>
<p>本文这里只是简单介绍下makefile中的语法，如果你想进行细致的学习的可以前往<a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener noreferrer">Document | GNU make</a>进行了解。</p>
<h3> 伪目标</h3>
<p>makefile是由一个个目标（target）组成的，在makefile中目标表示的文件，Go中不需要对文件单独处理，所以我们会使用伪目标，表示它只执行命令，我们会用<code>.PHONY</code>来表示它是一个伪目标，如下。</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在目标中执行的命令必须要用tab进行缩进，如果你觉得一行命令太长可以用<code>\</code>来换行，记得换行符后面不要有任何字符。</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行看看效果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会发现它将要执行的命令打印出来了，如果你不想这么做可以加上<code>-s</code>标志</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者在<code>echo</code>命令前加上<code>@</code></p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>两种方法都可以阻止make打印命令。</p>
<h3> 变量</h3>
<p>makefile中的变量用<code>=</code>来进行赋值，比如</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>变量没有类型，全都是字符串，没有被赋值的变量就是一个空字符串，赋值时必须要用空格相隔，不需要双引号也可以表示字符串</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果只是输出的话他们并没有什么区别，但实际上两者并不相等</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的结果会是不相等</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用的时候就需要稍微注意一下。</p>
<p>变量取值的时候可以用<code>$(var)</code>或者<code>${var}</code>两种方法获取变量的值，比如</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用<code>=</code>定义的变量默认是懒加载的，在使用到的时候才会展开，而用<code>:=</code>定义的变量会立即展开，如下</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里例子中变量<code>two</code>是被<code>:=</code>定义的，在它展开时变量<code>three</code>还未被定义，所以它就是一个空字符串。</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>shell</code>函数，可以将执行命令的返回值赋值给变量</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也可以不理会返回值，仅执行命令。</p>
<h3> 条件</h3>
<p>makefile中条件判断有下面几种</p>
<ul>
<li>
<p><code>ifeq</code>，判断是否相等</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code>ifneq</code>，判断不相等</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code>ifdef</code>，判断变量是否定义</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code>ifndef</code>，判断变量是否未定义</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> 循环</h3>
<p>makefile中的循环实际上是一个函数，格式如下</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它最终会将处理后的元素返回成一个新数组，如果你只是用作循环也可以完全不管这个返回值。在makefile中，由空格作为分隔符的字符串可以看作是数组，如下</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>迭代这个数组，然后将名字拼接成新字符串，然后返回一个新数组</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终输出</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以是多重循环</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 递归</h3>
<p>对于一个目标而言，我们可以在目标中使用<code>$(make)</code>来进行递归，比如下面这一个例子</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子中会无限递归执行目标<code>hello</code>。你也可以用这种方法执行其他目标</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归的原本目的是为了解析子文件夹下的makefile，所以它会显示<code>Entering directory</code>表示进入某个文件夹，如果你不想看到这些输出加上<code>-s</code>标志执行就行了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 替换</h3>
<p>字符串替换使用<code>$(patsubst)</code>来完成，它有下面几个参数</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通常我们会使用它的简写方式，通配符<code>%</code>表示匹配的部分</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>比如</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么它最后会是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 注释</h3>
<p>makefile中的注释由<code>#</code>来表示</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>值得一提的是，在执行目标的时候，如果没有设置静默输出的话，注释也会一并打印出来。</p>
<h2> 构建</h2>
<p>在简单地解了上面的几种语法后，对于构建Go程序而言已经完全足够使用了，你可以通过编写如下的makefile来编译一个go程序。</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但如果只是这么简单的使用，实在是没有必要使用makefile，集成开发环境就能满足了，所以我们要写点复杂的。</p>
<p>比如可以在编译前进行代码检查</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者进行交叉编译时，设置环境变量</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过这些还是太简单了，其实通过makefile更轻松的给程序注入元信息，进行其他的一些处理，比如下面是我自己经常用的一个makefile模板，做的处理就非常多了。</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个模板基本上满足大部分Go项目的需求了，假如说要多平台编译的话，还可以再加上下面这段</p>
<div class="language-makefile line-numbers-mode" data-ext="makefile"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过双循环执行目标<code>build</code>，这样一来就可以将所有预定平台的二进制文件全部自动编译出来，完整版在这里<a href="https://gist.github.com/246859/1a36cc805b96fb3cc164c70a1df9bee6" target="_blank" rel="noopener noreferrer">makefile | Github Gist</a>。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408271022015.png" type="image/png"/>
    </item>
    <item>
      <title>go语言操作windows注册表</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/registry.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/registry.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">go语言操作windows注册表</source>
      <description>go语言操作windows注册表</description>
      <category>go</category>
      <pubDate>Wed, 24 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> go语言操作windows注册表</h1>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407241437452.png" style="zoom:200%;">
<!-- more -->
<hr>
<h2> 简介</h2>
<p>注册表是windows中很重要的一个功能，通过它可以实现很多功能，在Go语言中操作注册表就目前而言有三种方式</p>
<ol>
<li>命令：通过<code>exec.Command</code>执行<code>REGINI</code>命令来操作注册表，效率较低</li>
<li>系统调用：在<code>syscall/zsyscall_windows.go</code>文件中包含了所有的注册表操作的系统调用，用编程的方式进行操作</li>
<li>库：go官方编写了注册表库<code>registry</code>，其原理就是封装了系统调用</li>
</ol>
<p>很显然，使用官方编写的库效率是最高的，不过它并没有加入标准库，需要我们单独下载。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 示例</h2>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大部分注册表操作都是基于这些windows预定义好的键，库中以常量的方式定义了这些键，可以直接使用。操作一个注册表项的API跟操作文件没什么太大的区别，使用完后一样要关闭。</p>
<h3> 新建</h3>
<p>下面演示一个创建GoLand右键菜单项的例子。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>首先如果要修改右键菜单的话，就需要基于<code>CLASSES_ROOT</code>键，rootKey作为第一个参数，子路径作为第二个参数传递</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第三个参数是<code>access</code>，就类似于访问文件的<code>perm</code>一样，关于这个的详细释义可以看<a href="https://learn.microsoft.com/zh-cn/windows/win32/sysinfo/registry-key-security-and-access-rights?redirectedfrom=MSDN" target="_blank" rel="noopener noreferrer">注册表项安全和访问权限 - Win32 apps | Microsoft Learn</a>，那么代码如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后给它设置两个字符串值，类型为<code>REG_EXPAND_SZ</code>或<code>REG_MULTI_SZ</code>都行，键为空就表示默认值，内容会展示到菜单上，<code>Icon</code>即图标。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再创建一个子项<code>command</code>，表示动作</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>它的默认值就是goland程序的地址</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>完整代码如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是在运行时必须要以管理员模式执行，否则会拒绝访问。</p>
<p>成功后效果如下</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407241536810.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 删除</h3>
<p>如果要删除一个注册表项，那么它必须没有子项才能成功删除，否则会返回错误</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以必须要先递归删除它的所有子项才行，我们可以编写下面一个简单的函数</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p>总的来说使用官方的API是最简单的，库函数加起来也没几个，非常易于使用。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407241536810.png" type="image/png"/>
    </item>
    <item>
      <title>Debian12 安装教程</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/linux/debian12_install.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/linux/debian12_install.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Debian12 安装教程</source>
      <description>Debian12 安装教程 以前在个人电脑上一直使用的是Ubuntu，Debian仅作为服务器使用，作为前者的上游分支，Debian是一个完全开源稳定的操作系统，这次打算将其安装到本地的vmware，于是写下本文记录。</description>
      <category>linux</category>
      <pubDate>Mon, 22 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Debian12 安装教程</h1>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221436679.png" style="zoom:200%;">
<p>以前在个人电脑上一直使用的是Ubuntu，Debian仅作为服务器使用，作为前者的上游分支，Debian是一个完全开源稳定的操作系统，这次打算将其安装到本地的vmware，于是写下本文记录。</p>
<!-- more -->
<hr>
<h2> 准备</h2>
<p>Debian在国内有中文论坛，有什么问题可以去论坛搜索：<a href="https://forums.debiancn.org/" target="_blank" rel="noopener noreferrer">Debian中文论坛 - (debiancn.org)</a></p>
<p>官方网站完全支持中文：<a href="https://www.debian.org/" target="_blank" rel="noopener noreferrer">Debian -- 通用操作系统</a></p>
<p>中文安装手册：<a href="https://www.debian.org/releases/stable/amd64/" target="_blank" rel="noopener noreferrer">Debian GNU/Linux 安装手册</a></p>
<p>Vmware官网：<a href="https://www.vmware.com/content/vmware/vmware-published-sites/cn/products/workstation-pro/workstation-pro-evaluation.html.html.html" target="_blank" rel="noopener noreferrer">下载 VMware Workstation Pro | CN</a></p>
<p>你需要有：</p>
<ul>
<li>基本的Linux使用能力</li>
<li>了解vmware的基本使用</li>
<li>一台足以支持Vmware12+运行的电脑</li>
<li>内存建议2GB以上</li>
<li>磁盘空间建议有20GB以上的剩余</li>
</ul>
<h2> 安装</h2>
<p>截至本文写下的时候，我的电脑系统是win10，Debian发行版已经来到了12.6，下面将讲述Debian12在Vmware16中的安装过程作为参考，最终目标即为系统可以与宿主机建立SSH连接，且能正常联网安装软件。</p>
<h3> 镜像</h3>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221459871.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>普通用户安装的时候镜像一般会用以下两种</p>
<ul>
<li>网络版（netinst）：只包含操作系统运行所需要的最基本工具，其他软件需要在安装时联网下载，大小600MB左右。</li>
<li>DVD版（dvd）：内置了大部分系统工具和软件，支持离线安装，大小为3.5GB左右。</li>
</ul>
<p>网络版在安装过程中的软件下载阶段默认使用的是官方的安全源，对于国内用户而言会极其缓慢，除非临时修改<code>sources.list</code>为国内源，而且只能手敲，关于这个问题你可以在网络上找到很多类似的回答，足以见得有多麻烦。</p>
<p>所以我的建议是使用DVD版，因为它支持离线安装，可以将操作系统完全安装成功后再去修改国内源，这种做法较为方便。</p>
<p><strong>下载</strong></p>
<p>中科大镜像站提供的国内下载链接</p>
<p>网络版：<a href="https://iso.mirrors.ustc.edu.cn/debian-cd/current/amd64/iso-cd/debian-12.6.0-amd64-netinst.iso" target="_blank" rel="noopener noreferrer">https://iso.mirrors.ustc.edu.cn/debian-cd/current/amd64/iso-cd/debian-12.6.0-amd64-netinst.iso</a></p>
<p>DVD版：<a href="https://iso.mirrors.ustc.edu.cn/debian-cd/current/amd64/iso-dvd/debian-12.6.0-amd64-DVD-1.iso" target="_blank" rel="noopener noreferrer">iso.mirrors.ustc.edu.cn/debian-cd/current/amd64/iso-dvd/debian-12.6.0-amd64-DVD-1.iso</a></p>
<p>后续安装过程我会使用DVD版来进行讲解。</p>
<h3> 创建</h3>
<p>选择创建新的虚拟机，使用自定义创建</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221520993.png" style="zoom: 67%;">
<p>硬件兼容性看个人喜好，版本越低兼容性越好，如果你的电脑比较老的话建议选12</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221523400.png" style="zoom:67%;">
<p>选择稍后安装操作系统</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221524047.png" style="zoom:67%;">
<p>在客户机操作系统这一步选择Linux和Debian10.x 64位，列表中最高版本也只有10.x，不过这并不会有什么影响。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221525396.png" style="zoom:67%;">
<p>指定安装位置，建议放在除C盘以外的其他盘，因为虚拟机大小基本上20G起步，比较占空间。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221527410.png" style="zoom:67%;">
<p>CPU，内存，磁盘空间根据自己电脑的配置来选择，我的电脑有16核40G内存，所以这里选择的配置稍微高了一些，一般情况下默认就足够了。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221528163.png" style="zoom:67%;">
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221529720.png" style="zoom:67%;">
<p>网络类型看个人需要，关于三种网络模式的详解请看：<a href="https://www.cnblogs.com/linjiaxin/p/6476480.html" target="_blank" rel="noopener noreferrer">Vmware虚拟机三种网络模式</a>，我一般使用桥接模式。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221538790.png" style="zoom:67%;">
<p>IO控制器和磁盘类型都建议默认选项</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221539872.png" style="zoom:67%;">
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221540143.png" style="zoom:67%;">
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221540493.png" style="zoom:67%;">
<p>磁盘容量建议设置20G以上，虚拟磁盘的存储类型根据个人需要来进行设置，建议选择存储为单个文件。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221540005.png" style="zoom:67%;">
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221542662.png" style="zoom: 67%;">
<p>到最后一步，选择自定义硬件</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221542031.png" style="zoom:67%;">
<p>然后在CD/DVD中设置之前下载好的系统镜像</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221543273.png" style="zoom: 50%;">
<p>到此虚拟机创建完毕，接下来是操作系统的引导过程。</p>
<h3> 引导</h3>
<p>启动虚拟机，会有下面这样一个界面，第一个是图形化安装，第二个是命令行安装，下面会以图形化安装的方式进行。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221552944.png" style="zoom:67%;">
<p>选系统语言和输入法</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221555755.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221555285.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221555031.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>随后Debian会自动设置必要的安装组件以及配置网络，主机名随便取，域名建议留空</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221557516.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221557323.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后设置root用户和登录用户的账号密码</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221558015.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221559859.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221600786.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>磁盘分区根据个人喜好来选择，第一种最省事</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221601879.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221601586.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221601544.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>磁盘分区设置好后Debian就会进行系统的基本配置，然后接下来配置软件包管理器就是重点了。选择否不扫描其他安装介质，因为我们并没有用驱动器进行安装。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221603856.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最重要的是镜像站点的选择这一步，如果你对自己的网速没有自信的话（不然下载三小时起步）建议选择否，即便你的网速很快我也建议不要使用镜像站点，因为系统安装好后有的是时间去配置镜像站点。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221605768.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>是否参与调查看自己</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221608484.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>软件选择这块除了最下面三个，其他全是桌面环境，如果你不喜欢桌面环境也可以不要，不过记得勾选SSH Server。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221650391.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221612558.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>安装GRUB引导器，虚拟机不需要在乎这个，一般是电脑装有双系统的时候才需要注意。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221613449.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>选择<code>/dev/sda</code>分区，之前配置了全部文件都放在一个分区里面</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221615757.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后Debian会结束安装进程</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221615564.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221616619.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 配置</h3>
<p>重启后登录用户</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221654698.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>完成输入法语言账号之类的初始配置即可使用</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221655893.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>debian12的登陆用户默认不会拥有sudoer的权限，所以我们要手动添加，文件位于<code>/etc/sudoers</code>，在<code>%sudo ALL=(ALL:ALL) ALL</code>的下面添加下面这一行，然后保存。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221807337.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后在Vmware中选择安装Vmware Tools，默认存放在<code>/media/cdrom0</code>文件夹中。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221702020.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>将其解压，建议解压到其他地方，我这里解压到了<code>/var/lib</code>下</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221716772.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后运行<code>vmware-install.pl</code>脚本，</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>过程中全部默认选项，完成后虚拟机就能以正常的分辨率显示了。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221720013.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>ping一下网络确实可以访问</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221722385.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>但此时apt是用不了的，因为我们是离线安装，需要去修改<code>/etc/apt/sources.list</code>里面的内容，这里使用的是中科大源。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用nano编辑（因为此时vim还没有安装）</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221731813.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>执行命令更新源</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221733972.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>安装vim测试一下</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221734043.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>目前基本上已经安装完毕，但还差最后一步，就是ssh，安装<code>net-tools</code>后执行<code>sudo ifconfig</code>命令查看虚拟机IP。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221737788.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后宿主机尝试下是否能ping通，可以看到并没有问题</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221738575.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>修改ssh配置文件<code>/etc/ssh/sshd_config</code>，设置端口22。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221743971.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>重启ssh服务</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221745258.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此时虚拟IP地址为<code>192.168.43.168:22</code>，最后能进行ssh连接即可，我这里用的是xshell，用的密码登录。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221751405.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221752221.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221752242.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到此debian12的安装已经完成。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202407221459871.png" type="image/png"/>
    </item>
    <item>
      <title>docker安装mysql和redis</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/docker/docker_mysql.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/docker/docker_mysql.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">docker安装mysql和redis</source>
      <description>docker安装mysql和redis</description>
      <category>docker</category>
      <pubDate>Thu, 29 Jun 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> docker安装mysql和redis</h1>
<figure><img src="https://w.wallhaven.cc/full/ex/wallhaven-ex9gwo.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<h4> Mysql</h4>
<p>首先拉取mysql的镜像，要确保major版本是8，例如8.0.33</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里要创建mysql的挂载文件夹，以防数据丢失，这里放在<code>/root/mysql</code>路径下为例子</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随后在<code>/root/mysql/confg/</code>目录下创建<code>my.cnf</code>文件，内容如下</p>
<div class="language-ini line-numbers-mode" data-ext="ini"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后运行如下命令启动容器即可，下面分别创建了mysql日志，mysql数据库，mysql配置的挂载数据卷，这里的<code>MYSQL_ROOT_PASSWORD=123456</code>就是数据库的root密码，可以自己改成其他的，环境变量<code>MYSQL_DATABASE=dst</code>会自动创建一个名为dst的数据库，按需修改。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建完成后登录mysql看看成功没有</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到有dst数据库就说明mysql成功安装.</p>
<p>到此安装成功，然后记录下数据库的密码，后面后端会用到。</p>
<h4> Redis</h4>
<p>首先拉取redis镜像，保证redis版本在6以上</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建redis的挂载目录</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入<code>~/redis/</code>目录，创建配置文件<code>redis.conf</code>，内容如下，密码自己定。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后运行容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>redis默认不允许远程访问，所以需要额外配置，修改配置文件如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>redis各版本配置文件：<a href="https://redis.io/docs/management/config/" target="_blank" rel="noopener noreferrer">Redis configuration | Redis</a></p>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/ex/wallhaven-ex9gwo.png" type="image/png"/>
    </item>
    <item>
      <title>Docker安装nginx</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/docker/docker_nginx.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/docker/docker_nginx.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Docker安装nginx</source>
      <description>Docker安装nginx docker安装nginx</description>
      <category>docker</category>
      <pubDate>Thu, 29 Jun 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Docker安装nginx</h1>
<figure><img src="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>docker安装nginx</p>
<!-- more -->
<hr>
<p>Docker安装nginx时一般都是直接使用命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但后来还是觉得直接把静态文件打包进镜像可能会更加方便些</p>
<div class="language-docker line-numbers-mode" data-ext="docker"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行命令</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>目录下的html是打包好的静态文件，nginx是nginx配置文件夹。</p>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/zy/wallhaven-zyxvqy.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Docker容器磁盘热扩容</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/docker/expand.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/docker/expand.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Docker容器磁盘热扩容</source>
      <description>Docker容器磁盘热扩容 本文主要讲解Docker容器磁盘热扩容，不需要重启docker服务，也不需要重启容器</description>
      <category>docker</category>
      <pubDate>Sat, 20 May 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Docker容器磁盘热扩容</h1>
<figure><img src="https://w.wallhaven.cc/full/9m/wallhaven-9mjoy1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本文主要讲解Docker容器磁盘热扩容，不需要重启docker服务，也不需要重启容器</p>
<!-- more -->
<hr>
<p>最近项目里的需求需要实现Docker容器的热扩容，前一阵子给Docker驱动换到了<code>devicemapper</code>，对容器的资源限制可以更加精确和友好，刚好记录一下整个过程。</p>
<h2> 环境准备</h2>
<p>系统：ubuntu22.04LTS</p>
<p>Docker：24.00</p>
<p>Go版本：1.20.4</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在开始之前你需要确保Docker驱动是<code>devicemapper</code>，并且宿主机和Docker的文件系统是<code>ext4</code></p>
</div>
<h2> 查看容器大小</h2>
<p>这里拿一个nginx容器做实验，先进入容器查看一下大小，一般在创建容器时若不指定默认大小为10G。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到rootfs的size是11G，并且文件系统类型是<code>ext4</code>，这里需要将<code>/dev/mapper/docker-8:3-2097855-40ca4227a94fe9cd1dc00963961cc16c8fc0bd6d650e72cfc0c10bc34a9c08f6</code>记下来，后续操作会用到。</p>
<h2> 准备扩容</h2>
<p>这时回到宿主机，查看之前复制的文件系统名占用的磁盘扇区数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到扇区数是从0到20971520，假设要扩容到20G，需要的扇区数就是<code>20*1024*1024*1024/512=41943040</code>，然后再修改表</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>重载一下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看扇区数</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到扇区已经变成了41943040，最后需要调整文件系统的大小</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 确认大小</h2>
<p>再次进入容器查看</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到确实变成了20G。</p>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/9m/wallhaven-9mjoy1.png" type="image/png"/>
    </item>
    <item>
      <title>Win10重置电脑</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/windows/win10_reset.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/windows/win10_reset.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Win10重置电脑</source>
      <description>Win10重置电脑</description>
      <category>windows</category>
      <pubDate>Fri, 19 Jul 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Win10重置电脑</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202407191536182.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>我的电脑一直以来都是用的win10，因为觉得win11华而不实，除了UI界面好看点外没什么用。最近因为软件和文件安装多了看着心烦，想要把win10重置以后重新分配空间，这样来的的清净些，当我把备份做好后，准备重置时就出现了下面的提示。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202407191536373.png" style="zoom: 80%;">
<p>因为我以前重置过一次，所以记得自带的重置功能是不需要外部介质（U盘之类）的，不过我也是第一次遇到这种情况，于是写下本文当作一个记录。</p>
<h2> 问题</h2>
<p>在网上查找了一下后，发现是因为<code>C:\\Recovery\\WindowsRE</code>文件缺失了，通过<code>reagentc</code>命令来查看重置软件的启用情况，如下所示。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面可以看到<code>Windows RE 位置</code>是空的，以及<code>reagentc /enable</code>启用失败，说明WindowsRE文件确实是缺失了。</p>
<h2> 解决</h2>
<p>我们需要下载win10的ISO镜像，并从中获取<code>Winre.wim</code>文件，然后复制到电脑的对应位置，这里推荐用系统库下载<a href="https://www.xitongku.com/index.html" target="_blank" rel="noopener noreferrer">MSDN系统库－致力于原版windows生态服务 (xitongku.com)</a>，微软目前不再提供ISO镜像下载了。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202407191617009.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>提取ISO中的目标文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>得到文件后将其放入本机的<code>C:\\Recovery\\WindowsRE\\</code>目录下，然后通过命令行设置文件位置。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再通过<code>reagentc /enable</code>命令启用即可。</p>
<h3> bitlocker</h3>
<p>有时可能会出现这种情况</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>BitLocker</code>是驱动器加密的一种技术，在win10<code>设置 &gt; 更新和安全 &gt; 设备加密</code>中关闭即可。</p>
<h3> 无恢复分区</h3>
<p>有一种情况是，电脑没有恢复分区时，重启后的蓝屏界面将不会有重置电脑的选项，如下图。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202407191734992.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>首先需要确保电脑是否有恢复分区，下图中是我电脑上的分区情况，如果没有的话就需要手动创建，否则无法正常进行重置操作。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202407191734024.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>恢复分区最好是和C盘在一个磁盘中，且在C盘前后，空间大小要求400MB左右，我这里给足空间直接设置了2GB（或许以后会有更新，所以预留足够的空间），NTFS，并且不需要卷标，其它全部默认设置。待分区创建完毕后就需要将其进行配置。</p>
<p>首先禁用恢复设置，这里必须先禁用否则后续的设置不会生效</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过<code>reagentc</code>命令重新指定WindowsRE文件位置，记得将<code>Winre.wim</code>文件移动新分区中的对应位置。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再重新启用</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置完毕后，通过<code>diskpart</code>对恢复分区进行配置，首先通过<code>list disk</code>命令列出所有的磁盘</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后执行命令<code>sel disk</code>选中恢复分区所在磁盘，这里我只有一个所以就选中磁盘0，</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后用<code>list part</code>列出该磁盘中所有的分区</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后选择该分区</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分区5的大小是2047MB也就是恢复分区，接下来通过修改分区ID来将其标记为恢复分区，windows下恢复分区的ID是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行如下命令设置ID即可</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后设置属性</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后一定要退出，不然不会生效。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时重新打开磁盘管理工具就会显示恢复分区了。</p>
<p>重新创建后的恢复分区会在资源管理中可见，如果想临时隐藏可以通过如下命令来临时删掉盘符</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>倘若要永久隐藏的话可以修改其属性即可</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202407191536182.png" type="image/png"/>
    </item>
    <item>
      <title>AutoToolBox</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/autotoolbox.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/autotoolbox.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">AutoToolBox</source>
      <description>AutoToolBox 一个用Go编写的小工具 - Windows下ToolBox菜单自动生成器</description>
      <category>技术日志</category>
      <category>go</category>
      <pubDate>Sun, 23 Oct 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> AutoToolBox</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/toolbox.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一个用Go编写的小工具 - Windows下ToolBox菜单自动生成器</p>
<!-- more -->
<hr>
<h2> 简介</h2>
<p>更新：时隔六年JetBrains终于开始尝试解决上下文菜单的问题，但菜单项是隐藏在打开方式里面的，仅对文件起作用，对于目录和目录背景并不生效，这明明只是一个很简单的功能，却迟迟不支持，所以本项目依旧有存在的必要性。</p>
<p>原问题链接：<a href="https://youtrack.jetbrains.com/issue/TBX-2540/Associate-file-extenstions-with-correct-Toolbox-app-or-with-the-Toolbox-itself-so-that-files-can-be-launched-from-Windows" target="_blank" rel="noopener noreferrer">TBX-2540 (jetbrains.com)</a> <a href="https://youtrack.jetbrains.com/issue/TBX-2478/Windows-Open-Directory-With-Editor" target="_blank" rel="noopener noreferrer"> TBX-2478 (jetbrains.com)</a></p>
<h2> 简介</h2>
<p>这是一个很简单的命令行工具，用于给Toolbox App添加windows右键菜单，它具有以下特性：</p>
<ul>
<li>更新或回退版本不会导致菜单失效（同时存在多个版本的IDE时，只会导向最新版）</li>
<li>可设置通过管理员权限打开IDE</li>
<li>无需手动维护注册表，</li>
<li>菜单项的排列顺序与Toolbox中的同步</li>
<li>能很轻易的删除，不会保留任何注册表项的残留</li>
</ul>
<p>下面是效果图</p>
<img src="https://github.com/246859/AutoToolBox/raw/main/image/preview.png" alt="效果图" style="zoom: 67%;">
<h2> 安装</h2>
<p>如果你拥有go环境，并且版本大于go1.16，可以采用<code>go install</code>的方式来安装，如下所示</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者直接在Release里面下载最新版的二进制文件。</p>
<h2> 使用</h2>
<p>3.0版本的工具使用起来简单了很多，虽然多了几个命令但大多数情况下都用不上，唯一需要的路径参数就是Toolbox的安装路径，一般情况下Toolbox被默认安装在如下路径。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>工具在默认情况下使用上述路径，不需要额外指定参数，如果安装路径被修改了则需要用<code>-d</code>来指定（最好不要修改Toolbox的安装路径）。</p>
<p>请确保设置中的<strong>生成Shell脚本</strong>处于打开状态，否则工具无法正常工具。</p>
<img alt="shellpath" src="https://github.com/246859/AutoToolBox/raw/main/image/shellpath.png" width="500" height="200/">
<h3> 迁移</h3>
<p>如果你是旧版工具的使用者，且想要升级到新版，可以使用旧版生成的<code>toolboxRemove.reg</code>将旧版注册表删除，然后再按照下面的方法使用新版即可。</p>
<h3> 开始</h3>
<blockquote>
<p><strong>工具需要管理员权限才能正常运行</strong></p>
</blockquote>
<p>安装好后执行如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就可以将所有本地安装的IDE添加到右键菜单中，这是最简单的使用方法，大多数情况下只会用到这一个命令。</p>
<h3> 命令</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面简单讲一下每个命令的大概作用</p>
<h4> list</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>list</code>命令用于查看本地所有已安装的IDE，例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看数量</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>查看所有已添加到菜单中的项</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看已添加到菜单中的项的数量</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> set</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>set</code>命令表示将哪些IDE设置为菜单项，会直接覆盖现有的菜单，菜单的展示顺序与Toolbox界面中的相同。</p>
<p>最简单的使用方法就是直接将全部IDE设置为菜单项，如果本地的IDE数量超过了16个，那么只会添加前16个，这是因为windows菜单项的最大限制就是16个。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者单独指定</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果你需要以管理员权限来运行IDE，那么可以加上<code>--admin</code>，就像下面这样，</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>--update</code>时只会更新现有的菜单项，不会添加新的菜单。如果同一个IDE存在多个版本，该命令可以将其导向最新版。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在注册菜单时可以使用<code>--top</code>来让Toolbox菜单位于置顶的位置</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><br>
<p>需要注意的是，有一些产品既没有提供稳定的shell脚本路径，也没有提供<code>exe</code>文件的位置，下面几个就是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然现阶段可以将其添加到菜单中，但它们的文件结构并不像其他IDE一样具有条理，<code>list</code>命令会展示出现哪些工具暂不支持，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于它们而言，暂时不会被添加进菜单中。</p>
<h4> add</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>add</code>命令的区别在于它会向已有的菜单中添加新的菜单项，而不是像<code>set</code>一样直接覆盖，用法大体上一致。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不过它并不支持<code>-a</code>，不能一次性添加所有IDE。</p>
<h4> rmove</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>remove</code>命令用于删除菜单项</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>-a</code>来删除所有</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> clear</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令<code>clear</code>会直接清空所有与Toolbox有关的菜单项，包括顶级菜单，且不会有任何输出。如果你不想再使用本工具，可以用该命令将所有注册表项清理干净。</p>
<h2> 贡献</h2>
<ol>
<li>Fork本仓库到你的账号</li>
<li>在Fork的仓库中创建一个新的分支</li>
<li>在新分支中提交代码修改</li>
<li>然后向本仓库发起Pull Request</li>
<li>等待Pull Request</li>
</ol>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/toolbox.png" type="image/png"/>
    </item>
    <item>
      <title>位运算保存状态</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/bitflag.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/bitflag.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">位运算保存状态</source>
      <description>位运算保存状态</description>
      <category>技术日志</category>
      <category>go</category>
      <pubDate>Wed, 29 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 位运算保存状态</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311291911647.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<h2> 理论</h2>
<p>在go里面，没有提供枚举这一类型，所以我们会通过声明常量来表示一些特定的状态，比如下面这种形式</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>const</code> + <code>iota</code>的方式来定义一些状态，这样做的缺点在于，一个变量只能同时存储一个状态，如果要同时表示多个状态，就需要使用多个变量，而使用位来存储这些状态可以很好的解决这种问题，其过程只涉及到了简单的位运算。</p>
<p>比特位存储状态原理是每一个比特位表示一个状态，1表示拥有此状态，0表示未拥有此状态，那么总共能表示多少个状态取决于有多少个比特位，在go语言中，使用<code>uint64</code>类型可以最多可以表示64个状态。在这种情况下，其所存储状态的值就有一定的要求，其值必须是2的整数次方，比如2的2次方</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2的8次方</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>假设现在用一个无符号8位整数来存储这些状态，意味着可以有8个比特位可以使用，也就是<code>uint8(0)</code></p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将其与<code>0b10</code>进行或运算，或运算的符号是<code>|</code></p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或运算的规则是同为0取0，否则取1，进行或运算后，就可以将该状态的标志位记录到变量中。同理，也可以存储多个其它不同的状态，将上面计算的结果与<code>0b10000000</code>再次进行或运算后，此时状态变量的二进制位中，已经有两个比特位为1。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要一次性存储多个状态，可以先将几个状态进行或运算，再存储到状态变量中，比如一次性存储状态ABCD</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终<code>status</code>的值就是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>既然有存储状态，就肯定要读取状态，读取状态的原理同样十分简单。假如要确认状态<code>A</code>是否存在于<code>status</code>变量中，使用与运算<code>&amp;</code>即可，其规则为同为1取1，否则取0，由于这些状态值全都是2的正整数次方，二进制位中永远只有一个位为1，所以两者进行与运算时，只有相同的那一个比特位才能为1，其余全为0，如果计算结果为0，说明指定位不相同，则不包含此状态，计算过程如下。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同理，如果想判断多个状态是否存在于<code>status</code>中，将多个状态值进行或运算，然后将结果与<code>status</code>进行与运算即可，比如下面判断是否同时包含状态ABC。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后一个操作就是撤销状态，将指定状态从<code>status</code>中删除，经过上面两个操作的讲解后相信可以很容易就能想到删除的原理。实际上有两种方法可以操作，其结果都是一样的，第一种是将指定状态取反，然后将结果与<code>status</code>相与，就能得到删除指定状态后的<code>status</code>。假设删除状态<code>D</code>其过程如下，</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>取反会将自身的每一个比特位反转，反转后只有一个比特位为0，也就是要删除的比特位，这样一来将与<code>status</code>进行与运算，就能将指定比特位置0。另一个方法就是直接将两者进行异或运算，异或的规则是不相同取1，相同取0，计算过程如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看得出来异或就等于取反后相与，两者是完全等价的。如果要删除多个状态，跟之前同理，多个状态进行或运算后再进行异或，比如下面删除状态ABC</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 实现</h2>
<p>理论部分讲完过后，下面看看怎么用代码来进行实现，这种操作是不限语言的，这里使用go语言来进行实现。需要注意的是，go语言中取反运算符和异或运算符是同一个，都是<code>^</code>符号。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>首先可以声明一个<code>BitFlag</code>类型，其底层类型为<code>uint64</code>，最多可以同时存储64个状态，在实际代码中可以直接使用位运算来进行操作，这里选择稍微封装了一下。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到代码量非常少，实现起来也很简单，下面是一个简单的使用案例</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311291911647.png" type="image/png"/>
    </item>
    <item>
      <title>使用geo2ip将IP地址转换为地理信息</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/geo2ip.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/geo2ip.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">使用geo2ip将IP地址转换为地理信息</source>
      <description>使用geo2ip将IP地址转换为地理信息</description>
      <category>技术日志</category>
      <category>go</category>
      <pubDate>Thu, 14 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 使用geo2ip将IP地址转换为地理信息</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403141721383.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>之前推荐了一个ip地理信息库<code>ip2location</code>，其免费版只能查询国家代码，并且离线数据库不支持全量加载到内存中，由于这些缺点，我找了一个新的替代品<code>geoip2</code>，该离线数据库仍然是由一个商业公司在运营，但是相比前者要良心非常多，免费版支持定位到城市，且支持多语言，同时支持<code>csv</code>，<code>mmdb</code>两种格式。</p>
<h2> 下载</h2>
<p>首先需要在网站注册一个账号，然后才能下载免费版</p>
<p>官网：<a href="https://www.maxmind.com/en/home" target="_blank" rel="noopener noreferrer">Industry leading IP Geolocation and Online Fraud Prevention | MaxMind</a></p>
<p>下载地址：<a href="https://www.maxmind.com/en/accounts/986554/geoip/downloads" target="_blank" rel="noopener noreferrer">Download GeoIP Databases | MaxMind</a></p>
<p>然后安装他们提供的go SDK库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 使用</h2>
<p>使用起来有两种，一种是从文件读</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另一种是把数据库全量加载到内存中，总共也才30MB不到，这样做可以省去文件IO</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 案例</h2>
<p>通过IP地址查询地区信息</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过IP地址查询城市信息</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面的两个输出可以看到，它支持多种语言，时区等等信息，除此之外它还支持经纬度定位等其它功能，不过不是很准确。</p>
<h2> 性能</h2>
<p>写一个简单的基准测试</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>平均耗时在5微秒左右</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403141721383.png" type="image/png"/>
    </item>
    <item>
      <title>使用ip2location包转换IP地址</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/go_ip2loc.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/go_ip2loc.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">使用ip2location包转换IP地址</source>
      <description>使用ip2location包转换IP地址</description>
      <category>技术日志</category>
      <category>go</category>
      <pubDate>Mon, 11 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 使用ip2location包转换IP地址</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403111750936.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>ip2loction是一个组织，它们提供IP数据库，可以通过IP地址解析道各种各样的信息，比如地区代码，时区等等，网站：<a href="https://lite.ip2location.com/%E3%80%82" target="_blank" rel="noopener noreferrer">https://lite.ip2location.com/。</a></p>
<p>免费数据库只能查询国家代码，更多功能只有付费数据库可以使用，它们的数据库也就是一个单独的文件或者CSV文件。</p>
<h2> 下载</h2>
<p>下载地址：<a href="https://lite.ip2location.com/database-download" target="_blank" rel="noopener noreferrer">Database Download (ip2location.com)</a></p>
<p>文档地址：<a href="https://ip2location-go.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener noreferrer">IP2Location Go Package — IP2Location Go (ip2location-go.readthedocs.io)</a></p>
<h2> 使用</h2>
<p>它们提供了专门GO API来操作数据库，所以对于go而言可以直接导入它们编写好的库就可以直接使用。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后直接通过go代码打开文件数据库，lite版本的数据文件很小只有2MB左右，完全可以嵌入到程序中，下面是一个使用案例</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出可以看到，只能查询国家代码，如果想要时区之类的一些信息需要付费购买更高级的数据库，不过对大多数人而言国家代码已经够用了。</p>
<h2> 性能</h2>
<p>下面是一个基准测试，来测试lite版本的查询性能如何</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到的是单次查询性能在18微秒左右，还是比较可以的。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403111750936.png" type="image/png"/>
    </item>
    <item>
      <title>Go语言实现按照行数逆序读取文件 - 模拟tail命令</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/go_tail_read_file.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/go_tail_read_file.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Go语言实现按照行数逆序读取文件 - 模拟tail命令</source>
      <description>Go语言实现按照行数逆序读取文件 - 模拟tail命令</description>
      <category>技术日志</category>
      <category>go</category>
      <pubDate>Mon, 15 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Go语言实现按照行数逆序读取文件 - 模拟tail命令</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404152051856.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<h2> 编写</h2>
<p>Linux中的tail命令很多人应该都用过，我们经常用它来看日志</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果在用go语言实现这一个功能，也是非常的简单，要点就是利用<code>Seek</code>这一函数</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它的第一个参数是偏移量，第二个参数总共有三个值</p>
<ul>
<li><code>0</code>，相对于文件头</li>
<li><code>1</code>，相对于当前的偏移量</li>
<li><code>2</code>，相对于文件末尾</li>
</ul>
<p>一个需要注意的点就是换行符问题，在linux上换行符是CR<code>\n</code>，而在windows上则是CRLF<code>\r\n</code>，在计算偏移量的时候这个问题不能忽视掉，在逆序读取的时候就一个字节一个字节的读，当遇到<code>\n</code>时就停止，然后再根据不同系统来更新偏移量。最后还需要注意的是逆序读取的偏移量不能小于文件大小的负数，否则就越过文件的起始位置了，在思路明确了以后，编码就比较轻松了，代码整体如下所示。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 测试</h2>
<p>文件<code>test.txt</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简单的测试代码</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404152051856.png" type="image/png"/>
    </item>
    <item>
      <title>Go读取Linux命令行管道参数</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/pipeline.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/pipeline.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Go读取Linux命令行管道参数</source>
      <description>Go读取Linux命令行管道参数</description>
      <category>技术日志</category>
      <category>go</category>
      <pubDate>Sat, 23 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Go读取Linux命令行管道参数</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312231144152.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>在用go编写命令行程序的时候，参数有三个来源</p>
<ol>
<li>命令行参数</li>
<li>命令行标志</li>
<li>管道</li>
</ol>
<p>Linux管道是一个很常见的用法，用于将上一个命令的结果作为下一个命令的参数</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但并不是所有命令行程序都支持管道参数，比如<code>echo</code>就不支持，这种情况我们一般会用<code>xargs</code>来转化下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它会读取管道参数然后作为标准命令行参数传递给下一个命令，不过它有可能会破坏源文件的内容，所以我们还是自身支持管道更好一些。</p>
<p>在使用管道时，实际上是将结果写入了标准输入<code>stdin</code>中，对于我们而言，就只需要从标准输入中读取就行了。很容易就能想到该怎么写</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可如果只是直接从标准输入读取，如果在使用命令的时候没有使用管道，那么这行代码就会一直阻塞下去。所以我们得首先判断是否是管道模式，再去读取管道参数，所以应该这样写</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看使用情况</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不使用管道</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，就可以区分使用管道和不使用管道的情况了，在不使用管道的情况下就可以从标准命令行参数里面去读取。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312231144152.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Goland远程开发与远程调试</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/go/remotedev.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/go/remotedev.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Goland远程开发与远程调试</source>
      <description>Goland远程开发与远程调试 本文讲解了如何使用Goland的远程开发和远程调试功能</description>
      <category>技术日志</category>
      <category>go</category>
      <pubDate>Mon, 15 May 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Goland远程开发与远程调试</h1>
<figure><img src="https://w.wallhaven.cc/full/j3/wallhaven-j35ev5.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本文讲解了如何使用Goland的远程开发和远程调试功能</p>
<!-- more -->
<hr>
<p>最近的一个项目是要部署在Linux上运行，但我习惯了在Windows上进行开发，许多开发工具都是在Windows上，所以远程开发和远程调试非常有必要，代码依旧在本地写，只是编译和部署放在Linux上。先说一下我的环境：</p>
<p>本地环境：Windows10，go1.20.2 dlv1.20.2</p>
<p>远程环境：ubuntu20LTS（虚拟机），go1.20.4，dlv1.20.2</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>虽然本文Linux用的是虚拟机，但是放在云服务器上一样使用。</p>
</div>
<h2> Go Build 配置</h2>
<p>首先在Goland运行配置里新建一个Go Build配置，然后选择Run On SSH</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202305151710958.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>输入Host和要登录的用户名</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202305151711615.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>登录成功后Goland会尝试执行<code>which go</code>命令，也许会失败，不过这并不影响，后面自己指定就行。再然后才是远程开发的重要配置</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202305151714447.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li><code>Project path on target</code>：该目录是后续操作的项目根目录，后续Goland自动上传的文件都会位于该目录下</li>
<li><code>Go Executable</code>：go二进制文件，该二进制文件并不是自己项目的二进制文件，而是go源代码的二进制文件，通常位于<code>$GOROOT/bin/</code>目录下</li>
<li><code>GOPATH</code>：不需要多做解释</li>
<li><code>Project sources directory</code>：Goland在编译时会先将源码上传到远程服务器上，该目录就是源码的指定位置，如果不填的话就会在项目根目录下随机生成目录，看起来很烦。</li>
<li><code>Compiled exectuables directory</code>：编译完成后二进制文件存放的文件夹。</li>
</ul>
<p>完成后如下</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202305151720594.png" alt="image-20230515172036551" tabindex="0" loading="lazy"><figcaption>image-20230515172036551</figcaption></figure>
<p>然后再Go Build中记得勾选 <code>Build on remote target</code>，这样上面的配置才会生效</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202305151723033.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> Go Remote配置</h2>
<p>在运行配置中新建Go Remote</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202305151725871.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后填写你的调试服务器IP和端口</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202305151725949.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>调试服务器就是dlv，如果在远程服务器中已经安装好了go环境，直接执行以下命令即可安装dlv</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用dlv命令运行调试服务器</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>每一个参数是什么作用可以在github上了解，exec参数后跟二进制文件的路径</p>
<h2> 开发流程</h2>
<p>上述所有配置完毕后，开发流程就是：</p>
<ol>
<li>本地编写代码</li>
<li>Goland更新远程服务器的源代码并编译</li>
<li>运行dlv调试服务器</li>
<li>本地运行Go Remote进行调试</li>
</ol>
<p>这样一来远程开发和远程调试的问题就都解决了，非常nice，远程调试起来也跟本地调试几乎没什么区别。</p>
]]></content:encoded>
      <enclosure url="https://w.wallhaven.cc/full/j3/wallhaven-j35ev5.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>在Pypi上发布自己的项目</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/python/pypi_upload.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/python/pypi_upload.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">在Pypi上发布自己的项目</source>
      <description>在Pypi上发布自己的项目</description>
      <category>python</category>
      <pubDate>Mon, 10 Jun 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 在Pypi上发布自己的项目</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406101805061.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>最近在用到一个python库的时候，发现了一个bug，看了看原仓库上次更新都是2022年了，估计我提了PR也不会被合并，于是我打算自己修复发布成一个新的包，此前没有了解过这些方面的知识，于是顺便写了这篇文章做一个记录。</p>
<p>官方教程：<a href="https://packaging.python.org/en/latest/tutorials/packaging-projects/" target="_blank" rel="noopener noreferrer">Packaging Python Projects - Python Packaging User Guide</a></p>
<h2> PyPI</h2>
<p>官网：<a href="https://pypi.org/" target="_blank" rel="noopener noreferrer">PyPI · The Python Package Index</a></p>
<p>第一步是在PyPI上注册一个自己的账号，然后申请一个API Token，这个Token就是专门用来上传软件包的。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406101815258.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>你可以在<code>username/Account settings/API tokens</code>位置找到有关Token的内容，现在的话申请Token必须要2FA认证，可以用自己喜欢的2FA应用来完成认证，在成功创建后，Token只会显示一次，为了后续方便使用，建议将其保存到本地的文件中，保存位置为<code>user/.pypirc</code>文件中。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>后续在用到的时候就会自动读取，不需要手动认证。</p>
<h2> 规范</h2>
<p>对于一个规范的项目而言，应该有如下几样东西</p>
<ul>
<li>LICENSE，开源证书</li>
<li>README，基本的文档</li>
<li><code>setup.py</code>，打包用的清单文件</li>
</ul>
<p>其它都还好，主要来讲讲这个<code>setup.py</code>，由于它稍微有点复杂，可以通过<code>pyproject.toml</code>配置文件来替代，不过其灵活性不如前者，比如下面是一个TOML的例子</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过配置文件可以很直观的了解到这些信息，不过稍微旧一点的项目都是使用<code>setup.py</code>来管理的，下面看一个<code>setup.py</code>的例子，该例子由知名开源作者<code>kennethreitz</code>提供</p>
<div class="language-python line-numbers-mode" data-ext="py"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该文件中主要是通过<code>setup</code>函数来进行管理，除了这个函数之外其它都是锦上添花的东西，根据你的需求去填写关键字参数即可。</p>
<h2> 打包</h2>
<p>首先安装打包工具</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后在项目根目录下执行，会在dist目录下生成tar.gz压缩文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后安装上传工具<code>twine</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用时只需要指定目录和项目名即可</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于前面在<code>.pypirc</code>文件中配置了token，这里会自动读取，不需要输入。</p>
<h2> 测试</h2>
<p>如果要测试的话，最好不要使用pip镜像，因为它们同步不及时，建议指定<code>-i https://pypi.org/simple/</code>官方源。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406101805061.png" type="image/png"/>
    </item>
    <item>
      <title>生病了</title>
      <link>https://246859.github.io/my-blog-giscus/posts/life/2024_06_03.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/life/2024_06_03.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">生病了</source>
      <description>生病了</description>
      <category>生活随笔</category>
      <pubDate>Thu, 06 Jun 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 生病了</h1>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202406061431627.jpg" style="zoom: 80%;">
<!-- more -->
<hr>
<p>在5月末的时候，背部的左下方靠腰的地方长了几个红色的小痘痘，刚开始没怎么在意，只是觉得有点痒，直到6月2号骑完车回来洗澡的时候仔细看了下，发现背后已经长了一大片红斑，大概有成年人一个手掌那么大，而且还在往腰部的方向逐渐蔓延，摸起来有颗粒感，晚上睡觉的时候又痒又痛，这种痛感是那种刺骨的感觉，整的我难以入睡，当晚就觉得不对劲，第二天起来一早就直接去学校最近的一个诊所查看情况。</p>
<p>给我看病的是一个头发半白的老头，他只是看了我后背一眼就得出了结论：<strong>带状疱疹</strong>。这玩意跟水痘差不多，都是由水痘病毒引起的，只是传染性没那么强，在宿主免疫力下降的时候会发病，越早治疗越容易痊愈，网上有很多类似的图片，很容易引起生理不适。</p>
<p>不到几分钟，老医生很快就给出了治疗方法</p>
<ol>
<li>扎火针放血，扎破痘泡使其快速结疤</li>
<li>在患病部位涂抹阿韦昔洛凝胶，防止其继续蔓延</li>
<li>输液打点滴，补充各种维生素营养液，提升免疫力</li>
<li>吃一些缓解神经痛的药</li>
</ol>
<p>其中的扎火针疗法不是必须的，但是很有效，同时也非常的折磨人，本来就挺疼的，还要用针扎，前后总共扎了两次，扎完过后涂抹药膏用射线灯照射将其烤干，相当折磨人，护士小姐姐给我扎针时还问我难道不觉得疼吗，疼当然是疼，只是早已麻木了。折磨半天后开始输液了，才终于可以静下来，然后我开始反思最近生活作息确实有点反人类了，经常熬夜，总是吃油腻外卖，运动量过低，个人卫生问题，这些可能都是导致免疫力下降的因素，这次生病也算是身体给我发出的一个警告。</p>
<p>老医生跟我说这病没有一个月好不了，相当顽固，必须根除，否则很容易再重新长出来，后遗症也很折磨人，好消息是治好后基本上很难复发。</p>
<p><strong>最难受的事情就是实习大概率黄了</strong>，先安心治病吧，顺便也调整下生活作息，这篇文章就简单记录下我得病的过程，希望以后不要再犯了，能有一个健康的身体比什么都重要。</p>
]]></content:encoded>
    </item>
    <item>
      <title>记一次因日志而引发的OOM问题</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/oom_pprof.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/oom_pprof.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">记一次因日志而引发的OOM问题</source>
      <description>记一次因日志而引发的OOM问题</description>
      <category>问题记录</category>
      <pubDate>Sun, 14 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 记一次因日志而引发的OOM问题</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404141415851.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<h2> 问题</h2>
<p>在最近的项目中，后端隔三岔五就会因为内存爆满而崩溃，这种情况差不多两三天就会发生一次。由于在项目中在向Steam请求模组信息时会开启多个协程并发请求，因此猜测可能是因为协程未能正常退出而导致的内存泄露问题，于是便通过pprof来对应用进行性能分析。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过对pprof的可视化分析，发现与猜测的结果并不一致，在分析的过程中，发现获取服务端状态的这个接口在调用时内存占用会猛增，该接口主要用于判断游戏服务端是否启动，判断的逻辑就是去读取游戏服务端的日志文件，而有些用户的游戏服务端会一直开着，导致其文件大小可能会非常大，目前最大的发现有800MB，由于在读日志的时候是将其全量加载到内存中，那么这样一来就会导致内存占用升高。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404141710273.png" alt="图片已脱敏" tabindex="0" loading="lazy"><figcaption>图片已脱敏</figcaption></figure>
<p>并且在日志读取完后还要对其进行处理，由于go语言的字符串写时复制特性限制，在处理日志的时候还会拷贝一份副本，分配的内存就会更大。由于很多的功能都依赖于游戏日志，比如获取与服务端交互的命令结果，判断服务端的启动状态等等，它们在不断频繁地将日志全量加载到内存中后，必然会导致内存不足而OOM。</p>
<p>所以问题的根本原因就在于，游戏日志的读取加载的方法不正确。</p>
<h2> 解决</h2>
<p>由于日志文件过大，所以不应该将其全量加载到内存中，在进行逐个分块读取过后，内存占用了有了较为明显的下降。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404141415851.png" type="image/png"/>
    </item>
    <item>
      <title>免费SSL证书申请</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/ssl_cert_collect.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/ssl_cert_collect.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">免费SSL证书申请</source>
      <description>免费SSL证书申请</description>
      <category>技术日志</category>
      <pubDate>Fri, 12 Apr 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 免费SSL证书申请</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404121531323.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>如果想要让你的网站在公网中正常访问，SSL绝对是不可或缺的部分，没有SSL的话浏览器甚至会直接警告不要访问，搜索引擎的权重也会降低。对于个人开发者而言，如果只是部署一些文档或测试网站，购买昂贵的SSL证书并不是一个好的选择，所以这里收集了一系列SSL证书免费申请的网站，以供白嫖参考，下面是内容都是从免费证书的角度出发的，不具备商业参考性。</p>
<h2> 1.Let's Encrypt</h2>
<p>这是一家很老牌的免费SSL证书颁发机构，他们的宗旨就是促进互联网向HTTPS发展。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404121558230.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>官网：<a href="https://letsencrypt.org/zh-cn/" target="_blank" rel="noopener noreferrer">Let's Encrypt - 免费的SSL/TLS证书 (letsencrypt.org)</a></p>
<p>优点：完全免费，公益的组织，申请数量没有限制</p>
<p>缺点：证书只有3个月有效期（可通过脚本自动化续签），使用门槛较高，教程中英混杂，不适合普通小白用户。</p>
<p>适用人群：对于开源组织，个人开发者有一定技术力的人群来说来说，Let's Encrypt绝对是首选。</p>
<h2> 2.腾讯云</h2>
<p>腾讯云是国内的一家云服务大厂，提供很多各种各样的云服务，其中包括SSL证书。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404121559166.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>官网：<a href="https://console.cloud.tencent.com/certoverview" target="_blank" rel="noopener noreferrer">概览 - SSL 证书 - 腾讯云 (tencent.com)</a></p>
<p>优点：免费证书有效期12个月（24年4月25日后降至3个月），文档丰富，可视化界面管理，无域名额度限制，可绑定任意域名，集成站内应用比较方便。</p>
<p>缺点：对于免费证书而言，个人用户限制50个（企业用户10个），且不支持自动续签</p>
<p>适用人群：国内用户，小白</p>
<h2> 3.阿里云</h2>
<p>阿里云同样提供免费的SSL证书，相比腾讯云就一般般了</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404121616141.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>缺点：个人用户免费证书只有20个，不支持根证书下载，证书有效期3个月，国内其它的云厂商大都类似</p>
<h2> 4.OHTTPS</h2>
<p>OHTTPS 致力于为用户提供 零门槛、简单、高效 的HTTPS证书服务，它基于Let‘s Eencrypt，我的评价是神中神。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404121635289.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>优点：可视化界面，自动化管理，并且是完全支持免费证书（单域名，多域名，泛域名），对于个人开发者来说算没有缺点了，唯一能算的就是证书有效期只有3个月，但是它支持自动更新，所以也就不是问题，并且还支持对接国内的云服务商。</p>
<p>缺点：唯一的缺点就是需要付费，不过新用户自动赠送的余额可以用好几年了</p>
<p>适用人群：所有人，只要想使用免费证书，OHTTPS就完全适合你。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404121531323.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>记录Hertz框架limiter的一个问题</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/go_bug_of_hertz_limiter.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/go_bug_of_hertz_limiter.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">记录Hertz框架limiter的一个问题</source>
      <description>记录Hertz框架limiter的一个问题</description>
      <category>问题记录</category>
      <pubDate>Wed, 13 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 记录Hertz框架limiter的一个问题</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403131932279.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>最近在尝试一个新的Web框架<code>Hertz</code>，使用起来跟gin没什么太大的区别，它的周边生态也有一些开源的中间件，在使用其中的limiter时遇到了问题，便记录了下来。</p>
<h2> 发现</h2>
<p>首先limiter的算法实现是BBR自适应限流算法，用起来没有问题，用法如下。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在编译之前进行语法检查，会得到如下报错，提示未定义的类型</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>首先会好奇这么个玩意是哪里来的，我好像也没用到过，先通过<code>go mod</code>命令看看是谁依赖了它</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原来就是这个limiter导入了它，因为bbr算法的需要获取主机的一些负载信息所以导入了这个库。<code>syscall</code>是标准库中的系统调用库，它不太可能会出问题，那就是用它的库有问题，接下来去这个<code>goprocinfo</code>库里面看看怎么回事，找到的目标代码如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码的逻辑很简单，就是通过系统调用来获取某一个路径下文件夹使用额度，但是遗憾的是Windows系统并不支持<code>Statfs</code>这个系统调用，所以对于win系统而言，编译后并不会存在<code>Statfs_t</code>类型和<code>Statfs</code>函数，所以整个问题的原因就是<code>goprocinfo</code>这个库没有根据不同的系统做兼容而导致的。</p>
<h2> 解决</h2>
<p>由于我的开发工作是在windows上进行的，不可能去迁移到linux上，所以只能更换一个新的限流库，这里找到了<code>go-kratos</code>开源的一个bbr限流库。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在更换过后，代码变化也不多</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>go-kratos</code>所使用的系统信息库是<code>gopsutil</code>，后者是一个专门兼容各个操作系统的系统信息库，对外屏蔽了复杂的系统调用，兼容性要更高。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403131932279.png" type="image/png"/>
    </item>
    <item>
      <title>大理旅行</title>
      <link>https://246859.github.io/my-blog-giscus/posts/life/2024_02_27.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/life/2024_02_27.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">大理旅行</source>
      <description>大理旅行 在大理旅行了三天</description>
      <category>生活随笔</category>
      <pubDate>Fri, 01 Mar 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 大理旅行</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403011824615.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在大理旅行了三天</p>
<!-- more -->
<hr>
<p>初次到大理的时候机场真的很小，下关风非常大，人都有点站不稳。住的地方是大理古城旁边的一家民宿，离洱海两三公里，骑着小电驴就可以到处逛，不得不吐槽下全国的古城都是只有小吃街，好在洱海的风景非常好看。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403011817994.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403011817964.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403011817104.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403011819606.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202403011824615.jpeg" type="image/jpeg"/>
    </item>
    <item>
      <title>二叉树的遍历</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/alg/binary_tree.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/alg/binary_tree.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">二叉树的遍历</source>
      <description>二叉树的遍历</description>
      <category>二叉树</category>
      <pubDate>Thu, 01 Feb 2024 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 二叉树的遍历</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202402011303985.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>二叉树的遍历分三种</p>
<ul>
<li>前序遍历，中-左-右</li>
<li>中序遍历，左-中-右</li>
<li>后序遍历，左-右-中</li>
</ul>
<p>遍历又分递归和迭代版，对于迭代而言就是手动创建栈来模拟递归的调用栈，整体来说都比较简单，只有迭代版的后序遍历需要稍微注意下。</p>
<h2> 前序遍历</h2>
<p>递归版本</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>迭代版本</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 中序遍历</h2>
<p>递归版本</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>迭代版本</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 后序遍历</h2>
<p>递归版本</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>迭代版本</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202402011303985.png" type="image/png"/>
    </item>
    <item>
      <title>Vmware虚拟机Nat模式网络不通</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/linux/nat_loss.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/linux/nat_loss.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Vmware虚拟机Nat模式网络不通</source>
      <description>Vmware虚拟机Nat模式网络不通</description>
      <category>linux</category>
      <pubDate>Mon, 21 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Vmware虚拟机Nat模式网络不通</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401211617744.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>我的主机是win10，主要拿来写代码，一些服务比如数据库什么的都是搭建在虚拟机里面，有一天打开的虚拟机的时候发现没法访问数据库了，尝试Ping了一下也不成功。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401211620640.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>虚拟机用的是Ubuntu22.04版本，Nat模式出现这种情况可能就是网段不一致，在<code>cmd</code>上执行<code>ipconfig</code>命令看了看发现果然是这样</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401211622174.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到Vm8网卡的自动配置的IPV4地址网段与虚拟机并不一致，由于设置了自动配置，不知道什么时候改的，这里需要手动的设置一下。在win10界面打开控制面板查看网卡设置，选择Vm8虚拟网卡，接下来需要手动的配置IP地址。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401211624664.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>将IP地址设置成与虚拟机同一个网段即可，DNS服务器选择国内通用的<code>114.114.114.114</code>，备用的DNS服务器是谷歌的<code>8.8.8.8</code>，完成后再来试一试。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401211626687.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>并且虚拟机也可以ping通主机</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401211629470.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>于是问题就解决了。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401211617744.png" type="image/png"/>
    </item>
    <item>
      <title>在Linux上使用clash</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/linux/clash_on_linux.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/linux/clash_on_linux.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">在Linux上使用clash</source>
      <description>在Linux上使用clash</description>
      <category>linux</category>
      <pubDate>Thu, 14 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 在Linux上使用clash</h1>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312021437923.png">
<!-- more -->
<hr>
<p>最近在测试SteamAPI Client，不得不吐槽一下steam提供的web接口返回的响应结构真是<strong>多种多样</strong>，可以看的出来都是陈年老项目了。不过重点不是这个，虽然Steam的游戏服务在国内不需要梯子也可以访问，但是他们提供的接口如果不走代理的话，那基本上请求十次八次超时，为了解决这个问题只好在测试机上弄clash。</p>
<p>clash是用go编写的，一大好处就是安装非常方便，因为除了一个二进制文件其它什么都不需要，并且还是开源跨平台的。</p>
<h2> 安装</h2>
<p>开源地址：<a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener noreferrer">Dreamacro/clash: A rule-based tunnel in Go. (github.com)</a></p>
<p>从release中找到最新版，然后找到对应的版本。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309141836378.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>wget下载到本地</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>gzip解压</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为了方便使用将其链接到bin目录下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>完事后查看版本，输出没问题就是安装成功了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 代理</h2>
<p>导入配置文件，clash的配置文件相当复杂，一般你的代理服务商都会提供现有的配置以供导入，比如我使用的glados</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后启动clash，指定配置文件和路径，<code>-d</code>指的是配置目录，clash在刚开始时会尝试下载country.db如果不存在的话。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>有如下输出即可</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到http代理端口<code>7890</code>，由于socks不需要就不配置。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在配置生效前来看看请求steamapi是什么效果，可以看到失败了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在开启clash后</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>clash日志这里也有输出，是走了代理的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果有需求的话，可以做成系统服务，进行更加方便的管理。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309141836378.png" type="image/png"/>
    </item>
    <item>
      <title>队列-双端队列</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/alg/dequeue.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/alg/dequeue.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">队列-双端队列</source>
      <description>队列-双端队列</description>
      <category>算法</category>
      <pubDate>Wed, 20 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 队列-双端队列</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201504787.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>众所周知，队列是一种先进先出（FIFIO）的数据结构，不过它只能一端进，在另一端出，而双端队列对前者进行了拓展，它的两端都能进出。假如，只在一端进，并且只在这一端出，那么这样就变成了后进先出，也就成了栈，因此双端队列其实同时具有队列和栈的性质。</p>
<p>双端队列可以采用链表或数组来实现，本文使用数组的方式来进行讲解。对于双端队列而言，会有两个指针<code>front</code>，<code>tail</code>分别代表的队列的两端。如下图</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201504350.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>front</code>指针指向队列的头部元素，而<code>tail</code>则指向队列的尾部，<strong>左右端指的是队列的左右端，并非图中数组的左右两端</strong>，两者是有很大区别的。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201520879.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>上图中队列内的元素实际为<code>[2, 1]</code>，是左端插入了一个2，右端插入了一个1而产生的结果。通常来说，一个双端队列支持以下操作，如下图</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201510214.png" alt="摘自wiki" tabindex="0" loading="lazy"><figcaption>摘自wiki</figcaption></figure>
<p>不同语言对这些操作可能会有不同的称呼，但它们的作用都差不多，下面来讲解下双端队列的具体思路。</p>
<h2> 入队</h2>
<p>先来讲讲左边入队，也就是从队列头部添加元素，给定一个如下图所示的空队列，此时<code>front</code>与<code>tail</code>指针重叠，元素数量为0。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201524254.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从队列左边入队一个元素<code>3</code>，<code>front</code>指针左移，但其本身位于下标0，所以就顺势环形移动到数组末尾，也就是下标<code>5</code>，然后对<code>front</code>所指向的元素赋值<code>3</code>。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201530656.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此时队列内元素为<code>[3]</code>，假设再从右边入队元素<code>10</code>，从队列右边入队时，先将<code>tail</code>所指向的元素赋值，然后再右移指针<code>tail</code>。所以在入队时，这两个指针其实就是在数组上面环形移动，从数组的一边走到头了，就从另一头继续走，就跟环形链表一样。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201542998.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此时队列内的元素为<code>[3, 10]</code>，接下来如果不停在左右端入队元素，那么两个指针此时最终就会相遇，操作如下</p>
<ol>
<li>左端入队1</li>
<li>右端入队9</li>
<li>左端入队6</li>
<li>右端入队-1</li>
</ol>
<p>最终结果如图所示，此时队列的元素为<code>[6, 1, 3, 10, 9, -1]</code>，数量为6，队列已经满了，无法再容纳新的元素。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201546059.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 扩容</h3>
<p>当双端队列满了以后，如果要继续添加新元素，就需要对其数组进行扩容（有些地方的实现可能不支持扩容），然后让元素重新按照相对位置分布在新的数组上。首先申请一个两倍于当前数组长度的新数组，然后按照原数组中元素的相对位置让它们重新分布在新数组上，对于上图中而言，就是让<code>front</code>指针指向元素（包括自身）的重新右边分布在新数组的右边，然后让左边的元素重新分布在新数组的左边，扩容后的队列数据分布如下图所示，队列左端的元素分布到了数组的右端，队列右端的元素分布在了数组的左端。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201556098.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在往后的入队操作中，两个指针又会不断靠拢，然后再次扩容，接着又重新分布到新数组的左右两端。</p>
<h2> 出队</h2>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201605159.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>拿上面这一个例子讲解出队，出队其实就是上面的入队的过程反着来。从队列右边出队，只需要将指针<code>tail</code>左移即可，如果有必要也可以将它所指向的元素置0，一般来说不需要。如下图所示，从右边出队元素-1，此时队列内元素为<code>[6, 1, 3, 10, 9]</code>。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201611560.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>而从左边出队也是一样，只需要将<code>front</code>指针右移。如下图所示，从右边出队元素6，此时队列内元素为<code>[1, 3, 10, 9]</code>。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201613044.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如此往复，两个指针会分别往数组左右两端移动，直到再次相遇，数组为空。</p>
<h3> 缩容</h3>
<p>当队内元素数量小于数组长度的一半时，可以考虑缩容，这个是可选项，并非所有双端队列都要实现缩容。此时元素都分布在数组的左右两侧，而数组中间有一大堆无用的空间，可以申请一个新的数组，其长度为原来的<code>3/4</code>，也就是原数组缩小了<code>1/4</code>的长度，之所以不直接缩小一半是为了避免往后入队时会频繁的触发扩容操作。沿用之前的例子，假设在缩容前队列如下图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201626231.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>原数组长度为6，缩小<code>1/4</code>就是长度5，然后重新分布元素后，如下图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201629865.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 总结</h2>
<p>下面是两种不同实现的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>动态数组</th>
<th>双向链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>入队</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>出队</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>随机访问</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>对于动态数组实现，它的均摊时间复杂度可以达到O(1)，适合读多写少的场景，而对于双向链表来说，比较时候读少写多的场景。</p>
<p>双端队列的实现代码位于<a href="https://github.com/246859/containers/blob/main/queues/dequeue.go" target="_blank" rel="noopener noreferrer">github.com/246859/containers/queues/dequeue.go</a>。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312201504787.png" type="image/png"/>
    </item>
    <item>
      <title>堆-二项堆</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/alg/binary_heap.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/alg/binary_heap.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">堆-二项堆</source>
      <description>堆-二项堆</description>
      <category>算法</category>
      <pubDate>Sat, 16 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 堆-二项堆</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161653801.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>堆是一种特殊的数据结构，它的特点在于可以在O(1)的时间内找到堆内的最大值或最小值。它一般有两种类型，大顶堆或小顶堆。大顶堆是最大值在堆顶，子节点均小于根节点；小顶堆是最小值在堆顶，子节点均大于根节，同时堆也是优先队列比较常见的实现种类。堆只是这类数据结构的统称，并非特指某种具体实现，一般来说它支持以下几种操作，</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这些操作在其它文章可能叫法不一样，但大致的作用都是类似的，也可能有更多的拓展。</p>
<p>今天要讲的就是堆里面最简单的实现，二项堆，或者叫二叉堆，其英文名为BinaryHeap，下面统称为二项堆。二叉堆在表现上通常是一个近似完全二叉树的树，如下图</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161717587.png" style="zoom:50%;">
<p>对于二项堆而言，它的关键操作在于元素的上浮和下沉，这个过程会频繁的遍历整个树，所以一般二项堆不会采用树节点的方式实现，而是使用数组的形式。将上图的二叉树转换成数组后就如下图所示：</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161723238.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>对于堆每一个节点，其在数组中的下标映射为：</p>
<ul>
<li>父节点：<code>(i-1)/2</code></li>
<li>左子节点：<code>i*2+1</code></li>
<li>右子节点：<code>i*2+2</code></li>
</ul>
<p>这种规则很好理解，下面演示上浮和下沉操作，默认为小顶堆。</p>
<h2> 上浮</h2>
<p>在前面的基础之上，向堆中添加了一个新元素，我们将其添加到数组的末尾，如下图</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161742023.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后让其不断的与它的父节点进行比较，如果小于父节点，就进行交换，否则就停止交换。对于2而言，它的父节点位于下标<code>(7-1)/2=3</code>处，也就是元素8，显然它是小于8的，于是它两交换位置。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161747062.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再与其父节点5进行比较，小于5，则交换位置，然后再与父节点3进行比较，小于3，于是再次交换，最终整个堆就如下图所示：</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161750694.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此时2就是堆顶元素，它也的确是最小的那一个元素，于是堆调整完毕，这个过程也就称之为上浮。整个过程只是在不断的与它的父节点进行比较，总比较次数为3，同时这也是树的高度，对于一个含有n个数量的堆来说，添加一个新元素的时间复杂度为O(logn)。代码实现如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 下沉</h2>
<p>对于堆顶元素而言，如果要将其从堆中删除，首先将其与最后一个元素交换位置，然后再移除尾部元素。如下图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161804777.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后此时堆顶元素不断与其子节点进行比较，如果比子字节大就交换位置，每一次交换时，优先交换两个子节点中更小的那一个。比如8的子节点是4，和5，那么将8与4进行交换。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161806563.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再继续与子节点进行比较然后交换，最终如下图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161808745.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此时堆再次调整完毕，堆顶元素仍然是最小值。整个过程只是在不断的与子节点进行比较交换，下沉操作的时间复杂度也为O(logn)。代码实现如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 构建</h2>
<p>对于构建二项堆而言，一个简单的做法是将其视为一个空的堆，然后不断的对每一个末尾的元素执行上浮操作，那么它的时间复杂度就是O(nlogn)。</p>
<p>有一种办法可以做到O(n)的时间复杂度，它的思路是：首先将给定的输入序列按照二叉树的规则在分布在数组当中，自底向上从最后一个父节点开始，每一个父节点就代表着一个子树，对这个子树的根节点执行下沉操作，这样一直操作到整个二项堆的根节点，由于所有局部的子树都已经完成堆化了，对于这个整体根节点的下沉操作也最多只需要比较O(h)次，h是整个树的高度，可以证明这个过程的时间复杂度为O(n)，详细的证明过程在<a href="https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap" target="_blank" rel="noopener noreferrer">wiki</a>中可以查阅，而二项堆的合并过程也与构建的过程大同小异。代码实现如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>构建</td>
<td>O(n)</td>
</tr>
<tr>
<td>查看最小值</td>
<td>O(1)</td>
</tr>
<tr>
<td>插入</td>
<td>O(log n)</td>
</tr>
<tr>
<td>删除</td>
<td>O(log n)</td>
</tr>
<tr>
<td>合并</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>二项堆是所有实现中最简单的一个，总体来说难度不大，性能尚可，足够满足基本使用。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>有关二项堆的具体实现，可以前往<a href="https://github.com/246859/containers/blob/main/heaps/binary_heap.go" target="_blank" rel="noopener noreferrer">containers/heaps/binary_heap.go</a>进行了解，这是我自己写的常用数据结构的库，支持泛型。</p>
</div>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161653801.png" type="image/png"/>
    </item>
    <item>
      <title>经典排序算法</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/alg/sort.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/alg/sort.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">经典排序算法</source>
      <description>经典排序算法</description>
      <category>算法</category>
      <pubDate>Sun, 23 Oct 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 经典排序算法</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312081421944.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<h2> 冒泡排序</h2>
<p>冒泡排序是最简单的一种排序，也是最暴力的排序方法，对于大多数初学者而言，它是很多人接触的第一个排序方法。大致实现思路如下：从下标0开始，不断将两个数字相比较，如果前一个数大于后一个数字，那么就交换位置，直至末尾。外层循环每一轮结束后，就能确定一个值是第<code>i+1</code>大的元素，于是后续的元素就不再去交换，所以内层循环的终止条件是<code>len(slice)-(i+1)</code>。</p>
<p>下面是一个冒泡排序的泛型实现。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度：O(n^2）</strong></p>
<p>不管情况好坏，它需要交换总共 (n-1)+(n-2)+(n-3)+...+1 次 ，对其进行数列求和为 (n^2-n)/2 ，忽略低阶项则为O(n^2)，即便整个切片已经是完全有序的。</p>
<p><strong>空间复杂度：O(1）</strong></p>
<p>算法进行过程中没用到任何的额外空间，所以为O(1)</p>
<p><strong>稳定性：是</strong></p>
<p>两个元素相等时不会进行交换，就不会发生相对位置的改变。看一个例子</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一轮冒泡，移动第二个3</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二轮冒泡，移动第一个3</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到相对位置没有发生变化。</p>
<p><strong>性能测试</strong></p>
<p>对其进行基准测试，分别使用100，1000，1w，10w个随机整数进行排序，测试数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>随着数据量的增多，冒泡排序所耗费的时间差不多是在以平方的级别在增长，到了10w级别的时候，要花费整整18秒才能完成排序，值得注意的是整个过程中没有发生任何的内存分配。百万数据量耗时太久了，就懒得测了。</p>
<p><strong>优化</strong></p>
<p>第一个优化点是原版冒泡即便在数据完全有序的情况下依然会去进行比较，所以当一趟循环完后如果发现数据是有序的应该可以直接退出，这是减少外层循环的次数。由于冒泡排序每轮会冒泡一个有序的数据到右边去，所以每轮循环后都会缩小冒泡的范围，假设数据右边已经是有序的了，那么这种操作就可以提前，而不需要等到指定循环次数之后才缩小范围，比如下面这种数据</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个范围的边界实际上就是上一轮循环最后一次发生交换的下标，这是减少了内循环次数。这里提一嘴使用位运算也可以实现数字交换，算是第三个优化点，但仅限于整数类型。优化后的代码如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优化只能提高冒泡的平均时间效率，在最差情况下，也就是数据完全逆序/升序的时候，对其进行升序/逆序排序，渐进时间复杂度依旧是O(n^2)。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提升并不是特别明显，因为数据是完全随机的，可能很多生成的数据并没有走到优化点上，这也变相证明了冒泡排序不太适合实际使用。</p>
<h2> 选择排序</h2>
<p>选择排序的思路非常的清晰和容易实现，将数组分为两部分，一部分有序，一部分无序，首先在数组的未排序部分找出其中的最大或最小值，也就是然后将最大值或最小值其与数组的中的第i个元素交换位置。第一个交换的一定是第一大或第一小的元素，第二个就是第二大或第二小的元素，这样一来就确认了有序的部分，如此在未排序的部分循环往复，直到整个数组有序。比如</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时整个数组都是无序的，找出其最小值-1，与第一个元素交换位置</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时只剩[1,4,2]是未排序部分，继续找最小值，得到1，那么它就是第二小的元素，就将其与第二个元素交换位置，由于它本身就在第二个位置上所以没变化。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>继续按照这个流程，就能将数据最终变得有序。具体代码实现如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度：O(n^2)</strong></p>
<p>不管在什么情况，在选择排序的过程中，它都会在每轮循环后的未排序部分去比较寻找最大值，所以比较次数为(n-1)+(n-2)+(n-3)....+1差不多就是(n<sup>2+n)/2，所以其时间复杂度为O(n</sup>2)。</p>
<p><strong>空间复杂度：O(1)</strong></p>
<p>排序过程中没有用到任何的额外空间来辅助，所以时间复杂度为O(1)。</p>
<p><strong>稳定性：否</strong></p>
<p>在交换的过程中它们的位置会发生改变，但也不会被调整回来，所以是不稳定的。看一个例子</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一轮交换第一个6会和0交换位置，就变成了</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>本来是在第二个6前面的现在到后面来了，相对位置发生改变了，即便整个数组完成排序后也不会再被调整。</p>
<p><strong>性能测试</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到的是选择排序在10w数据量时选择排序花费的时间是冒泡的一半左右，这是因为冒泡每轮循环交换的次数比较多，而选择排序每轮循环只交换一次，总体上从时间来说是优于冒泡排序的。</p>
<p><strong>优化</strong></p>
<p>原版选择排序只会在切片的左边构建有序部分，在右边无序的部分去寻找最大或最小值，既然反正都是在无序部分寻找最大/最小值，那就可以在切片左右两边都构建有序区，假设是升序排序，左边是最小，右边是最大，中间就是无序区，这样一来就可以减少差不多一半的比较次数。优化后的代码如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，这样一来只需要看一边的比较次数就够了，不严谨的来说就是(n/2-1)+(n/2-2)+(n/2-3)...，最后时间复杂度依旧是O(n^2)，不过优化的时间效率上会有所提升。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过数据对比可以看到，在时间效率上大概提升了接近10-20%左右。</p>
<h2> 插入排序</h2>
<p>插入排序也是一种比较简单的排序方法，其基本思路为：假设0 ...i的元素已经有序，使用<code>s[i+1]</code>逆向与前i+1个元素进行逐个比较，如果在比较过程中第j个元素比第i+1个元素小/大，那么将其后移，如此循环往复，直到找到第一个大于/小于<code>s[i+1]</code>下标元素的元素时或者下标为0时，考虑到比<code>s[i]</code>小/大的元素都已经后移了，所以直接<code>s[i]</code>的值覆盖到<code>s[j+1]</code>上。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度：O(n^2)</strong></p>
<p>如果是要升序排列，在最好情况下，要排序的切片已经是完全升序的了，那么只需要进行n-1次比较操作。最坏情况就是完全降序，那么就需要n+(n-1)+(n-2)+......+1次比较，总共就是(n^2+n)/2次。</p>
<p><strong>空间复杂度：O(1)</strong></p>
<p>整个过程中未用到额外的辅助空间</p>
<p><strong>稳定性：是</strong></p>
<p>遇到相等元素时便插入到该元素后面，不会出现跑到它前面的情况。</p>
<p><strong>性能测试</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优化</strong></p>
<p>插入排序的优化方案很容易想到，假设是升序排列，在确保前n个元素已经是有序的情况下，我们需要去一个个遍历找到第一个小于<code>s[n+1]</code>的元素，既然它是有序的，那就可以使用二分查找来进行操作，然后再移动元素。移动次数没有减少，但比较次数减少了相当的多。优化后的代码如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看优化后的性能</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到使用了二分的插入排序性能整整比原版提升了足足有70-80%左右，这已经是非常巨大的提升了。在最好的情况下，如果切片本身就是全部有序的话，就不需要移动元素，那么就只有查找会消耗时间，这样一来它的时间复杂度可以接近O(nlogn)。在最差的情况，每次都需要移动i-1个元素，那么就是(log(n-1)+n-1)+(log(n-2)+n-2)+(log(n-3)+n-3)....，当n足够大时，logn产生的影响已经微不足道了，虽然没有经过严格的计算，但简单估算下它的时间复杂度依旧不会小于O(n^2)。</p>
<p>不过值得高兴的是，到目前为止总算有一个方法能够有突破O(n^2)的可能性。</p>
<h2> 希尔排序</h2>
<p>希尔排序是插入排序的一个更加高效的优化版本，也称<strong>递减增量排序</strong>。原版插入排序在数据本身是有序的情况下效率会非常高可以达到O(n)，希尔排序的改进思路也是基于此，它在移动和比较时，不再是一个一个移动，而是有了间隔称之为<strong>步长</strong>。比如下面这个序列</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>假设初始步长为3，那么就将数据划分为了三份</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分别对每一份进行插入排序后得到下面的序列，将其拼接再一起，然后再以步长为2进行划分</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时再拼接回来</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以发现整体已经接近基本有序的状态了，在这种情况下，步长再减为1就是原版插入排序了，在数据大多数有序的情况下，插入排序的时间复杂度可以接近O(n)。希尔排序的关键就在于，如何选择这个步长序列，步长序列的不同会导致希尔排序的时间复杂度也不同，在某些情况下它可能根本不会起作用。比如下面这个数据，步长的选择是每次折半，会根本发现不会起到任何优化的作用，反而还不如直接进行插入排序，因为无意义的步长划分导致它甚至比原始的插入排序还增加了额外的耗时，要更加的低效率。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最简单的步长序列就是每次对半分，这也是希尔本人提出的，这种也最容易实现，当然也最容易出现上面那个问题。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当最坏情况下，也是上面那个例子的情况下，划分步长没有任何的意义，这就退化成了原始的插入排序，其最差时间复杂度依旧是O(n^2)。为了避免这种情况，就需要仔细斟酌步长序列的选择，最基本的原则就是序列之间的元素得互为质数，如果可以互为因子的话就可能会出现对已经排过序的集合再一次排序这种情况，导致无意义的消耗。</p>
<p>希尔排序首次提出是在上世纪六十年代，现如今已经有了非常多的序列可选，下面介绍比较常见的两个：</p>
<ul>
<li>Hibbard序列，最差时间复杂度O(n(3/2))</li>
<li>Sedgewick序列，最差时间复杂度O(n(4/3))，目前最优序列？</li>
</ul>
<p>还有其它非常多的序列，前往：<a href="https://en.wikipedia.org/wiki/Shellsort#Gap_sequences" target="_blank" rel="noopener noreferrer">Shellsort - Wikipedia</a>了解更多（注意必须是英文维基，中文根本没有这么详细的介绍）。Hibbard实现代码如下，步长序列采用打表的方式记录，不需要每次都来计算步长序列。步长序列本身计算非常简单，难的是求证过程，笔者受限于数学水平，无法在此做出解答。由于序列的增长本身就是次方级别，当增长到数值溢出时的上一个步长就是最大步长了，这样就可以得到一个对于任意长度的切片都适用的步长序列。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312091801009.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于Sedgewick序列，则有如下两个公式</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312091728295.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>第二个公式要分奇偶情况，这里选择第一个公式，依旧选择打表实现。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>性能测试</strong></p>
<p>下面是一个简单的性能测试对比</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到的是Sedgewick步长序列在时间效率上有着较为明显的提升，Hibbard则不太明显。</p>
<h2> 堆排序</h2>
<p>堆排序是利用堆这个数据结构对数据进行排序，堆的特点是可以在构建完毕后以O(1)的时间找到最大或最小值。堆有很多种实现，最简单也是最常见的实现就是二项堆，其类似一个完全二叉树，不过是以数组形式呈现的，这时下标呈现一个规律，对于一个下标i的元素</p>
<ul>
<li>其父节点的下标：<code>i/2-1</code></li>
<li>其左子节点的下标：<code>i*2+1</code></li>
<li>其右子节点的下标：<code>i*2+2</code></li>
</ul>
<p>如果是升序排序，就构建大顶堆，反之构建小顶堆。</p>
<p>这里以升序为例，父节点与子节点进行比较，如果比子节点小就交换双方位置，交换后继续向下比较，直到遇到第一个比父节点更小的子节点，或者没有子节点了才停止，这个过程被称为下沉。对于一个切片而言，它的最后一个子树的根节点位置位于<code>len(s)/2 -1</code>，逆序遍历每一个子树根节点，对其进行下沉操作。在构建完毕后，此时堆顶的元素一定的最大的那一个，将其与切片中最后一个元素交换，然后再次对堆顶元素进行下沉操作，此时下沉范围不包括最后一个元素，因为已经确定了它是最大值。第二次下沉可以确认堆顶的元素是第二大的，将其与在切片的倒数第二下标的元素交换，然后下沉范围减一，继续第三次下沉，如此循环往复，每次下沉都能找到第k大的元素，最终整个切片都会有序。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度：O(nlogn)</strong></p>
<p>堆排序总共分为两步，第一步构建堆，由于是自底向上构建，如果一个高度为h的子树已经是堆了，那么高度为h+1的子树进行调整的话最多也只需要h步，构建堆的过程的时间复杂度可以是O(n)，详细证明过程可以看：<a href="https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap" target="_blank" rel="noopener noreferrer">Build Binary heap - Wikipedia</a>。在下沉的过程中，对于一个高度为h的完全二叉树而言，最多需要比较h-1次，而高度h就等于log2(n+1)，总共下沉n-1次，其时间复杂度就近似为O(nlogn)，并且不管在任何情况都是O(nlogn)，不会受到数据的影响。</p>
<p><strong>空间复杂度：O(1)</strong></p>
<p>过程中没有用到任何的额外辅助空间</p>
<p><strong>稳定性：否</strong></p>
<p>在排序过程中，需要不断的将堆顶元素放交换到数组末尾，这一过程会破掉坏相等元素的相对位置。</p>
<p><strong>性能测试</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到的是，在10w数据量的情况下，堆排序只需要1秒多一点。</p>
<h2> 归并排序</h2>
<p>归并排序是分治思想的一个体现，1945年由约翰.冯.诺依曼首次提出。它的思路理解起来非常简单，看一个例子，现有如下数据</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>首先是分隔操作，将其分成两份</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在两份的基础之上对半分</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时已经没法再分了，可以直接调整每一份内的顺序，由于只有两个数，只需要简单交换下，现在每一小份的数据内部都是有序的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来就是合并操作，先将其合并为2份，在合并的过程中，可以创建一个临时数组来保存结果，比如合并 <code>0 6 || 2 10</code>，第一步0比2小，所以先写入0</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二步，6比2大，所以写入2</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第三步6比10小，所以写入6，最后写入10。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于每小份内部都是有序的，在合并的时候只需要依次比较元素就可以得到更大的有序的部分，合并成两份数据如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最终延续之前的操作，将其合并为一份，就可以得到排序后的数组。这个过程就是分治的过程，一整个数组不好排序，就将其分为更小的数组，直到不能再分，排序好后再不断合并为更大的有序数组，直到完成排序。这种方式天然适合递归来实现，当然也可以使用迭代来实现，只不过后者要自行模拟栈的行为，较为麻烦。</p>

<p>递归的优点就是简单易懂，如果数据过大，可能会爆栈，而迭代的优点就是可以避免递归栈空间的开销，是真正意义上的O(n)空间，建议使用迭代法。</p>
<p><strong>时间复杂度：O(nlogn)</strong></p>
<p>拿迭代法举例分析，最外层循环每次都会乘2，可以确定是log2^n次，内层循环每次移动一个步长，然后在遍历步长范围内的元素，内循环总的遍历次数就是n次，内外总的时间复杂度就是O(nlogn)。归并排序和堆排序一样，不受数据的影响，始终都是O(nlogn)。</p>
<p><strong>空间复杂度：O(n)</strong></p>
<p>用到了一个临时数组来保存每一轮合并结果</p>
<p><strong>稳定性：是</strong></p>
<p><strong>性能测试</strong></p>
<p>下面是迭代和递归法两个一起测试的结果</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从时间效率上来看，迭代法总体是要优于递归法的，大概提升了10%-25%左右的时间效率。</p>
<h2> 快速排序</h2>
<p>快速排序，又称分区交换排序，也用到了分治的思想，由英国计算机科学家东尼.霍尔在1959年提出。它的平均时间复杂度是O(nlogn)，最差是O(n^2)，尽管如此，在对随机数据的排序效果上，尤其是大量的随机数据，其时间效率的表现比归并排序和堆排序更好一些。</p>
<p>下面介绍一下快排的实现思路：假设有如下数据且是升序排序，总共有10个数字，快排的思路中也需要分治，不过它的方法不会像归并排序一样直接对半分，而是会选取一个基准值，将数组划分成两部分，左半边的部分都比这个基准值小，右半边的部分都比这个基准值大，具体的划分思路如下。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里为了简单演示，选择5作为基准值，然后有左右两端两个指针指向最左和最右，左指针从左往右扫描，遇到比基准值大的元素停下来，右指针从右往左扫描，遇到比基准值小的元素停下来，下面用<code>i</code>表示左指针，<code>j</code>表示右指针。右边先开始扫描，遇到比基准值小的元素就停下，j停在了0所在的位置。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将j所指向的元素的值赋给i所指向的元素</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后左边开始扫描，遇到比基准值大的元素就停下，然后将i所指向元素的值赋给j所指向的元素</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再然后j继续从右边开始扫描，遇到2停下，将其赋值给i所指向的元素，如此循环往复，直到两指针相遇</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相遇过后，此时i和j的位置，就是基准值在这个数组中排序后对应的位置，将基准值赋值到相遇位置上的元素</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时可以发现，基准值5右边的所有数字都大于5，左边的数字全都小于5 ，说明在升序排序的情况下，数字5的下标就位于下标3，至此数字5的位置确定了，每一轮扫描都可以确定一个数字在数组中排序后的位置，接下来就是将数组分为两部分，0-2和4-9，再次对子数组进行相同的操作，直到不可再分。</p>
<p>另一点需要注意的是，如果基准值的选取默认选择在最左边的元素，那么在扫描的时候就需要右边先开始。如果从左边开始，那么左指针i扫描结束后会覆盖j所指向的值，但此处j指向的是最右边的值，把它覆盖过后这个值就丢失了。看下面一个例子，当第一次左指针i扫描完成后两个指针分别指向7和10</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时i会将7赋值给j所指向的元素，也就是将10覆盖为7</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后问题就出现了，10这个数字就不见了，当从右边先开始时，j所覆盖的第一个元素一定是最左边的基准值，因为基准值是单独记录的，所以不存在丢失的问题。同理，基准值取最右边的元素时，就需要左指针先动。考虑一种情况，如果基准值恰好是所有数字中最小的，就像下面的数据一样。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于总是右指针先开始，且基准值已经是最小的了，右指针会移动到1与左指针相遇然后停下，然后子数组被分成了[0,-1]和[1,5]，只产生了一个有效的子数组，后面的每一次递归都是这种情况，第一层递归比较n-1次，第二层递归比较n-2次，第三层比较n-3次，总共会产生n-1次而不是log2<sup>n次递归调用，这样一来它的时间复杂度实际上就变成了O(n</sup>2)。</p>
<p>上面介绍的这个分区方法叫霍尔分区法，在其它教材比如《算法导论》以及英文wiki中介绍的一般是洛穆托分区法，它的代码实现更简单，比较适合用作教学。它的思路可以参考下面这个例子，选取基准值取最右边的元素5，然后有ij两个分别指针指向<code>-1</code>，<code>0</code>，它们的移动方向都是从左到右，并非左右双向指针。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>j先开始扫描，遇到比基准值小的元素停下来，然后i向后移动一位，再交换ij所指向的元素，如此循环往复，直到j移动到最右边</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>扫描结束后，i此时指向的是最后一个小于基准值的数字，所以将i向后移动一位指向8</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后i，j指向的元素互换</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时基准值就被放到了正确的位置上来了，洛穆托分区法跟冒泡很相似，只不过它不会像冒泡一样逐个交换，而是跳跃式的，在最坏情况下，洛穆托分区法的时间复杂度也是O(n^2)。假设升序排序且洛穆托分区法基准值取的是左边，那么两个指针就要从右往左移，比较规则也要从小于换成大于。</p>
<p><strong>代码实现</strong></p>

<p><strong>时间复杂度：O(nlogn)</strong></p>
<p>每一趟扫描的时间复杂度是O(n)，总共扫描log2^n次，所以总的时间复杂度是O(nlogn)。</p>
<p><strong>空间复杂度：O(logn)</strong></p>
<p>它在代码方面确实没有额外的空间，但在有些书籍中会将递归的栈空间也算入空间复杂度中，也就是O(logn)，在上面介绍的最坏的情况下，它的空间复杂度可以达到O(n)。</p>
<p><strong>性能测试</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种分区法并没有特别明显的性能差距，但理论上来讲，洛穆托分区法的交换次数是是霍尔分区法的三倍（证明过程可以前往<a href="https://cs.stackexchange.com/questions/11458/quicksort-partitioning-hoare-vs-lomuto" target="_blank" rel="noopener noreferrer">hoare vs lomuto</a>了解细节）。</p>
<p><strong>优化</strong></p>
<p>上面的快排实现中，在10w数据量的情况下要88ms，同样情况下堆排序和归并排序只需要其十分之一的耗时，显然如此简单的快排实现是不足以应用到实际使用中的，必须对其进行优化。</p>
<p><strong>优化点1</strong></p>
<p>基准值如果是数组中的中位数，就可以做到较为均匀的划分子数组，避免出现取到最小最大值作为基准值的情况，但是取中位数是需要耗费额外的性能，常见的做法是将数组中左右端点和中间位置的三值间的中值作为基准值。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有另一个方法就是随机选取。</p>
<p><strong>优化点2</strong></p>
<p>对于小数组而言，没有必要再用快排继续进行分区递归了，可以使用其它更为简单排序算法来代替，例如C++STL中的排序会在长度小于16时采用插入排序，因为插入排序对于小规模数据比冒泡和选择都更快，并且实现也很简单，转换的临界点也一般在5-16之间。</p>
<p><strong>优化点3</strong></p>
<p>如果含有大量的重复元素，时间复杂度仍然可能会恶化成平方级别。优化方法是使用三路快排，其思想是在单趟排序时将数组划分为三个部分，左边是小于基准值的部分，中间是等于基准值的部分，右边是大于基准值的部分，在后续的排序中，我们只需要处理小于和大于的部分，中间的可以完全不用管，三路快排对于处理有大量重复元素的数组很有效。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>[l, lt-1]</code>表示小于基准值的范围，<code>[gt, r]</code>表示大于基准值的范围，<code>[lt, i]</code>就是等于基准值的范围。举一个例子，如下图</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401261511519.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>我们的任务是将小于基准值的移动到数组左边，大于基准值的移动到右边，所以<code>i</code>不断遍历数组。当<code>i</code>指向的元素小于基准值时，右移<code>lt</code>一位</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401261516880.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此时<code>i</code>指向元素2，等于基准值于是跳过</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401261517300.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>现在<code>i</code>指向的值是3，大于基准值，<code>gt</code>指针左移并和<code>i</code>所指的元素进行交换。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401261519972.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>但交换后的值仍然大于基准值于是继续移动<code>gt</code>指针然后再交换。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401261521618.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>此时的<code>i</code>指向了2，与基准值相同则继续移动，直到等于<code>gt</code>。最后再将基准值归位，即<code>lt</code>与<code>pivot</code>交换位置。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202401261524093.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>至此，区间的划分已经完毕，接下来在进行递归时我们只需要关注左右两个区间即可，中间的就可以忽略掉，这样就起到了优化大量重复元素d</p>
<h2> 计数排序</h2>
<p>计数排序是一种线性时间的排序算法，并且是非比较排序，虽然它可以达到线性时间复杂度，但对使用的数据有一定的要求：数据之间的差值不能有太大，并且会使用额外的辅助空间。它的实现思路如下，首先统计数据中的最小最大值，然后使用一个长度为<code>max-min+1</code>的数组来记录每一个数据的个数，对于计数数组，下标i就等于数据的值，这样一来通过计数数组，天然的就能将其排序，然后反向遍历计数数组根据数量填充原数组。由于数据的限制，该排序方法不太好通过泛型来实现。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度：O(n+k)</strong></p>
<p>寻找最大最小值时花费O(n)，k是最大值和最小值的差值，在计数后写入原数组时，至少会循环k次，所以时间复杂度O(n+k)。当k值远大于O(nlogn)时，说明就不适合使用计数排序来对数据进行排序。</p>
<p><strong>空间复杂度：O(k)</strong></p>
<p>这里用到了<code>counts</code>数组来存放数量信息，花费空间O(k)。我看到网上很多其它实现都会用一个临时数组来存储结果再复制到目标数组中去，这样一来空间复杂度就变成了O(n+k)，不太明白这样做的意义是什么。</p>
<p><strong>稳定性：是</strong></p>
<p>正序读，逆序写保证了相等数据的相对位置。</p>
<p><strong>性能测试</strong></p>
<p>计数排序是用在特定场景的排序方法，不适合随机数据排序，下面的测试用例中的生成数据中的最大差值在1w以内。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到的是即便是数据量来到了10w级别，也没有出现较大的增幅。</p>
<h2> 基数排序</h2>
<p>基数排序同计数排序一样，是非比较排序，同样只适用于特殊场景，不适合普遍的随机数据排序。它的排序思路是根据数据的位数来决定，可以从高位到低位，也可以从低位到高位。这里以以低位到高位举例，比较好理解。现有如下数据，低位数据自动补零方便理解。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>首先将其按照个位的大小排序，得到下面的序列</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在其基础之上根据十位排序得到下面的序列</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在其基础知识根据百位排序</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最终得到有序的数组，基数排序的思路非常简单明了容易理解，代码实现如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到的是在过程中，每一轮的排序方式其实就是计数排序变种，每一个位上的差值最大也就只有9，所以count数组长度也就是固定的10。计数分配好后，因为在这里分配的下标不代表实际的值，所以要累加每一个计数的值，这样就能得到它们排序后的位置。后面就是将其写入临时数组，再复制到原数组中。</p>
<p><strong>时间复杂度：O(kn)</strong></p>
<p>k的最大值的位数，也决定了外层循环的次数，每一次外循环花费的时间是O(n)，总共就是O(nk)。</p>
<p><strong>空间复杂度：O(n+k)</strong></p>
<p>用到了一个长度为n的临时数组用于存放每轮排序结果，和一个计数数组。</p>
<p><strong>稳定性：是</strong></p>
<p>跟计数一样，正序读，逆序写保证了相等数据的相对位置。</p>
<p><strong>性能测试</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里生成的随机数据只包含正整数，10w数据量的情况下只需要7ms，指的是注意的是，基数的选择不止是10进制还可以是十六进制，八进制，二机制，每个进制的基数范围不同。那么为什么它的性能相当优秀但使用没有快排广泛，思考下总共有几点：</p>
<ol>
<li>不太好抽象，适用面窄，比如这个基数排序的例子我都是用int来写的，很难用泛型实现，如果是结构体类型，那么它的特征值可能是浮点数，字符串，或者是负数，甚至是复数，这些类型很对基数进行分解，也就谈不上排序。</li>
<li>第二点就是额外的O(n)空间。</li>
</ol>
<h2> 桶排序</h2>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312081421944.png" type="image/png"/>
    </item>
    <item>
      <title>Flutter在windows桌面软件开发</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/daily/fluttertry.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/daily/fluttertry.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Flutter在windows桌面软件开发</source>
      <description>Flutter在windows桌面软件开发</description>
      <category>技术日志</category>
      <category>每日发现</category>
      <pubDate>Sat, 29 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Flutter在windows桌面软件开发</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307291114364.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>最近打算试一试桌面软件的开发，苦于没有QT基础，并且go的GUI生态太拉跨了。后来在网上了解到Flutter，现在已经可以稳定开发windows桌面软件了，结合Dart进行开发，而且性能相当的可以，于是本文记录一下flutter的尝试。</p>
<p>Flutter官网：<a href="https://flutter.cn/" target="_blank" rel="noopener noreferrer">Flutter: 为所有屏幕创造精彩 - Flutter 中文开发者网站 - Flutter</a></p>
<p>Flutter文档：<a href="https://flutter.cn/docs" target="_blank" rel="noopener noreferrer">Flutter 开发文档 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter</a></p>
<p>Flutter安装：<a href="https://flutter.cn/docs/get-started/install" target="_blank" rel="noopener noreferrer">安装和环境配置 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter</a></p>
<h2> 安装</h2>
<p>第一件事是下载flutter，由于是谷歌开源的，部分网页需要魔法上网。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307291155426.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>下载下来后就是一个压缩包，Flutter SDK是包含了完整的Dart SDK，解压到自己想要的位置后将bin目录添加到系统变量中。</p>
<h2> 换源</h2>
<p>安装完成后，需要配置一下镜像源，因为flutter服务需要下载一些东西，默认配置的话国内网络多半是下载不了的。</p>
<p>清华源：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/flutter/" target="_blank" rel="noopener noreferrer">flutter | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p>可以使用清华镜像源，将以下几个替换掉</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者也可以手动去设置上面三个环境变量。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>其他一些可用的镜像站点：<a href="https://flutter.cn/community/china#%E7%A4%BE%E5%8C%BA%E8%BF%90%E8%A1%8C%E7%9A%84%E9%95%9C%E5%83%8F%E7%AB%99%E7%82%B9" target="_blank" rel="noopener noreferrer">在中国网络环境下使用 Flutter - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter</a></p>
</div>
<h2> 检查依赖</h2>
<p>Flutter的跨平台构建应用是需要依赖其他的一些软件的，windows桌面软件开发需要依赖微软的vs，app的话需要Android Studio，这里只安装vs。</p>
<p>vs安装：<a href="https://learn.microsoft.com/zh-cn/visualstudio/install/install-visual-studio?view=vs-2022" target="_blank" rel="noopener noreferrer">安装 Visual Studio | Microsoft Learn</a></p>
<p>vs安装好后，执行</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到我并没有安装安卓工具链，这里安装的是最新版flutter 3.10.6，正式版从2.0开始就稳定支持windows了。</p>
<h2> Hello World</h2>
<p>使用命令创建项目，过程中需要下载东西，要等一会儿，如果前面的镜像配置好了的话是不需要等多久的。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后运行demo</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>选择要运行的类型</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有web和windows可选，都可以试一试</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307291234496.png" alt="windows桌面软件" tabindex="0" loading="lazy"><figcaption>windows桌面软件</figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307291235487.png" alt="web" tabindex="0" loading="lazy"><figcaption>web</figcaption></figure>
<h2> 体验</h2>
<p>整个过程的初体验还是很不错的，没有深入了解的情况下不太好评价其他地方。在打开web的时候发现整个界面不是传统的html元素，相当于是flutter自己渲染的一套canvas，只能说有点东西。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307291238083.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>等到后面学习的足够深入了再回头做一个系统点的评价。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307291114364.png" type="image/png"/>
    </item>
    <item>
      <title>TOML</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/daily/toml.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/daily/toml.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">TOML</source>
      <description>TOML 为人类而生的配置文件格式</description>
      <category>技术日志</category>
      <category>每日发现</category>
      <pubDate>Wed, 16 Aug 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> TOML</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312021115471.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为人类而生的配置文件格式</p>
<!-- more -->
<p>官方文档：<a href="https://toml.io/cn/" target="_blank" rel="noopener noreferrer">TOML：Tom 的（语义）明显、（配置）最小化的语言</a></p>
<p>主流的配置文件格式有很多，也有各自的缺点，<code>xml</code>，<code>json</code>，<code>yaml</code>，<code>ini</code>，<code>properties</code>等等，都有其各自适用的范围与领域，TOML比起其它的格式，风格上更像是ini的拓展，在基本类型方面而言更加简洁和实用，这是一个很大的优点，但是在嵌套类型上，例如嵌套表，嵌套表数组，为了在写法表现上更加简洁，相应的牺牲就是在语义上变得繁琐和不太容易理解。就作者个人而言认为，目前最主流和最适合的配置文件依旧是<code>yaml</code>，不过抱着学习的心态，对于TOML，未尝不可一试。</p>
<p>Go中对于TOML支持的依赖：<a href="https://pkg.go.dev/search?q=toml" target="_blank" rel="noopener noreferrer">toml - Search Results - Go Packages</a></p>
<h2> 介绍</h2>
<p>TOML是由Github创始人所构建的一种语言，这种语言专门为配置文件而生，旨在成为一个语义明显且易于阅读的最小化配置文件格式。TOML 被设计成可以无歧义地映射为哈希表。TOML 应该能很容易地被解析成各种语言中的数据结构。他们的目的就是<strong>简洁，简单，语义化</strong>，以及<strong>为人而生</strong>的配置文件格式。</p>
<p>TOML非常简单易学，类型丰富，总共支持以下类型：</p>
<ul>
<li>键/值对</li>
<li>数组</li>
<li>表</li>
<li>内联表</li>
<li>表数组</li>
<li>整数 &amp; 浮点数</li>
<li>字符串</li>
<li>布尔值</li>
<li>日期 &amp; 时刻，带可选的时区偏移</li>
</ul>
<p>并且TOML也已经受到了非常广泛的语言支持，其中就包括Go语言。</p>
<h2> 示例</h2>
<p>这是一个十分简单的TOML配置，即便没有了解过TOML也能看个大概，一些细节上的问题等阅读本节后就会全部消失了。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>TOML官方声称自己还在测试版本，不排除日后语法更改的可能性，但是很多团队已经将其纳入生产环境了，具体如何使用需要由各位自行决定。</p>
</div>
<h2> 规范</h2>
<p>TOML的规范特别少，总共就四条：</p>
<ul>
<li>TOML 是大小写敏感的 -- 命名时需要注意大小写</li>
<li>TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档 -- 仅支持UTF-8编码</li>
<li>空白是指制表符（0x09）或空格（0x20）</li>
<li>换行是指 LF（0x0A）或 CRLF（0x0D 0x0A）</li>
</ul>
<h2> 注释</h2>
<p>TOML的注释与其他大多数配置语言类似，都是通过<code>#</code>来进行标注，允许全行注释与行尾注释。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 键值对</h2>
<p>TOML最基本的元素就是键值对，有以下几点需要注意：</p>
<ul>
<li>键名在等号的左边，值在右边</li>
<li>键名和键值周围的空白会被忽略</li>
<li>键名，等号，键值，必须在同一行 （有些值可以跨多行）</li>
<li>键值所允许的类型如下：
<ul>
<li>字符串</li>
<li>整数</li>
<li>浮点数</li>
<li>布尔值</li>
<li>坐标日期时刻</li>
<li>各地日期时刻</li>
<li>各地日期</li>
<li>各地时刻</li>
<li>数组</li>
<li>内联表</li>
</ul>
</li>
</ul>
<p>示例</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个键名必须对应一个键值，不允许空键的存在</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>书写完一行键值对后必须立刻换行</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 键名</h2>
<p>键名分为<strong>裸键</strong>，<strong>引号键</strong>，大多数情况下推荐使用裸键。</p>
<p><strong>裸键</strong>只能包含ASCII字母，ASCII数字，下划线和短横线</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>虽然裸键允许使用纯数字来作键名，但始终会将键名当作字符串来解析</p>
</div>
<p><strong>引号键</strong>的规则与字符串字面量的规则一致，提供对于键名更广泛的使用</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>裸键是无论如何也不能是空键，但引号键允许空键，不过并不推荐这样做</p>
</div>
<p>通过<code>.</code>使键有了层级结构</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 字符串</h2>
<p>TOML中的字符串有四种：<strong>基本字符串</strong>、<strong>多行字符串</strong>、<strong>字面量</strong>、<strong>多行字面量</strong>，所有的字符串都只能包含合法的UTF8-8字符</p>
<p><strong>基本字符串</strong>由双引号<code>"</code>包裹，几乎所有Unicode字符都可以使用，除了部分需要转义</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面是一些常见的转义方法</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>任何 Unicode 字符都可以用 <code>\uXXXX</code> 或 <code>\UXXXXXXXX</code> 的形式来转义。所有上面未列出的其它转义序列都是保留的，如果用了，TOML 应当产生错误。</p>
</div>
<p><strong>多行基本字符串</strong>是由三个引号包裹，允许换行，紧随开头引号的换行会被自动去除</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析的结果根据不同的平台会有不同</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果只是单纯的想写多行，而不想引入换行符以及其他的空白符，可以在行末使用<code>\</code>来消除空白</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当一行的最后一个非空白字符串是违背转义的<code>\</code>时，它会将包括自己在内的所有空白字符一齐清除，直到遇见下一个非空白字符或者结束引号为止</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>也可以在多行基本字符串内的写入一个或两个相连的<code>"</code>，同样可以写在开头和结尾</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></div>
<p><strong>字面量字符串</strong>由单引号包裹，完全不允许转义，多用于书写文件路径，正则表达式等特殊的规则</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>多行字面量</strong>由<code>'''</code>包裹，同样不允许转义，由于没有转义，书写连续三个<code>'</code>将会解析错误</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 整数</h2>
<p>整数是纯数字，可以有<code>+</code>，<code>-</code> 符号前缀</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于一些很长的数字，可以用下划线<code>_</code>来分割以增强可读性，下面以中国人的数字阅读习惯举个例子</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其它进制</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>TOML所允许的整数范围是<code>-2^63 - 2^63-1</code></p>
</div>
<h2> 浮点数</h2>
<p>浮点数应当被实现为 IEEE 754 binary64 值</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小数点前后必须紧邻一个数字</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用<code>_</code>来增强可读性</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>特殊浮点值也能够表示，它们是小写的</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 布尔值</h2>
<p>布尔值只有两种表达，真-<code>true</code>，假-<code>false</code></p>
<h2> 时区日期时刻</h2>
<p><a href="https://rfc-editor.org/rfc/rfc3339" target="_blank" rel="noopener noreferrer">RFC 3339</a>格式的日期格式，需要指定特定的时区偏移量，如下所示</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>规范也允许使用空格替换字母T</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 本地日期时刻</h2>
<p>RFC3339格式的日期时刻省略了日期偏移量，这表示该日期时刻的使用并不涉及时区偏移。在没有其它信息的情况下，并不知道它究竟该被转换成世上的哪一刻，如果仍被要求转换，那结果将取决于实现。</p>
<p>日期</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>时刻</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>日期时刻</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>日期时刻的值如果超出的所实现的精度，多余的部分将会被舍弃</p>
</div>
<h2> 数组</h2>
<p>数组是由方括号<code>[]</code>包裹，子元素由逗号分隔<code>,</code>，可以混和不同类型的值。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组内部可以换行，也可以被注释</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这之前的所有内容作者都觉得是TOML的优点，而往后的内容，就是TOML所诟病的点了。</p>
<h2> 表</h2>
<p>又称为哈希映射表或字典，是键值对的集合。</p>
<p><strong>表头</strong>由方括号定义<code>[]</code>，只作为单独的行出现，其规则与键名一致</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在定义表头时，可以直接定义子表，而无需先定义父表</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其下方直到文件结束或者下一个表头为止，都是这个表头的键值对，且并不保证键值对的顺序。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顶层表，又被称为根表，于文档开始处开始并在第一个表头（或文件结束处）前结束，不同于其它表，它没有名字且无法后置。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>点分隔键为最后一个键名前的每个键名创建并定义一个表，倘若这些表尚未被创建的话。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说实话TOML在表名重定义这块做的有点繁杂，按照作者的理解是：如果一个表已经被方括号表头形式定义过一次了，那么不能再以方括号形式定义同样的表，且使用点分隔键来再次定义这个表也是不被允许的。倘若一个表是通过点分隔符定义的，那么可以通过方括号表头的形式定义其子表。刚开始看这一坨，确实有点绕。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 内联表</h2>
<p>内联表提供了一种更为紧凑的语法来表示表，它们对于分组数据特别有用，否则这些数据很快就会变得冗长，内联表被完整地定义在花括号之中：<code>{</code> 和 <code>}</code>。 括号中，可以出现零或更多个以逗号分隔的键值对，键值对采取与标准表中的键值对相同的形式，什么类型的值都可以，包括内联表。</p>
<p><strong>规范</strong></p>
<ul>
<li>内联表得出现在同一行内</li>
<li>内联表中，最后一对键值对后不允许终逗号（也称为尾逗号）</li>
<li>不允许花括号中出现任何换行，除非在值中它们合法</li>
<li>即便如此，也强烈不建议把一个内联表搞成纵跨多行的样子，如果你发现自己真的需要，那意味着你应该使用标准表</li>
</ul>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述内联表等同于下面的标准表定义：</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内联表是完全独立的，在内部定义全部的键与子表，且不能在括号以外的地方，再添加键与子表。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，内联表不能被用于向一个已定义的表添加键或子表。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 表数组</h2>
<p>可以把表头写在方括号里，表示是一个表数组，按照其出现顺序插入数组。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>等价于 JSON 的如下结构。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>任何对表数组的引用，都指向数组里上一个的表元素，允许在表数组内创建子表和子表数组。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述 TOML 等价于 JSON 的如下结构。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表数组和子表的定义顺序不能颠倒</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>试图向一个静态定义的数组追加内容，即便数组尚且为空，也会在解析时报错。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>若试图用已经确定为数组的名称定义表，会在解析时报错。将数组重定义为普通表的行为，也会在解析时报错。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 拓展名</h2>
<p>TOML配置文件的拓展名均以<code>.toml</code>为准</p>
<h2> MIME类型</h2>
<p>在互联网上传输 TOML 文件时，恰当的 MIME 类型是 <code>application/toml</code></p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312021115471.png" type="image/png"/>
    </item>
    <item>
      <title>Unicode字符集及其编码实现</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/daily/unicode.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/daily/unicode.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Unicode字符集及其编码实现</source>
      <description>Unicode字符集及其编码实现 本文主要介绍Unicode字符集和它的几个实现UTF-8，UTF-16，UTF-32</description>
      <category>技术日志</category>
      <category>每日发现</category>
      <pubDate>Thu, 06 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Unicode字符集及其编码实现</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304061406979.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本文主要介绍Unicode字符集和它的几个实现UTF-8，UTF-16，UTF-32</p>
<!-- more -->
<hr>
<p>在日常的写代码过程中，想必或多或少都跟Unicode打过交道，UTF-8，ISO-8859-1，UTF-16等编码出现的次数相当多，例如项目中的配置文件的编码问题，一个人打开可以正常查看并写入了配置，而另一个人打开后看到的就全是乱码，这种问题实际上也只是编码不同而造成的问题类型之一，为了能更好的去解决这类问题，所以就有必要了解相关知识。</p>
<h2> 基本概念</h2>
<p>在了解本文的内容之前，以下基本概念需要了解。</p>
<h3> 字节</h3>
<p>一个字节占八个比特位，它是字符大小的基本单位。</p>
<h3> 字符</h3>
<p>字符（character），在计算机科学中，一个字符是一个单位的字形，类字形单位或符号的基本信息，可以理解为各种文字和符号的总称。它可以是中文汉字：你，也可以是英文字母：Y，或者是一个标点符号：！，还可以是一个emoji表情：🥙，以及一些不可见的控制符号。不同类型的字符在计算机存储中占用的大小可能会有所不同，比如一个英文字符通常只占用一个字节，但是一个中文字符通常占用三个字节。</p>
<h3> 字符集</h3>
<p>字符集（character set），指某一类字符的集合。字符集会收录某一类特定的字符，比如GB2312字符集是中国国家标准总局发布的，它收录了共7445个字符，其中有六千多个汉字。不同的字符集包含的字符类型不同，在计算机上的编码方式也不同，不过具体的编码方式并不由字符集来指定和实现，字符集的作用是收录字符而不是对字符进行编码。常见的字符集有ASCII字符集，Big5字符集，Unicode字符集。</p>
<h3> 字符编码</h3>
<p>字符编码（character encoding），字符编码就是字符映射规则。众所周知计算机只认识0和1，那么一个字符最终还是要被转换成二进制形式才能方便计算机存储和传输，字符编码要干的就是将字符以某种规则转换成计算机可以理解的二进制形式。最常见和最简单的字符编码就是ASCII编码，它规定用一个字节的低七位去编码字符，例如小写字母a的经过ASCII编码后的二进制形式就是<code>01100001</code>，十进制形式就是97。一般来说，一个字符集可能会有多种编码规则，不同的字符集拥有不同的编码规则。如果一个文本文件是用UTF-8进行编码的，那么在解码的时候就也应该使用UTF-8的规则，如果使用了GBK或者Big5编码的规则进行解码，就只会得到一串人类无法阅读的乱码。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>大部分的编码都兼容ASCII字符集，不过也有少部分不兼容，比如UTF-16编码，UTF-32编码。</p>
</div>
<h3> 编码空间</h3>
<p>编码空间（encoding space）或者又叫码位空间，简单说就是包含所有字符的表的维度。比如说GB2312的编码空间是94x94，因为它总共就只有94x94个码位。同理ISO8859-1有256个码位，所以它的编码空间是256，也可以说是8比特。其实它的表示方式有很多种，总的来说都是在表达字符集所能容纳的字符数量。</p>
<h3> 码点</h3>
<p>码点（code point）又称码位，指的是编码空间中的一个位置。对于一个字符而言，它在编码空间也就是字符集中所占用的码位叫码位值（有点拗口，其实两个都是一个概念）。码位值是可查的，例如在Unicode字符集中，汉字“中”的码点就是U+4E2D。</p>
<br>
<h2> ASCII</h2>
<p>ASCII（American Standard Code for Information Interchange，美国信息互换标准编码）是基于罗马字母表的一套字符集，发布于1967年，因为美国的主流语言是英语，ASCII字符集所包含的字符也只有英文字符，它总共有128个字符。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304061632282.png" alt="ASCII字符集的一部分" tabindex="0" loading="lazy"><figcaption>ASCII字符集的一部分</figcaption></figure>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如果想要查看更完整的ASCII字符集可以前往<a href="https://ascii.org.cn/" target="_blank" rel="noopener noreferrer">ASCII码对照表</a></p>
</div>
<p>ASCII采用的是单字节来表示字符，一个字节有八位，ASCII只有128个字符也就是2的7次方，相当于八位里面只有七位是有用的，所以在ASCII二进制形式中最高位默认为0，就比如第一个字符是空字符它的二进制形式是<code>0000 0000</code>，第128个字符是DEL字符，二进制形式是<code>0111 1111</code>。计算机起源于美国，早期只有美国科学家在使用这些，足够满足他们的使用。</p>
<p>随着计算机技术的不断发展，世界上的各个国家都引进了计算机，ASCII的局限性就体现出来了，世界上的国家有非常多，有些国家使用的语言甚至不止一种。ASCII所包含的字符总共只有128个，肯定是无法表达所有的语言的，于是欧洲将ASCII中字符闲置的最高位利用起来，对ASCII进行了拓展到了256个字符，称为EASCII（Extend ASCII），但其实256个字符也不足以统一整个欧洲的语言字符。</p>
<p>于是后来规定，将这256个字符中的前128个字符用于收录ASCII中的字符，也就说前128个字符与ASCII完全一致，而后128个字符根据欧洲不同的地区而收录不同的字符，这就是后来的ISO 8859系列标准（<a href="https://en.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="noopener noreferrer">ISO/IEC 8859</a>），下面列出一小部分：</p>
<ul>
<li>
<p>ISO8859-1 字符集，也就是 Latin-1，收集了西欧字符。</p>
</li>
<li>
<p>ISO8859-2 字符集，也称为 Latin-2，收集了东欧字符。</p>
</li>
<li>
<p>ISO8859-3 字符集，也称为 Latin-3，收集了南欧字符。</p>
</li>
<li>
<p>ISO8859-4 字符集，也称为 Latin-4，收集了北欧字符。</p>
</li>
</ul>
<p>这样改进了后，欧洲不同地区使用不同的字符集，就可以满足使用了，但是这也仅仅只是满足欧洲语言体系的使用而已，要知道光是中文汉字的数量都有十万多个，于是就有了下面要讲的汉字字符集。</p>
<h2> 汉字字符集</h2>
<p>汉字字符集中，简体字符集中有国标系列字符集，繁体字符集有Big5。</p>
<h3> GB2312</h3>
<p>GB，就是”国标“的拼音GuoBiao的首字母。GB2312编码是第一个汉字编码国家标准，由中国国家标准总局1980年发布，它的全名叫《国家标准信息交换用汉字编码字符集-基本集》。在1981年5月1日开始使用。GB2312编码共收录汉字6763个，其中一级汉字3755个，二级汉字3008个。同时，GB2312编码收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符，前往<a href="https://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php" target="_blank" rel="noopener noreferrer">GB2312查表</a>可以前往查询GB2312编码表。</p>
<p><strong>分区编码</strong></p>
<p>GB2312对收录的字符的表示是分区进行的，一共94个区，每个区有94个位，共有8836个位，这种表示方式称为区位码。下面展示前两个区的字符表。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是分区的规则：</p>
<ul>
<li>每一个区的第0位不记录字符</li>
<li>01-09区收录除汉字外的682个字符。</li>
<li>10-15区为空白区，没有使用。</li>
<li>16-55区收录3755个一级汉字，按拼音排序。</li>
<li>56-87区收录3008个二级汉字，按部首/笔画排序。</li>
<li>88-94区为空白区，没有使用。</li>
</ul>
<p>GB2312既指GB2312字符集，也指GB2312编码。它采用的是双字节编码，第一个字节为高字节，第二个字节为低字节，高字节用于记录字符对应的94个区中的每一个区，低字节用于记录字符一个区中对应的94个位。例如汉字"啊"，是GB2312字符集中的第一个汉字，位于16区的01位，对应的区位码就是1601，GB2312的区位码范围就是0101-9494。</p>
<p>区号和位号分别加上0xA0就是GB2312编码，比如1601的区号是16，位号是01，转换成十六进制就是10和01，高字节为0xA0+0x10=0xB0，低字节为0xA0+0x01=0xA1，高低字节组合起来就是0xB0A1，所以汉字“啊”的GB2312编码就是B0A1。GB2312编码范围：A1A1－FEFE，其中汉字的编码范围为B0A1-F7FE，第一字节0xB0-0xF7（对应区号：16－87），第二个字节0xA1-0xFE（对应位号：01－94）。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304062018572.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>GB2312字符集总共收录了八千多个字符，当时国内的计算机需求并不旺盛，GB2312所以可以满足基本的日常使用。但是随着技术的发展也明显不够用了，于是就有了后来的GBK。</p>
<h3> Big5</h3>
<blockquote>
<p>“大五码”（Big5）是由台湾财团法人信息产业策进会为五大中文套装软件所设计的中文共通内码，在1983年12月完成公告，隔年3月，信息产业策进会与台湾13家厂商签定“16位个人电脑套装软件合作开发（BIG-5）项目（五大中文套装软件）”，因为此中文内码是为台湾自行制作开发之“五大中文套装软件”所设计的，所以就称为Big5中文内码。</p>
</blockquote>
<p>Big5是最常用的繁体中文字符集，共收录13,060个汉字，最初流行于港澳台地区，后面被收录进了GBK。Big5字符集的双字节的编码方式，分高低两个字节，然后组成Big5编码，图示如下：</p>
<figure><img src="https://ask.qcloudimg.com/draft/1300884/ldeacl0av5.jpg?imageView2/2/w/2560/h/7000" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> CJK</h3>
<p>中日韩统一表意文字（英语：CJK Unified Ideographs），也称统一汉字（英语：Unihan），目的是要把分别来自中文、日文、韩文、越南文、壮文中，起源相同、本义相同、形状一样或稍异的表意文字，赋予其在UISO 10646及万国码标准中相同编码。此计划原本只包含中文、日文及韩文中所使用的汉字，旧称中日韩（CJK）统一表意文字（Unified Ideographs）。后来，此计划加入了越南文的喃字，所以合称中日韩越（CJKV）统一表意文字。</p>
<h3> GBK</h3>
<p>GBK，是”国标扩展“拼音GuoBiaoKuoZhan的首字母。1995年12月发布的汉字编码国家标准，是对GB2312编码的扩充，所以完全兼容GB2312字符集，除此之外也支持国际标准ISO/IEC10646-1和国家标准GB13000-1中的全部中日韩汉字（包含部分CJK），还包含了Big5字符集，共收录了21886个字符。</p>
<p><strong>编码</strong></p>
<p>在编码上GBK同样也还是采用的双字节编码，范围在0x8140-0xFEFE之间，高字节在0x81-0xFE范围内，低字节在0x40-0xFE范围内。GBK中总共有三大区：</p>
<ul>
<li>汉字区
<ul>
<li>GB2312汉字区</li>
<li>GB13000.1扩充汉字区</li>
</ul>
</li>
<li>图形符号区
<ul>
<li>GB2312非汉字区</li>
<li>GB13000.1扩充的非汉字区</li>
</ul>
</li>
<li>自定义区</li>
</ul>
<p>下面展示一些GBK中81区到8F区的字符表</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如第一个汉字丂位于81区，位置在4行0列，所以它的GBK编码为8140。</p>
<h3> GB18030</h3>
<p>2000年3月17日发布的汉字编码国家标准，是对GBK编码的扩充，覆盖中文、日文、朝鲜语和中国少数民族文字，其中收录27484个汉字。GB18030字符集采用单字节、双字节和四字节三种方式对字符编码。兼容GBK和GB2312字符集。2005年11月8日，发布了修订版本：GB18030-2005，共收录汉字七万余个。2022年7月19日，发布了第二次修订版本：GB18030-2022，收录汉字总数八万余个。</p>
<p><strong>编码</strong></p>
<p>GB18030编码向下兼容GBK编码和GB2312编码，它采用了单字节、双字节、四字节分段编码方案。</p>
<ul>
<li>
<p>单字节部分采用GB/T 11383的编码结构与规则，使用0x00至0x7F码位共128个字符（对应ASCII码位）。</p>
</li>
<li>
<p>双字节部分，首字节码位从0x81至0xFE，尾字节码位分别是0x40至0x7E和0x80至0xFE。</p>
</li>
<li>
<p>四字节部分采用GB/T 11383未采用的0x30到0x39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0x81308130到0xFE39FE39。其中第一、三个字节编码码位均为0x81至0xFE，第二、四个字节编码码位均为0x30至0x39</p>
</li>
</ul>
<p>下表是GB18030-2022收录的汉字。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304071521996.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>国家标准查询网站<a href="https://openstd.samr.gov.cn/bzgk/gb/index" target="_blank" rel="noopener noreferrer">国家标准全文公开 (samr.gov.cn)</a></p>
</div>
<h2> Unicode</h2>
<p>Unicode，它是由Unicode联盟创建并维护的，中文名为统一码，由于它收录了世界上绝大多数国家的字符所以又称作万国码。它提供了一种跨平台的乱码问题解决方案，Unicode使用数字来处理字符，为每一个字符指定一个唯一的代码，并将字符视觉上的任务交给其他软件来自行处理。Unicode的编码空间从U+0000到U+10FFFF，共有1,112,064个码位可用来映射字符。</p>
<p>Unicode是当今互联网最流行的字符集发展自USC（ISO/IEC 10646），首个版本发布于1991年10月，最初的目标是为了解决ISO 8859-1所不能解决的计算机多语问题（即一台电脑可以处理多个语言混合的情况），最新版本的Unicode15发布于2022年9月，共收录了161种文字和14万多个字符，现在成为了国际标准通用字符集。</p>
<p>UTF指的是Unicode Transformation Format中文称为Unicode转换格式，Unicode的编码实现方式中最流行的当属于UTF-8，除此之外还有UTF-16和不怎么常用的UTF-32，以及被淘汰了的UTF-7。</p>
<h3> UTF8</h3>
<p>UTF-8（8-bit Unicode Transformation Format），是由Ken Thompson和Robo Pike（他们两个在后来还共同设计了Go语言）共同设计并提出。UTF8是基于Unicode实现的可变长编码，在日后随着计算机的普及，UTF8的编码的使用率高达95%以上，以至于IETF互联网工程小组甚至要求所有的互联网协议都必须支持UTF8。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>Mysql字符编码集中，同时支持utf8和uftmb4，前者一个字符最多占用3个字节，后者一个字符最多占用4个字节，utf8mb4才是utf8的完整实现。</p>
</div>
<p>UTF-8最初使用一至六个字节为每个字符编码，2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说最多四个字节，UTF-8对于所有常用的字符差不多都可以采用三个字节来表示。在UTF-8编码中，对于一个任意字节B，有着如下规则：</p>
<ul>
<li>对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)</li>
<li>如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)</li>
<li>如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节</li>
<li>如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节</li>
<li>如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节</li>
</ul>
<p>通过第二条规则可以很轻易的判断出该字符是不是一个ASCII字符。对于一个任意字符，如果它占用的字节大于1，那么除了第一个字节外，其余字节都以10开头，如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">码点的位数</th>
<th style="text-align:center">码点起值</th>
<th style="text-align:center">码点终值</th>
<th style="text-align:center">字节序列</th>
<th style="text-align:center">Byte 1</th>
<th style="text-align:center">Byte 2</th>
<th style="text-align:center">Byte 3</th>
<th style="text-align:center">Byte 4</th>
<th style="text-align:center">Byte 5</th>
<th style="text-align:center">Byte 6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">U+0000</td>
<td style="text-align:center">U+007F</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><code>0xxxxxxx</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">U+0080</td>
<td style="text-align:center">U+07FF</td>
<td style="text-align:center">2</td>
<td style="text-align:center"><code>110xxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">U+0800</td>
<td style="text-align:center">U+FFFF</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><code>1110xxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">U+10000</td>
<td style="text-align:center">U+1FFFFF</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><code>11110xxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center">U+200000</td>
<td style="text-align:center">U+3FFFFFF</td>
<td style="text-align:center">5</td>
<td style="text-align:center"><code>111110xx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">U+4000000</td>
<td style="text-align:center">U+7FFFFFFF</td>
<td style="text-align:center">6</td>
<td style="text-align:center"><code>1111110x</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
<td style="text-align:center"><code>10xxxxxx</code></td>
</tr>
</tbody>
</table>
<p>例如中文简体汉字“爱”的Unicode码点为U+7231，位于U+0800 - U+FFFF范围内，所以爱的UTF-8编码需要三个字节，接下来将0x7231转换成二进制形式，从最低位开始每一次取6位，最后一次取成4位，不够的补0，最后就是如下二进制</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>根据规则填入后就变成了如下，可以看出就是三个字节的大小</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不过一般用于表述时的使用形式是十六进制</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304071720118.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>UTF-8编码的字符可以很轻易的通过第一个字节得知该字符占用的字节数。</p>
<h3> UTF16</h3>
<p>UTF-16是Unicode字符集的一种变长编码实现方式，它把Unicode字符集的抽象码位映射成16位长的整数序列，用于数据存储和传递，它使用两个或四个字节来编码字符，编码规则如下，已知Unicode范围是U+0000 - U+10FFFF。</p>
<table>
<thead>
<tr>
<th>码点起值</th>
<th>码点终值</th>
<th>字节</th>
<th>规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>U+0000</td>
<td>U+D7FF</td>
<td>2</td>
<td>UTF16-编码就是Unicode码点，不进行任何转换</td>
</tr>
<tr>
<td>U+E000</td>
<td>U+FFFF</td>
<td>2</td>
<td>UTF16-编码就是Unicode码点，不进行任何转换</td>
</tr>
<tr>
<td>U+10000</td>
<td>U+10FFFF</td>
<td>4</td>
<td>码位减去0x10000，转换成二进制，得到20位二进制序列。高10位的值加上0xD800形成一个16个序列，低十位的值加上DC00形成一个16位序列，然后再拼成一个完整的二进制序列，就得到了一个Unicode字符的UTF-16编码。</td>
</tr>
<tr>
<td>U+D800</td>
<td>U+DFFF</td>
<td>无</td>
<td>不对应任何字符，算作编码错误</td>
</tr>
</tbody>
</table>
<p>比如美元符号"$"，它的Unicode码点是U+0024，它并不在U+10000到U+10FFFF的范围内，所0024就是它的UTF-16编码，占用两个字节。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304072120742.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>再比如符号𐐷的码点是U+10437，二进制序列是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>高十位加上0xD800，低十位加上0xDC00，就变成了下方的序列</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它的十六进制形式是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它的UTF-16编码占用4个字节，这种编码方式并不兼容ASCII码。</p>
<h3> UTF32</h3>
<p>UTF-32是固定长度编码，每个码位使用4个字节，Unicode码位直接存储位UTF-32编码，没有任何规则。这种编码几乎没有使用，因为它极大的浪费了空间，由UTF-32所编码的文件占用大概是UTF-16的两倍，UTF-8的四倍。</p>
<p>它唯一的优点就是定索引非常方便，因为是定长编码，字符位置直接使用十进制数，每加一就是下一个字符。</p>
<h2> 其他概念</h2>
<h3> 字节序</h3>
<p>对于UTF序列编码而言，UTF-8不存在字节序问题，因为它的编码单元就是一个字节，没有高低位之分，一次取一个字节就完事。但是UTF-16和UTF-32不同，它至少每次要处理两个字节或4个字节，这就涉及到了字节序的问题。例如Unicode字符集中的汉字“你”，UTF-8编码为EDBDA0，这是大端序，小端序就是低位在低地址，高位在高地址，就是反过来0ADBDE，反正读取时都是从低地址开始读，结果都是一样的。所以这并不会产生什么问题。</p>
<p>汉字”你“的UTF-16的大端编码是4F60，小端是604F，它的单位是两个字节，读取时都是从低地址开始读的，不知道大小端序的话，就不清楚谁是高位字节，谁是低位字节，如果本身是大端序，按照小端序读取的话就成了604F，这完全变成另一个字符了，UTF-32同理。</p>
<figure><img src="https://pic3.zhimg.com/80/v2-2e698172dc190d7e7b510e4e95886dae_720w.webp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>所以应该显式的告诉计算机是大端序还是小端序，因此UTF-16编码分为UTF-16BE和UTF-16LE，同理也UTF-32也分为UTF-32BE和UTF-32LE。</p>
<h3> BOM</h3>
<p>BOM（byte order mark），中文名为字节序标记。UTF系列的文件通常用零宽非换行空格符（U+FEFF）用于标记大小端序。UTF-8文件有时候也会用到它，不过仅仅只是用来标记该文件是UTF-8文件，它的UTF-8编码是EF BB BF。对于UTF-16的文件而言，标记是FE FF，就是大端序，FF FE就是小端序。</p>
<p>据说给UTF-8文件加BOM头是微软为了兼容旧系统的编码，但是这可能在其他的操作系统就不一定适用了，比如Unix，因为他们的设计原则是“文档中的所有字符必须可见”，所以在windows系统上编写的shell脚本，在unix上就不一定能运行，一些源代码文件也可能会出现编译问题。</p>
<h2> 总结</h2>
<p>一图胜千言，下面这张图可以很直观的看出各个字符集之间的关系。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304071431437.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>国标系列的GB字符集从始至终都向下兼容，在后续更新中慢慢的还囊括了CJK，Big5等其他语种的字符集，但可能并不兼容。ISO8859是早期欧洲为了方便因国家之间语言的细微差异而在ASCII基础之上衍生的一系列字符集。Unicode与GB18030相互不兼容，两者都想收录世界上的绝大多数语言的文字和字符，只不过目前来看Unicode更流行一些，Unicode同时还兼容ISO8859-1。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304061406979.png" type="image/png"/>
    </item>
    <item>
      <title>存储模型 --- Bitcask</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/bitcask.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/bitcask.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">存储模型 --- Bitcask</source>
      <description>存储模型 --- Bitcask</description>
      <category>db</category>
      <pubDate>Fri, 10 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 存储模型 --- Bitcask</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312021440442.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<h2> 简介</h2>
<p>在面向磁盘的Key/value数据库设计中，常见存储模型的有B+Tree，LSM，前者读性能优秀，后者写性能优秀，它们两个已经有了非常多的实践案例，比如基于B+Tree的<code>BoltDB</code>，基于LSM的<code>LevelDB</code>。不过今天的主角讲的并不是它们两个，而是另一个存储模型Bitcask，它最早是由一个日本分布式存储公司Riak提出的理论，与LSM类似，它也是日志结构，不过实现起来要比LSM简单的多。</p>
<p>Bitcask文档：<a href="https://riak.com/assets/bitcask-intro.pdf" target="_blank" rel="noopener noreferrer">riak-bitcask</a></p>
<p>Riak公司最初希望寻找一个满足以下条件的存储引擎</p>
<ul>
<li>读写低延迟</li>
<li>高吞吐量随机写入</li>
<li>在高负载情况下，行为可以预测</li>
<li>具有处理比内存更大空间数据的能力</li>
<li>崩溃友好，可以快速恢复而不丢失数据</li>
<li>易于备份和恢复</li>
<li>简单易懂的数据格式，且易于实现</li>
<li>简单的使用协议</li>
</ul>
<p>找到满足上面部分条件的很容易，但是满足全部条件的几乎没有，于是这促使他们开始自己去研究一种日志化结构的KV存储引擎，受到LSM的启发，而后便设计了Bitcask这一个可以满足上述所有要求的存储模型，所以Bitcask实际上也是一种类LSM的结构。</p>
<h2> 设计</h2>
<p>在了解完Bitcask的历史后，下面来说说它究竟是如何设计的。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101550346.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一个Bitcask实例就是一个文件夹，文件夹存放着若干个数据文件，这些文件分为Active Data File和Older Data File。在某一时刻，数据会被写入到Active Data File也就是活跃文件，当文件存放的数据达到阈值后，当前活跃文件将被关闭并成为旧数据文件，旧数据文件一旦被关闭过后，日后永远都不会再对其写入数据。然后会创建一个新的活跃数据文件用于写入新数据，同一时刻只能有一个进程对活跃数据文件写入数据。文件的写入操作是通过追加（append only）的方式进行，由于是顺序IO所以不需要多余的磁盘寻址操作。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101602964.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Bitcask的数据格式同样很简单，如图所示，由以下几个部分组成</p>
<ul>
<li>crc，循环冗余校验码</li>
<li>tstamp，时间戳</li>
<li>ksz，键的所占用的空间大小</li>
<li>value_sz，值所占用的空间大小</li>
<li>key，存放键</li>
<li>value，存放值</li>
</ul>
<p>每一次对活跃数据文件写入数据，就会添加一条新的数据条目，对于删除操作而言，并不会真的去删除文件里面的数据，而且将其作为一个特殊的数据条目写入文件中来标记该数据被删除，待到下次文件合并时，数据才会被真正的删除。Bitcask数据文件只不过是这些数据条目的线性序列，如下图所示。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101613871.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在向磁盘写完数据以后，就会去更新keydir"。"keydir"并不是一个真的文件夹，它是一个维护在内存中的索引结构，负责映射每一个key的元信息。这些元信息包括</p>
<ul>
<li>file_id，标识数据存放在哪一个文件</li>
<li>value_sz，数据所占用的空间大小</li>
<li>value_pos，数据在文件中的位置</li>
<li>tstamp，时间戳</li>
</ul>
<p>如下图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101620287.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当更新数据时，并不会去更新旧数据文件中的指定数据条目，而是向当前的活跃数据文件添加新的数据条目，然后keydir会原子的更新最新数据的位置，旧数据依旧保存在磁盘中，往后的数据读取操作会使用keydir中的最新位置来进行访问，至于旧数据条目会在后续的合并过程中被删除。</p>
<p>对于读数据而言，只需要进行一次磁盘寻道。首先会从内存中维护的keydir找到与之匹配的数据元信息，得知数据存放在哪一个文件，以及文件中的位置信息，然后再去对应的数据文件中读取响应的数据条目信息，凭借着操作系统的预读文件缓存，这一过程可能会比预期的还要更快。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101643358.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在上面的删除和更新操作中，都会产生额外的新数据条目，对于旧数据条目则不会再使用，随着时间的推移，这种冗余的数据条目会越来越多，就会占用相当大一部分的空间，为此需要就需要去清理这些旧的数据文件，这个过程就称之为合并。在合并过程中，会遍历所有的旧数据文件，然后输出一系列只包含最新数据的文件，在合并的同时，还会创建Hint File，也就是索引文件，每一个合并过后的Merged Data File都有一个对应的Hint File，Hint File中的数据条目与内存中的keydir相对应，前者是后者的持久化体现。Hint File只存储数据元信息，并不存储实际的数据，它的作用是为了在Bitacask实例启动时，更快速的构建内存索引。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101706570.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这些就是Bitcask所有的设计内容，可以看得出确实比较简单和容易理解。官方还做了以下几点的说明</p>
<ol>
<li>Bitcask读性能依赖于操作系统的文件系统缓存，他们曾经讨论设计过关于Bitcask的内部缓存，这可能会使Bitcask变得更复杂，且不清楚这样做的带来的性能收益是否可以抵过随之而来的复杂性，毕竟设计的初衷就是要足够简单。</li>
<li>Bitcask不会对数据进行任何的压缩，因为这种行为的收益与损耗依赖具体的应用。</li>
<li>在早期的测试中，一台低配的笔记本电脑上，Bitcask每秒可以执行5000-6000次左右的写入操作。</li>
<li>在早期的测试中，Bitcask可以存储10倍于内存的数据而不会出现性能下降的情况。</li>
<li>在早期的测试中，即便有数百万个key，keydir所占用的内存也不到GB。</li>
</ol>
<h2> 总结</h2>
<p>Bitacask在设计之初就不是追求<strong>最快</strong>的速度，作者觉得快到足够使用即可，它使用内存来做索引，用磁盘来存储数据，具有实现简单，可读性强，性能优秀等众多优点。由于它只有一个写入点，且只能是串行写入，所以尤其适合存储大量只需一次IO就能写入的小块数据，对于大块数据而言，会使得吞吐量非常低。</p>
<p>鉴于其简单的设计，非常适合初学者学习和入门，社区里面也有很多开源实现，比如<code>nutsDB</code>，<code>roseDB</code>，两者都是嵌入式KV数据库，均为go语言实现。动手自己实现一个基于Bitacask的数据库，可以加深理解。</p>
<h2> API</h2>
<p>Riak官方在文档中描述了Bitcask参考的API，仅仅只有几个接口，下面以go语言的伪代码展示。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312021440442.png" type="image/png"/>
    </item>
    <item>
      <title>Docker上安装MariaDB</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_mariadb.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_mariadb.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Docker上安装MariaDB</source>
      <description>Docker上安装MariaDB</description>
      <category>db</category>
      <pubDate>Fri, 06 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Docker上安装MariaDB</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111859077.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>官网：<a href="https://mariadb.org/" target="_blank" rel="noopener noreferrer">MariaDB</a></p>
<p>开源地址：<a href="https://github.com/MariaDB/server" target="_blank" rel="noopener noreferrer">https://github.com/MariaDB/server</a></p>
<p>在Mysql被Oracle收购以后，MySql之父觉得此时的Mysql不再是一个纯粹的开源数据库了。于是没多久便出走了，随后他便从Mysql社区fork出来一个新的分支：MariaDB，到目前为止已经是一的独立的项目了。该数据库以作者女儿的名字来命名的，相比于Mysql而言它是一个完全开源的数据库，在协议和表定义方面也兼容，相比于mysql社区版支持更多的存储引擎和功能。</p>
<h3> 镜像</h3>
<p>镜像地址：<a href="https://hub.docker.com/_/mariadb" target="_blank" rel="noopener noreferrer">mariadb - Official Image | Docker Hub</a></p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310121029029.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>目前的维护版本有11和10，因为是开源社区维护的，所以版本迭代要比mysql快很多，这里选择相对稳定的10</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 准备</h3>
<p>准备好要挂载数据的文件夹</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>maridadb在这些方面都与mysql兼容，所以基本类似，创建配置文件<code>~/db/mariadb/conf/my.cnf</code></p>
<div class="language-ini line-numbers-mode" data-ext="ini"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 容器</h3>
<p>运行如下命令创建容器，mariadb使用的配置目录跟mysql完全一致</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建起容器后看看是否正常运行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进入容器里面看看数据库命令行，这里使用<code>mysql</code>命令也可以登录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看看数据库，可以看到默认的hello数据库成功创建</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 连接</h3>
<p>我用的navicat15，已经支持mariadb，正常来说它的协议应该跟mysql完全兼容。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310121055491.png" style="zoom: 80%;">
<p>就目前而言感受不到太大的区别，以后用的深了一点再来评价吧。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111859077.png" type="image/png"/>
    </item>
    <item>
      <title>Docker上安装MongoDB</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_mongo.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_mongo.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Docker上安装MongoDB</source>
      <description>Docker上安装MongoDB</description>
      <category>db</category>
      <pubDate>Mon, 24 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Docker上安装MongoDB</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111838486.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>官网：<a href="https://www.mongodb.com/zh-cn" target="_blank" rel="noopener noreferrer">MongoDB</a></p>
<p>mongodb是一个高性能的非关系型数据库，或者说文档数据库因为它的基本单位就是文档，在我的一个开源项目中主要拿它来存游戏信息，比较灵活，存在mysql纯纯是找罪受。mongodb说实话第一次看到的时候，SQL写起来真的反人类，弄成了json的样子，如果语句长了点嵌套多了点，可读性骤然下降。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尤其是花括号看的真的眼花，这玩意在命令行里面敲起来是真滴折磨。</p>
<h3> 镜像</h3>
<p>镜像地址：<a href="https://hub.docker.com/_/mongo" target="_blank" rel="noopener noreferrer">mongo - Official Image | Docker Hub</a></p>
<p>这里我就直接用mongo6</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>镜像拉下来以后看看</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>681MB说实话挺大了</p>
<h3> 配置</h3>
<p>创建要挂载的数据目录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建默认的配置文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>写入如下配置</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建默认的日志文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 容器</h3>
<p>运行如下命令创建容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的参数</p>
<ul>
<li>环境变量<code>LANG</code>是为了设置数据库字符编码</li>
<li><code>-f /etc/mongo/mongod.conf</code>指定具体的配置文件地址</li>
</ul>
<p>容器创建完毕后，查看一下是否正常运行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后进入数据库命令行操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于初始时是没有默认的用户和密码，所以进来就是test用户，接下来创建一个管理员账号，先写sql</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主要有以下权限可以用</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>切换倒admin数据库后再创建</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看用户列表</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成后，退出然后修改mongo的配置文件添加</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>重启容器之后再重新登录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 连接</h3>
<p>navicat也支持mongodb数据库，如果上面操作正确的话，连接应该是不会有问题的。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310112316660.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111838486.png" type="image/png"/>
    </item>
    <item>
      <title>Docker上安装Mysql</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_mysql.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_mysql.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Docker上安装Mysql</source>
      <description>Docker上安装Mysql</description>
      <category>db</category>
      <pubDate>Mon, 07 Nov 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Docker上安装Mysql</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111830040.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>官网：<a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener noreferrer">MySQL :: MySQL Documentation</a></p>
<p>mysql是很经典的一个数据库了，刚接触到这个数据库的时候还是刚刚大一下那会，那会在windows上安装把密码给整忘了捣鼓了老半天才整回来。日后在学习的时候，捣鼓中间件都是在本地的Linux虚拟机上+docker捣鼓，再也不会把这些玩意安装在windows上了。</p>
<h3> 镜像</h3>
<p>镜像地址：<a href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener noreferrer">mysql - Official Image | Docker Hub</a></p>
<p>Mysql常用的版本只有8和5，最常用的应该是5.7，不过我在写代码的时候用的都是mysql8。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看下镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 准备</h3>
<p>创建本地用于挂载数据的文件夹</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建mysql配置文件<code>~/db/mysql/conf/my.cnf</code></p>
<div class="language-ini line-numbers-mode" data-ext="ini"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 容器</h3>
<p>运行如下命令，创建容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>MYSQL_ROOT_PASSWORD</code>，root用户的默认密码，不指定的话会在输出中显示默认密码</li>
<li><code>MYSQL_DATABASE</code>，默认创建的数据库名</li>
</ul>
<p>看看mysql容器有没有成功运行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用mysql命令访问数据库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看有哪些数据库，可以看到hello数据库被成功创建了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看hello数据库中的表，可以看到空空如也</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 连接</h3>
<p>切换到<code>mysql</code>数据库，然后查看<code>user</code>表</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到root账户默认是允许远程登录的，一般建议创建一个新的账号来用，然后再禁用root远程登录，如果只是自己学习的话那无所谓了，修改完以后记得刷新下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再用navicat连接</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111949722.png" style="zoom:50%;">
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111830040.png" type="image/png"/>
    </item>
    <item>
      <title>Docker上安装PostgreSql</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_postgres.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_postgres.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Docker上安装PostgreSql</source>
      <description>Docker上安装PostgreSql</description>
      <category>db</category>
      <pubDate>Sat, 30 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Docker上安装PostgreSql</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111522417.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>官网：<a href="https://www.postgresql.org/" target="_blank" rel="noopener noreferrer">PostgreSQL: The world's most advanced open source database</a></p>
<p>关系型数据库的话以前只学习过mysql一种，最近打算来捣鼓一下大名鼎鼎的postgresql，官网的标题就是<strong>世界上最先进的关系型数据库</strong>。为了方便学习，采用本地虚拟机+docker的方式进行安装。</p>
<h3> 镜像</h3>
<p>首先在dockerhub看看镜像<a href="https://hub.docker.com/_/postgres" target="_blank" rel="noopener noreferrer">postgres - Official Image | Docker Hub</a></p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111516192.png" alt="" style="zoom: 50%;">
<p>一看postgresql的维护版本这么多，不知道选什么就选最稳的<code>11</code>。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>16版本的话navicat还不太兼容</p>
</div>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看下镜像</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 容器</h3>
<p>运行如下命令创建容i去</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>POSTGRES_PASSWORD</code>，环境变量，设置超级用户默认密码</li>
<li><code>LANG</code>，环境变量，设置字符集</li>
</ul>
<p>跑起来看看看日志</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再看看ps</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 命令行</h3>
<p>容器成功运行以后，到数据库命令行里面看看，默认的超级用户名为<code>postgres</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>pg的命令行有独特的命令，不像<code>mysql</code>全是SQL语句，一般以下划线<code>\</code>开头，<code>\?</code>查看帮助命令。查看所有的数据库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看所有用户</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看两个配置文件的地址</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>退出命令行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 远程登录</h3>
<p>pg默认是不允许远程登录的，必须得修改其配置文件。修改<code>postgresql.conf</code>文件的中监听地址为如下。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再修改<code>pg_hba.conf</code>，添加如下规则</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完后把容器重启下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111643870.png" style="zoom: 80%;">
<p>然后就可以连接成功了。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111522417.png" type="image/png"/>
    </item>
    <item>
      <title>Docker上安装Redis</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_redis.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/docker_install_redis.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Docker上安装Redis</source>
      <description>Docker上安装Redis</description>
      <category>db</category>
      <pubDate>Mon, 17 Jan 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Docker上安装Redis</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111832973.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>官网：<a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis</a></p>
<p>Redis是我接触的第一个NoSQL数据库，一般是拿来做缓存用，不支持windows。刚开始用的windows版，一看版本redis2，几年没维护了，后面只能在虚拟机上捣鼓了，算是我接触虚拟机和Linux系统的一个契机。</p>
<h3> 镜像</h3>
<p>镜像地址：<a href="https://hub.docker.com/_/redis" target="_blank" rel="noopener noreferrer">redis - Official Image | Docker Hub</a></p>
<p>redis现在的维护版本有6和7，两个的区别就是RESP协议的区别，一个是RESP2，一个是RESP3，理论上来说RESP3应该是兼容RESP2的，不过Redis社区声称以后不会兼容RESP2。这里用的是版本7。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看下镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置</h3>
<p>配置文件地址：<a href="https://redis.io/docs/management/config/" target="_blank" rel="noopener noreferrer">https://redis.io/docs/management/config/</a></p>
<p>redis默认是不允许远程连接，而且没有密码，这些需要在配置文件中指定，对应指定版本的redis需要去官网下载配置文件。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310112029549.png" style="zoom: 67%;">
<p>这里选择的是7.0版本的配置文件，首先创建容器的数据挂载文件夹</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后下载配置文件，因为是外网可能不太好下载</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后将里面的如下四个配置修改如下值，然后保存退出。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件的路径位于<code>~/db/redis/redis.conf</code>，然后还要记得把日志文件自己创建下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 容器</h3>
<p>运行如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建后查看下有没有正常运行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进入容器测试下命令行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 连接</h3>
<p>redis客户端软件的话推荐两个，虽然navicat也支持redis连接，但还是那种行列方式看起来相当膈应。</p>
<ul>
<li><a href="https://github.com/RedisInsight/RedisDesktopManager" target="_blank" rel="noopener noreferrer">Redis Manager</a>，开源，c++项目，性能应该要好很多</li>
<li><a href="https://github.com/qishibo/AnotherRedisDesktopManager" target="_blank" rel="noopener noreferrer">Another Redis Manager</a>，开源，nodejs项目，目测应该是electron之类构建的，性能没测试过。</li>
</ul>
<p>上面两个都是开源的，且都支持中文，我都有在用，前者毕竟c++写的项目，nodejs性能跟它没法比，但后者界面更加人性化，功能要多很多。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310112123845.png" style="zoom: 67%;">
<p>如果前面的配置正常来搞的话这里连接是不会出问题的。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310112125867.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到关于redis的很多统计信息。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111832973.png" type="image/png"/>
    </item>
    <item>
      <title>MsSQL索引字节数超出最大值</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/index_length_exceed.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/index_length_exceed.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">MsSQL索引字节数超出最大值</source>
      <description>MsSQL索引字节数超出最大值</description>
      <category>db</category>
      <pubDate>Wed, 20 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> MsSQL索引字节数超出最大值</h1>
<!-- more -->
<hr>
<h2> 问题</h2>
<p>最近在开发的时候遇到了一个索引上的问题，模型结构体如下</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从中可以看到创建了一个联合唯一索引<code>perm</code>，那么在使用gorm迁移数据库时，会报如下的错误</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>mysql已经提示说你的索引太长了，最大只能是<code>3072</code>个字节数，那么究竟占了多少个字节数呢，计算方法就是类型占用字节数，由于我的mysql版本是8.0，字符集设置的是<code>utf8mb4</code>，一般来说索引限制有两种情况</p>
<ul>
<li>ROW_FORMAT= COMPACT 或 REDUNDANT，单列索引支持的最大长达为767bytes。</li>
<li>ROW_FORMAT= COMPRESSED 或 DYNAMIC，单列索引支持的最大长度为3072bytes。</li>
</ul>
<p>一个字符占用的是4个字节，那么上面结构体中索引的所占用的字节就是<code>255 x 4 x 4 = 4080</code>，总共4080个字节大于3072，所以自然就无法成功创建。</p>
<h2> 解决</h2>
<p>既然已经发现了问题所在，那么该如何解决？在经过一顿资料查找后，总结出了几种解决办法。</p>
<h3> 减少长度</h3>
<p>在上面的结构中，其实很多字段是没有必要设置<code>255</code>长度的，比如对于<code>tag</code>来说，<code>50</code>的长度就差不多够用了，比如说修改成如下长度。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>(100+50+30+30) x 4 = 840 </code>，总共840个字节，远小于3072的限制。但万一业务需要就得这么大的长度，这种情况就不适用了。</p>
<h3> 前缀索引</h3>
]]></content:encoded>
    </item>
    <item>
      <title>RiverDB</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/river_db.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/river_db.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">RiverDB</source>
      <description>RiverDB</description>
      <category>db</category>
      <pubDate>Sat, 02 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> RiverDB</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312031440217.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<h2> 开头</h2>
<p>大概在11月份，我写了两篇文章，一篇讲的是Bitcask，另一个讲的是Write Ahead Log，这两个东西跟数据库都有着莫大的关系。写完以后，我便萌生了一个想法，能不能自己动手写一个数据库，因为在此前数据库对我来说都只是使用而已，写一个数据库似乎有点遥不可及，并且从来没有接触过这些。想到就做，于是我花了点时间去参考了Github上比较知名的开源数据库包括：Badger，LevelDB，godis，RoseDB，NutsDB等</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312022119275.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>主流数据库的存储模型有B+Tree和LSM，最终选择了使用Bitcask存储模型来作为我的入门选择，它就像是简化版的LSM，因为它足够简单，不至于太难一上来直接劝退，也是我选择它的一大原因，准备妥当后，便开始着手朝着这个未知的领域窥探一番。</p>
<p>正所谓万事开头难，第一个问题就是数据库叫什么名字，虽然写出来可能没人用，但好歹要有一个名字。在思索一番过后，决定取名为<code>river</code>，这个名字来自初中时候玩的一款游戏《去月球》，里面的女主就叫river。在建完github仓库后，便开始思考一个数据库要有什么，首先可以确定的是这是一个KV数据库，最基本的增删改查肯定是要保证的，然后就是TTL可以整一个，给键值上一个过期时间，既然有了TTL，肯定要能单独查询和修改TTL的功能，还有一个最最重要的就是事务支持，以及批量写入数据和批量删除数据，梳理一下就是</p>
<ul>
<li>基本的增删改查</li>
<li>TTL过期时间支持</li>
<li>事务支持</li>
<li>批量处理数据</li>
<li>范围扫描和匹配</li>
</ul>
<p>对了还有一个忘了就是数据库的备份和还原，这个也蛮重要的，在梳理好了这些大体的功能以后就可以开始着手去设计一些细节了。</p>
<h2> 存储</h2>
<p>首先就是如何在磁盘上存放数据，既然采用了Bitcask作为存储模型，那么最简单直接的方法就是一条一条record存，一条一条record读，这样做最简单，也最容易实现。但是！非常重要的一点就是，前面已经提到过Bitcask不适合存大块数据，在几MB以上数据就可以被称为大块数据了，Bitcask原有的Record是由几个部分组成</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312022243634.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>header部分主要是record的元数据，包括crc，时间戳，key的长度，value的长度，读取一条record，需要两次IO，第一次读header，确认数据的长度，第二次确认数据长度过后才能去读取数据。实际上存放的数据都不是特别大，平均可能只有KB级别，甚至不到KB，对于这样小的数据，读取一条record还要进行两次IO，十分的浪费性能。</p>
<p>那么可以这样考虑，一次读取固定大小的文件内容到内存中，称之为Block，然后在内存中从Block读取数据，如果数据的足够小，刚好能在Block中，那么查询就只需要一次IO，后续虽然也是要先读数据长度再读实际数据，但由于是在内存中读取，要比磁盘读取快得多，这种能被Block容纳的数据称之为Chunk。而这个规则也就是应用在LevelDB的Wal文件中，而LevelDB默认的BlockSize就是32KB，每一次IO固定读32KB，这个值太大了会耗费内存，太小了会频繁IO，具体可以去这个文章<a href="/post/db/wal_in_leveldb.html" target="blank">Wal-LevelDB中的预写日志</a>了解。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312031426113.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一个chunk由header和data组成，header最大为7个字节，所以data数据长度范围在[0, 32KB-7B]，这里将crc校验从record抽离出来，放到了chunk中，这样在读写数据的时候就不需要再去做额外的校验。所以数据库实际操作的record是存放在data这部分中，对于一条记录而言，它的头部由以下几个部分组成</p>
<ul>
<li>type，标识操作类型，更新还是删除</li>
<li>ttl，过期时间，存放的是毫秒，10个字节是64位整数占用的最大字节数</li>
<li>txn_id，事务ID</li>
<li>key_sz，key的长度，5个字节是32位整数所需要的最大字节数</li>
<li>val_sz，数据的长度</li>
</ul>
<p>数据的组织格式大体上就设计完毕了，数据在文件中的分布大概可能是下图的样子</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312031438746.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>除此之外，我还在内存中做了一个缓存，由于每次读取的都是一个32KB的Block，那么可以将频繁使用的Block缓存起来从而减少了IO次数。思考这么一种情况，如果一个Block中的所有Chunk都远小于Block，那么只有读第一个Chunk的时候，会进行文件IO，在第一个chunk读取完毕后，会将这个Block缓存起来，这样一来，后续的Chunk就不再需要从文件中读取，直接从内存里面读取即可，这样就大大提高读取的速度。但一直缓存也不是办法，内存也是有限的，也还要做索引，所以需要定期进行淘汰，这里可以用LRU缓存来实现。</p>
<p>使用了上述的数据组织形式，可以一定程度上优化读的性能，不过写性能也不能忽略。Bitcask本身采用的是append-only的写入方式，顺序写的性能自然是要比随机写要好很多的，不过问题在于这样会包含很多冗余的数据。写性能的瓶颈在与Fsync的时机，如果每一次写入都sync，数据的持久性可以得到很好的保证，但性能会很低，如果不sync，性能肯定是比前者要高很多的，但持久性难以得到保证，正所谓鱼和熊掌不可得兼，还得是在两者之间找一个平衡点。</p>
<h2> 索引</h2>
<p>对于索引的选择，比较主流的选择有BTree，SkipList，B+Tree，RedBlackTree，这几个都有一个共同点就是它们都是有序的，当然还有一个无序的数据结构哈希表，这个直接排除了，使用哈希表做索引没法做范围扫描。Redis和LevelDB首选的是SkipList，基于有序链表的SkipList的写性能会优秀一些，查询性能相对较弱，而树这一类的数据结构查询性能优秀，写入性能相对而言弱一些。</p>
<p>考虑到Bitcask存储模型并不适合存储大量数据，也不适合存储大块数据，在综合考虑下，选择了各方面比较平衡的BTree作为首选的内存索引，BTree又叫做多路平衡查找树，不选SkipList是因为没有找到很好的开源实现，B+Tree更适合做磁盘索引，而Btree有谷歌开源的库，并且另一大优点就是这个库很多人使用且支持泛型。不过其实索引并不只限于BTree，索引这一层做了一层抽象，后续也可以用其它数据结构实现。</p>
<p>是否要自己手写？说实话这个数据库我还是想用一用的，BTree，B+Tree都是非常复杂的数据结构，自己写是能写但不一定能保证能用，有了稳定成熟的开源实现可以使用是最好的。我自己也有写另一个数据结构的库，并且全都支持泛型，</p>
<p>开源仓库：<a href="https://github.com/246859/containers" target="_blank" rel="noopener noreferrer">246859/containers: base data structure and algorithm implemention in go genericity (github.com)</a></p>
<p>不过还在逐步完善，等以后稳定了说不定可以使用。</p>
<p>那么，内存索引存什么东西呢？这个问题还是比较好回答的，考虑到存储中采用的是Wal的组织形式，索引中存储的信息应该有</p>
<ul>
<li>哪个文件</li>
<li>哪个block</li>
<li>chunk相对于block的offses</li>
</ul>
<p>用go语言描述的话就是一个结构体</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每一个block固定为32KB，所以只需要知道<code>Fid</code>，<code>BlockId</code>，<code>Offset</code>这三个信息就可以定位一条数据。除此之外，还可以把数据的TTL信息也放到索引中存储，这样访问TTL就不需要文件IO了。</p>
<h2> 事务</h2>
<p>如果要我说整个数据库哪一个部分最难，恐怕只有事务了，支持事务要满足四个特性，ACID，原子性(Atmoicty)，一致性(Consistency)，隔离性(Isolation)，Durability(持久性)。其中最难实现的当属隔离性，隔离性又分为四个级别，读未提交，读提交，可重复读，串行化。</p>
<p>在写事务这块之前，参考了下面几个项目</p>
<ul>
<li>
<p>RoseDB</p>
<p>它的v2版本对于事务的实现只有一个读写锁，保证了串行化事务。</p>
</li>
<li>
<p>NutsDB</p>
<p>跟上面的一样，也是用一个读写锁来实现串行化事务，可以并发读，但是不能并发写，并且写会阻塞读写事务。</p>
</li>
<li>
<p>Badger</p>
<p>badger与上面的两个项目不同（吐槽一下badger源代码可读性有点差），它是基于LSM而非Bitcask，并且提供了完整的MVCC事务支持，可以并发的进行读写事务，失败就会回滚。</p>
</li>
</ul>
<p>前两个数据库不支持MVCC的理由非常简单，因为Bitcask本身就使用内存来做索引，如果实现MVCC事务的话，就需要在内存中存放许多版本的索引，但是内存空间不像磁盘，磁盘空间多用一点没什么，所以Bitcask的存储方式会产生冗余数据是可以容忍的，但内存空间是非常宝贵的，采用MVCC事务的话会导致有效索引的可用空间受到非常大的影响。</p>
<p>大致的思路如下，在开启一个事务时不需要持有锁，只有在提交和回滚的时候才需要。在一个事务中所有的修改加上事务ID后都将立即写入到数据文件中，但是不会更新到数据库索引中，而是去更新事务中的临时索引，每一个事务之间的临时索引是相互独立的，无法访问，所以事务中更新的数据对外部是不可见的。在提交时，首先检测是否发生了事务冲突，冲突检测思路如下。</p>
<ol>
<li>
<p>遍历所有已提交的事务</p>
</li>
<li>
<p>检测其提交时间是否晚于本次事务的开始时间</p>
</li>
<li>
<p>如果是的话，再遍历该事务的写集合，如果与本次事务的读集合有交集，说明本次事务中读过的数据在事务执行过程中可能被修改了，于是判定为发生冲突。</p>
</li>
<li>
<p>提交成功的话就加入已提交事务列表中</p>
</li>
<li>
<p>将事务中的临时索引更新到数据库索引中，现在数据对外部可见了</p>
</li>
<li>
<p>插入一条特殊的记录，附带上当前事务的事务ID，表示此次事务已提交</p>
</li>
<li>
<p>如果失败回滚的话，也插入一条特殊的记录，表示此次事务已回滚</p>
</li>
</ol>
<p>数据库在启动时，会按顺序遍历每一个数据文件中的每一条数据，每一个数据都携带对应的事务ID，首先会收集对应事务ID的事务序列，如果读到了对应事务ID的提交记录，就会将该事务的数据更新到内存索引中，如果读到了回滚的记录就会直接抛弃。如果一个事务序列，既没有提交也没有回滚，这种情况可能发生在突然崩溃的时候，对应这种数据则直接忽略。</p>
<p>这样一来，事务的ACID都可以满足了</p>
<ul>
<li>原子性和一致性，只有提交成功的数据才会出现在索引中，回滚和崩溃的情况都会直接抛弃，所以只有成功和失败两种结果，即便出现突然断电崩溃，也不会出现第三种状态。</li>
<li>持久性：一旦事务提交成功，也就是标记事务提交的特殊记录写入到数据库中，那么这些数据在数据库中就永远生效了，不管后面突然断电还是崩溃，在数据库启动时这些事务数据一定会成功加载到索引中。</li>
<li>隔离性：事务与事务之间的修改是彼此都不可见的，只有提交后更新到索引中，所做的修改才能被其它事务看见。</li>
</ul>
<p>在运送时，可以用最小堆来维护当前的活跃事务，在每一次提交后就会清理已提交事务列表，如果提交时间小于堆顶的事务开始时间，说明该事务不可能会与活跃的事务发生冲突，就可以将其从已提交事务列表中删除，避免该列表无限膨胀。</p>
<p>但是！凡是都要有个但是，上面这种方法的隔离级别只能够保证读提交，无法保证可重复读，如果读过的数据在事务执行过程中被修改了，就会发生冲突，这种情况要么回滚要么重试。当然，riverdb也提供了另一个隔离级别，串行化，就跟RoseDB和NutsDB一样，使用读写锁来保证事务之间按照顺序执行，这样做的好处就是几乎很难发生冲突，坏处某一时刻就是只有一个协程能写入数据。</p>
<p>高性能往往意味着的可靠性低，高可靠性也代表着性能会拖后腿，事务就是可靠性和性能之间的权衡，至于选择什么隔离级别，这个可以做成可配置化的，让使用者自己选择。</p>
<h2> 合并</h2>
<p>在存储那一块提到了增量写导致的问题，由于不管是增删改，都会插入一条新的数据，随着时间的流逝冗余的数据越来越多，肯定需要去清理的，不然会占用大量的空间。对数据库中无用的数据进行清理，这一过程称为合并。在合并清理数据的时候，有几个问题需要思考</p>
<ul>
<li>清理哪些数据</li>
<li>在什么时候清理</li>
<li>如何清理</li>
</ul>
<p>清理哪些数据？梳理了一下应该有下面这些数据</p>
<ul>
<li>过期的数据，已经过期的数据是没有必要再存在的</li>
<li>被覆盖的数据，有效的数据始终只有一条，被覆盖后没有存在的必要</li>
<li>被删除的数据，删除后也不需要了</li>
<li>回滚的事务数据</li>
<li>无效的事务数据，也就是写入数据，但是即没提交也没回滚</li>
</ul>
<p>对于事务数据，成功提交后的事务数据在清理时可以将其事务ID清空，在数据库启动时读取数据时，读到合并后的数据可以直接更新到索引中，而不需要收集整个事务序列来判断是否提交成功。</p>
<p>在什么时候清理？肯定是不能直接在原数据文件上动手，否则的话会阻塞其它正在进行的读写操作，一个Bitcask实例本身就是一个文件夹，数据库本身就是一个Bitcask示例，为了不阻塞读写，可以在清理合并数据的再新建一个Bitcask实例，将清理后的数据写入到新的实例中，然后再将数据覆盖到数据库实例中，这样的好处就是只有在进行覆盖操作的时候才会阻塞读写操作，其它时候不影响。</p>
<p>如何清理？在清理开始之前可以让bitcask实例新建一个active-file，将当前文件归入immutable-file，这样一来，在清理过程中新的写入就会写入到新的active-file中，而清理操作则是针对旧的immutable-file，记录下旧的active-file的文件id，然后逐个遍历immutable-file，如果数据被删除了，索引中自然不会存在，数据是否过期需要在遍历时判断一下，另一个需要注意的一点是还要检查一下索引信息中的文件id是否大于记录的文件id，是的话说明是新的写入操作则忽略掉这个索引项。在遍历索引时，还可以做一件额外的事，那就是构建hint文件，将新的索引信息写入hint文件中，这样一来，在数据库启动期间构建索引时，对于清理后的这部分数据可以不用去遍历每一条数据，而且可以从hint文件中读取，对于未清理的数据仍然需要去遍历其真实数据，这样做可以加快内存的构建速度。对于hint文件，它就等于存放在磁盘中的索引，其中的每一条记录都只存放索引信息，不包含实际数据，它只用于构建索引，而不会用于数据查询，目的只是为了加快索引的构建速度。</p>
<p>当数据清理完毕后，根据先前记录的文件ID覆盖掉原先的immutable-files，然后在重新加载索引，这样一来合并过程就完成了。还剩下最后一个问题，合并操作该在什么时候进行？有两个方案，第一个是定时合并，另一个是触发点。定时合并就比较简单了，就只是定时操作。触发点则是让数据库在写入时记录数据条数，当现有的数据条数与索引中的条数达到一定比例时就会触发合并。触发点合并就需要考究了，如果数据库中的数据量本身就很小，比如只有100条，但这100条都是针对一个key的改写，那么比例就达到了100：1，可能会触发合并，但实际上根本就没有必要。那么该如何去判断是否达到了触发点呢，这个可以用事件监听来实现，监听数据库的写入行为，如果达到了阈值，就可以进行合并，而且这一过程是异步的。</p>
<p>考虑一个情况，一个事务已经向数据库中写入了一些数据，但是没有提交，而恰好这时候又触发合并了，合并时会新建一个数据文件，于是该事务的后半段数据就写入了新文件中，并成功提交。合并时，之前的文件会被归档然后清理掉其中的无用数据。但是，这个事务的前半段数据在合并时是扫描不到提交记录的，那么它就会被清理掉，这样一来只有事务的后半段数据持久化了。这个过程就是一个<strong>事务被截断</strong>了。如何避免这种情况，最简单的方法是用一个互斥锁让事务与合并互斥，这样做的代价很明显，会导致合并操作阻塞其它事务的读写行为，如果数据量多了的话合并操作是非常耗时的。我的解决方案是合并操作之前必须要等待当前所有的活跃事务执行完毕，同时阻塞新事务的开启，然后再去创建新的数据文件，文件创建完成后让阻塞的事务恢复运行。这样做虽然同样会阻塞事务，但它等待的时间是活跃事务的执行时间+创建新数据文件的时间，真正的合并操作依旧是异步的，而使用互斥锁的等待时间是一整个合并操作的时间。</p>
<p>其实还有一种解决方案，如下图</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312051932268.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>它采用的方案是把读和写的文件分开了，其实这就是我早期的设想。事务的修改首先被写入到wlog中，这时内存索引存储的是wlog中的位置索引，然后到了一定触发点将日志中的数据compact到data中，再更新内存索引为data中的位置索引，data是只读的，除了merge操作外不做任何修改。这样做其实依旧会发生上述提交的事务截断的情况，但compact阻塞的成本要比merge低很多，是可以接受的。因为每一次compact过后wlog的数据都会被清空，compact不会遍历所有数据，而merge总是会遍历整个data files，compact和merge操作也并不互斥，可以同时进行。这个方案最终没有被采纳，一是因为当我发现这个bug的时候已经写的差不多了，要改动的话会动非常多的东西，二是它还是会出现事务截断的情况，并且在compact的时候依旧需要阻塞事务，还会让整个过程变得更复杂。</p>
<p>下图是实际上应用的方案</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312051952097.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看得出来其实是把事务日志和数据文件合成一个了，因为bitcask数据文件的性质本身就跟事务日志一模一样。</p>
<h2> 备份</h2>
<p>备份的实现思路就非常简单了，Bitcask实例就是一个文件夹，直接把当前文件夹打包成一个压缩包，就完成了备份，日后如果要恢复到备份状态的话，就直接解压缩到数据目录就好了。解压缩是用tar gzip来实现，它的兼容性会更好些。</p>
<h2> 监听</h2>
<p>数据库总共有几种事件</p>
<ul>
<li>更新事件</li>
<li>删除事件</li>
<li>回滚事件</li>
<li>备份事件</li>
<li>还原事件</li>
<li>合并事件</li>
</ul>
<p>可以用一个队列来存放这些事件，上述操作成功后，会向队列中发送消息，队列会将这些消息转发给用户已创建的监听器，监听器的本质就是一个带缓冲的通道，所以这就是一个极简的消息队列的实现。用户在创建监听器时可以指定监听哪些消息，如果不是想要的消息就不会发送给该监听器，并且用户创建的监听器被维护在数据库中的监听器列表中，当消息队列有新的消息时，会遍历整个列表逐个发送消息，对于用户而言，只对其暴露一个只读的通道用于接收事件。其实这就是一个极简版的消息队列实现。</p>
<h2> 总结</h2>
<p>这个简单的数据库花了我大概一个月的时间，从11月10日到12月2日结束，在过程中Wal的实现以及事务的支持卡了我最久，最后终于实现了预期的所有功能，但距离使用仍然需要不断的测试和完善。</p>
<p>仓库地址：<a href="https://github.com/246859/river" target="_blank" rel="noopener noreferrer">246859/river: light-weight kv database base on bitcask and wal (github.com)</a></p>
<p>在这个过程中学习到了非常多的东西，最重要的就是存储模型Bitcask的实现，Wal的实现，事务的实现，这三个就是riverdb的核心点，总结下来就是</p>
<ul>
<li>磁盘存储，磁盘存储的关键点在于数据的组织形式，以及Fsync调用时机，是性能与持久性之间的权衡</li>
<li>内存索引，而索引的关键点在于怎么去选择优化更好的数据结构，提供更好的性能，占用更少的内存。</li>
<li>事务管理，事务的关键点在于隔离性，是事务可靠性与事务并发量之间的权衡</li>
</ul>
<p>至于其它的功能也就是在它们的基础之上衍生出来，只要这三个核心处理好了，其它的问题也就不算特别难处理。目前它还只是一个嵌入式的数据库，没有提供网络服务，要想使用只能通过导入代码的方式。riverdb现在等于只是一个数据库内核，只要内核完善了，在它的基础之上开发新的命令行工具或者是网络服务应该还算是比较简单的。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312031440217.png" type="image/png"/>
    </item>
    <item>
      <title>WAL——预写日志</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/db/wal_in_leveldb.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/db/wal_in_leveldb.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">WAL——预写日志</source>
      <description>WAL——预写日志</description>
      <category>db</category>
      <pubDate>Fri, 17 Nov 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> WAL——预写日志</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311292055936.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>WAL全名叫Write Ahead Logging，译为预写日志，常用在数据库系统中，用来保证ACID事务中的原子性和持久性。WAL的写入方式通常是<code>append only</code>，每一次写入都是在向其中添加数据，而非<code>in place</code>原地修改，那么这样做的好处非常明显，由于是顺序IO，写入性能会比随机IO好很多。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311292055936.png" type="image/png"/>
    </item>
    <item>
      <title>基本介绍</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/docker/0.dcoker.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/docker/0.dcoker.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">基本介绍</source>
      <description>基本介绍 docker是一款非常出名的项目，它是由go语言编写且完全开源。docker去掉了传统开发过程中的繁琐配置这一步，让开发者可以更加快速的构建应用。到目前为止，docker提供了桌面端，CLI命令行，SDK，以及WebApi几种方式以供开发者选用。</description>
      <category>docker</category>
      <pubDate>Fri, 07 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 基本介绍</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307152047981.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>docker是一款非常出名的项目，它是由go语言编写且完全开源。docker去掉了传统开发过程中的繁琐配置这一步，让开发者可以更加快速的构建应用。到目前为止，docker提供了桌面端，CLI命令行，SDK，以及WebApi几种方式以供开发者选用。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>这部分文章主要关注点在CLI命令行，其他几种方式请自行了解。</p>
</div>
<p>其实自己很早就用过docker，但是没有进行过一个系统的归纳，写下这些内容也是对自己的学习进行一个总结。Docker这块主要分为两大部分，前半部分主要讲怎么使用docker，后半部分会讲docker的一些原理（如果还有时间的话），先学会用再去深究这是我一直以来的理念。</p>
<h2> 一些链接</h2>
<h3> 官网</h3>
<p>官网：<a href="https://www.docker.com/" target="_blank" rel="noopener noreferrer">Docker: Accelerated, Containerized Application Development</a></p>
<p>docker官网，这里什么信息都有。</p>
<h3> 仓库</h3>
<p>开源仓库：<a href="https://github.com/moby/moby" target="_blank" rel="noopener noreferrer">moby/moby: Moby Project - a collaborative project for the container ecosystem to assemble container-based systems (github.com)</a></p>
<p>docker使用过程中，如果遇到问题，直接来仓库提issue是最有效的方法（能搜就别问了），如果有能力提pr就更好了。</p>
<h3> 文档</h3>
<p>文档地址：<a href="https://docs.docker.com/" target="_blank" rel="noopener noreferrer">Docker Docs: How to build, share, and run applications | Docker Documentation</a></p>
<p>docker的官方文档，使用指南，使用手册，API文档，详细到每一个命令的作用都有解释，也会教你怎么开始使用docker，怎么安装怎么卸载，不过是全英文。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307152047981.png" type="image/png"/>
    </item>
    <item>
      <title>安装使用</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/docker/1.start.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/docker/1.start.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">安装使用</source>
      <description>安装使用 第一次使用电脑时，都会先学习怎么开机和关机，使用软件也一样，得先学会怎么安装和卸载，以免觉得不好用了也可以卸掉。 本篇的内容参考自Install Docker Engine on Ubuntu | Docker Documentation 提示 后续的文章都将在ubuntu22.04LTS系统基础之上进行描述。</description>
      <category>docker</category>
      <pubDate>Sun, 09 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 安装使用</h1>
<p>第一次使用电脑时，都会先学习怎么开机和关机，使用软件也一样，得先学会怎么安装和卸载，以免觉得不好用了也可以卸掉。</p>
<p>本篇的内容参考自<a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener noreferrer">Install Docker Engine on Ubuntu | Docker Documentation</a></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>后续的文章都将在ubuntu22.04LTS系统基础之上进行描述。</p>
</div>
<h2> 安装</h2>
<h3> 设置仓库</h3>
<p>1.更新apt索引，安装一些依赖</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2.添加docker官方的GPG密钥</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.设置仓库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 安装docker engine</h3>
<p>1.先更新索引</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2.安装最新版本</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3.安装指定版本</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.执行<code>docker info</code>看看是否docker service是否都正常运行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>5.运行<code>hello-world</code>镜像看看能不能正常工作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 卸载</h2>
<p>相比于安装，卸载就要简单多了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再删除数据文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 关闭</h2>
<p>要想完全关闭docker，需要将<code>docker.socket</code>和<code>docker</code>两个服务都关掉。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 开启</h2>
<p>开启同理</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>简介</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/git/0.introduction.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/git/0.introduction.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">简介</source>
      <description>简介 代码管理对于软件开发而言永远是一个绕不过去的坎。笔者初学编程时对软件的版本没有任何概念，出了问题就改一改，把现在的代码复制保存一份留着以后用，这种方式无疑是是非常混乱的，这也是为什么VCS（Version Control System）会诞生的原因。这类软件的发展史还是蛮长的，笔者曾经短暂的在一个临时参与的项目中使用过SVN，现在应该不太常见了，几乎大部分项目都是在用git进行项目管理。大多数情况下，笔者都只是在拉代码和推代码，其他的命令几乎很少用到，不过这也侧面印证了git的稳定性。写下这些内容是为了对自己git相关知识的进行一个总结，更加熟悉之后，处理一些疑难杂症时会更加得心应手。</description>
      <category>git</category>
      <pubDate>Wed, 23 Nov 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 简介</h1>
<figure><img src="https://gitforwindows.org/img/git_logo.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>代码管理对于软件开发而言永远是一个绕不过去的坎。笔者初学编程时对软件的版本没有任何概念，出了问题就改一改，把现在的代码复制保存一份留着以后用，这种方式无疑是是非常混乱的，这也是为什么VCS（Version Control System）会诞生的原因。这类软件的发展史还是蛮长的，笔者曾经短暂的在一个临时参与的项目中使用过SVN，现在应该不太常见了，几乎大部分项目都是在用git进行项目管理。大多数情况下，笔者都只是在拉代码和推代码，其他的命令几乎很少用到，不过这也侧面印证了git的稳定性。写下这些内容是为了对自己git相关知识的进行一个总结，更加熟悉之后，处理一些疑难杂症时会更加得心应手。</p>
<p>开源地址（镜像）：<a href="https://github.com/git/git" target="_blank" rel="noopener noreferrer">git/git: Git Source Code Mirror</a></p>
<p>官方网站：<a href="https://git-scm.com/" target="_blank" rel="noopener noreferrer">Git (git-scm.com)</a></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>本章内容大量参考<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener noreferrer">GitBook</a>，该书有着良好的中文支持，十分建议阅读。</p>
</div>
<h2> 安装</h2>
<p>git本身是为linux设计的，不过也有windows版本的。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309021510253.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>前往官网下载对应平台的发行版，笔者所使用的是windows版本，下载完成后执行命令查看git是否可用</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于linux而言，可以使用apt来安装</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 更新</h3>
<p>更新git的方法相当简单</p>
<ol>
<li>第一种是直接下载新的文件覆盖旧文件</li>
<li>第二种是执行<code>git update-git-for-windows </code>命令进行更新。</li>
<li>对于linux而言使用自己对应软件包管理工具的更新方法</li>
</ol>
<h2> 帮助</h2>
<p>寻求git帮助的方式有很多种</p>
<ol>
<li>在官网查阅命令文档</li>
<li>执行<code>git help verbs</code>获取详细帮助</li>
<li>执行<code>git verbs -h</code>来获取简短的描述</li>
</ol>
<p>善用这些方法和渠道，因为很多时候出了问题并不会有人来帮你解决，自己多去看看文档说不定会发现问题所在。</p>
<h2> 配置</h2>
<p>通过<code>git config</code>命令可以查看git配置，比如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来说，刚安装后，你需要配置你的名称和邮箱，因为这个信息会在你日后对每一个git仓库的每一次提交出现，比如当你和其他人合作开发项目时，突然看到一段很烂的代码，通过这个信息就可以很快的知晓到底是哪个大聪明写的代码。通过<code>--global</code>参数进行全局设置，同样的也可以使用<code>--local</code>来进行局部设置，全局设置会作用到所有的仓库，而局部设置只会覆盖当前的仓库。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过添加<code>--show-origin</code>参数可以很清晰的看到每一个配置的来源。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 注意</h2>
<p>最后说一句，后续的git学习只会使用命令行工具，因为只有命令行才能体验到git的完整功能。掌握了命令行以后，再去使用其他GUI工具就轻而易举了。在windows平台，如果安装成功了的话，是可以直接在cmd和powershell里面使用git命令的，当然也可以使用<code>git bash</code>，这是git自带的命令工具，你可以在鼠标右键菜单中找到它。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309040931066.png" style="zoom:50%;">
<p>使用<code>git bash</code>的好处是可以兼容一些基础的linux命令。git有着很多的内置命令，没必要去死记硬背，忘了也很正常，我写这些文章的目的就是为了未来有一天忘了的时候可以回顾这些内容，所以放平心态。</p>
]]></content:encoded>
      <enclosure url="https://gitforwindows.org/img/git_logo.png" type="image/png"/>
    </item>
    <item>
      <title>仓库</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/git/1.repo.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/git/1.repo.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">仓库</source>
      <description>仓库 本文将讲解git一些基础操作，所有内容都是围绕着本地仓库进行讲解的，比如提交修改，撤销修改，查看仓库状态，查看历史提交等基本操作，学习完这些操作，基本上就可以上手使用git了。 创建仓库 git的所有操作都是围绕着git仓库进行的，一个仓库就是一个文件夹，它可以包含一个项目代码，也可以包含很多个项目代码，或者其他奇奇怪怪的东西，到底要如何使用取决于你自己。创建仓库首先要创建一个文件夹，执行命令创建一个example文件夹。 $ mkdir example</description>
      <category>git</category>
      <pubDate>Sat, 26 Nov 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 仓库</h1>
<p>本文将讲解git一些基础操作，所有内容都是围绕着本地仓库进行讲解的，比如提交修改，撤销修改，查看仓库状态，查看历史提交等基本操作，学习完这些操作，基本上就可以上手使用git了。</p>
<h2> 创建仓库</h2>
<p>git的所有操作都是围绕着git仓库进行的，一个仓库就是一个文件夹，它可以包含一个项目代码，也可以包含很多个项目代码，或者其他奇奇怪怪的东西，到底要如何使用取决于你自己。创建仓库首先要创建一个文件夹，执行命令创建一个<code>example</code>文件夹。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入该文件夹，执行git初始化命令<code>git init</code>，就可以为当前文件夹创建一个git仓库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>命令初始化完毕后，当前文件夹下就会多出一个名为<code>.git</code>的文件夹，里面存放着当前仓库所有的信息。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>到此就创建好了一个基本的git仓库。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309022007232.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>介绍一些基本的概念，首先要明白的是，在已创建的<code>example</code>目录内，除了<code>.git</code>文件夹，其他的所有文件或文件夹都属于工作区（图中黄色部分），日后所有对文件的修改，新增，删除的操作都是在工作区进行。操作过后，我们必须要手动指定git追踪哪些文件，这样git才能将指定文件纳入版本控制当中，这一步就是追踪文件，将其添加到暂存区（图中蓝色部分），然后就将这些修改提交到仓库（图中的紫色部分）后，才算是真正的由git仓库记录了这一次修改。除此之外，还有一个将本地仓库的修改推送到远程仓库的步骤，不过这是可选的。</p>
<h2> 暂存修改</h2>
<p>当前仓库什么都没有，所以接下来要创建几个文件来进行管理。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的命令中，创建了一个<code>hello.txt</code>文本文件，还有一个名为<code>README.md</code>的markdown文件。名为<code>README</code>的文件往往具有特殊意义，它的名字就是read me，即阅读我，该文件通常作为一个项目的介绍文件，里面包含了一个项目的基本信息和作者想要展示给其他人看的介绍信息。通常来说，它并不限制格式，示例中使用的是<code>md</code>格式，只是因为方便书写，它也可以是<code>README.txt</code>，<code>README.pdf</code>，<code>README.doc</code>，它可以是任何一切人类可以阅读的文本格式，这只是一种约定俗成的规范，而非强制要求，如果你乐意，也可以不创建<code>README</code>文件。</p>
<p>这时候再执行<code>git status</code>命令查看仓库目前的状态，git会告诉你，这两个文件没有被追踪（untracked），如果你想要管理这两个文件，就需要显式的使用命令来进行追踪。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示中也告诉了你应该使用 <code>git add</code>命令来追踪这些文件，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>追踪文件后，再次执行<code>git status</code>命令，git就会告诉你这两个文件处于暂存状态（staged），即被添加到了暂存区</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在git仓库中，只有被追踪的文件才会纳入版本控制。在追踪了两个文件后，接下来修改<code>hello.txt</code>的文件内容</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再次执行<code>git status</code>命令，查看仓库状态，git会告诉你，发现之前追踪的<code>hello.txt</code>文件已经被修改了，且新的修改没有暂存。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时，暂存区的状态还停留在上一次<code>add</code>操作时，而工作区已经有了新的修改，所以要再次执行<code>git add</code>来更新暂存区。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 查看修改</h2>
<p>在对工作区文件做出修改过后，<code>git status</code>只能知晓文件的状态变化，而无法得知具体的变化细节。使用<code>git diff</code>命令可以解决此问题，不带任何参数执行该命令的话，它会展示工作区文件与暂存区文件的区别。比如先修改<code>hello.txt</code>，再执行<code>git diff</code>，输出如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>a</code>，<code>b</code>，分别指工作区和暂存区，<code>@@ -4,3 +4,4 @@</code>指的是变化位置，最后一行带有<code>+</code>号，表示这是新增的。加上<code>--staged</code>参数就会比较暂存区与上一次提交时的变化。接下来先添加到暂存区，然后再查看差异</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一次输出的就是最后一次提交的文件和暂存区的文件的差异。</p>
<h2> 忽略文件</h2>
<p>对于一些文件，我们并不希望将其纳入git版本控制当中，也不需要git去追踪它们的变化，比如编译好的二进制文件，程序生成的错误日志等，为此git提供了一个配置文件<code>.gitignore</code>，来告诉git要忽略哪些文件。下面看一个例子，这是文档站仓库的<code>.gitignore</code>文件：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>.idea/</code>是忽略IntellJ IDE自动生成的项目配置文件，<code>node_modules/</code>是忽略掉一系列本地依赖文件，其他的要么就是忽略缓存，要么就算忽略打包文件。可以使用<code>#</code>来进行注释，描述忽略文件的具体信息。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>#</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以以（<code>/</code>）开头防止递归。</li>
<li>匹配模式可以以（<code>/</code>）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（<code>!</code>）取反。</li>
</ul>
<p>glob模式指的是简化过后的正则表达式，熟悉正则表达式看这个应该相当容易，下面看一些例子</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基本上每一个语言都会有一套属于自己的<code>.gitignore</code>模板，比如说<code>c++</code>模板</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Github有专门收集这类模板的仓库，前往<a href="https://github.com/github/gitignore" target="_blank" rel="noopener noreferrer">github/gitignore: A collection of useful .gitignore templates</a>了解更多。</p>
<h2> 提交修改</h2>
<p>在将所有修改到添加到暂存区过后，就可以将暂存的文件提交到当前分支，使用<code>git commit</code>命令进行提交操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>git要求你在进行提交时，必须附带提交信息，使用<code>-m</code>参数来指定提交信息，如果参数为空字符串的话会中断操作，倘若不携带<code>-m</code>参数，会自动进入<code>vim</code>界面要求你必须输入提交信息，否则就无法提交到当前分支。提交成功后，git输出如下信息</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>master</code>，就是提交到的分支，<code>b3c2d7f</code>是git为本次提交生成的40位sha1校验和的一部分。</p>
<p>每当完成了一个阶段的小目标后，将变动的文件提交到仓库，git就会记录下这一次更新。只要提交到仓库里，日后就可以通过各种手段恢复，不用担心数据丢失的可能。</p>
<h3> 跳过暂存</h3>
<p>git提供了一个可以跳过暂存的方式，即在<code>git commit</code>命令后加上<code>-a</code>参数就可以将所有修改过的文件暂存并提交到当前分支。比如先修改了<code>hello.txt</code>文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再创建一个新文件<code>bye.txt</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此时执行<code>git status</code>，查看仓库状态</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>git commit -a</code>跳过暂存</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次执行<code>git status</code>会发现，<code>bye.txt</code>并没有被提交，也没有被暂存，所以跳过暂存的前提是文件首先需要被追踪，这样git才能感知到它的变化。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 历史提交</h3>
<p>在进行一段时间的工作后，你可能会想看看以前干了些什么，可以使用<code>git log</code>命令查看当前仓库的提交历史。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过输出，我们可以很轻易的得知每一个提交的日期时间，作者，提交描述信息，以及sha1校验和。通过添加<code>-p</code>参数可以得知每一次提交的修改</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当历史过多时可以指定显示多少条，来获得更好的查看效果</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者以图表的形式来展示提交历史，为了更有效果，拿文档站的提交历史作例子，可以看到多了一条线，这其实是其它分支合并的结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外，通过添加<code>--pretty</code>参数还可以美化<code>git log</code>的输出，比如每一个提交只显示一行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>甚至支持自定义格式化，比如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一些常用的格式化选项。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>%H</code></td>
<td style="text-align:left">提交的完整哈希值</td>
</tr>
<tr>
<td style="text-align:left"><code>%h</code></td>
<td style="text-align:left">提交的简写哈希值</td>
</tr>
<tr>
<td style="text-align:left"><code>%T</code></td>
<td style="text-align:left">树的完整哈希值</td>
</tr>
<tr>
<td style="text-align:left"><code>%t</code></td>
<td style="text-align:left">树的简写哈希值</td>
</tr>
<tr>
<td style="text-align:left"><code>%P</code></td>
<td style="text-align:left">父提交的完整哈希值</td>
</tr>
<tr>
<td style="text-align:left"><code>%p</code></td>
<td style="text-align:left">父提交的简写哈希值</td>
</tr>
<tr>
<td style="text-align:left"><code>%an</code></td>
<td style="text-align:left">作者名字</td>
</tr>
<tr>
<td style="text-align:left"><code>%ae</code></td>
<td style="text-align:left">作者的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:left"><code>%ad</code></td>
<td style="text-align:left">作者修订日期（可以用 --date=选项 来定制格式）</td>
</tr>
<tr>
<td style="text-align:left"><code>%ar</code></td>
<td style="text-align:left">作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td style="text-align:left"><code>%cn</code></td>
<td style="text-align:left">提交者的名字</td>
</tr>
<tr>
<td style="text-align:left"><code>%ce</code></td>
<td style="text-align:left">提交者的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:left"><code>%cd</code></td>
<td style="text-align:left">提交日期</td>
</tr>
<tr>
<td style="text-align:left"><code>%cr</code></td>
<td style="text-align:left">提交日期（距今多长时间）</td>
</tr>
<tr>
<td style="text-align:left"><code>%s</code></td>
<td style="text-align:left">提交说明</td>
</tr>
</tbody>
</table>
<p>还可以查看指定时间段的提交历史</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一些常用的输出限制参数</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-&lt;n&gt;</code></td>
<td style="text-align:left">仅显示最近的 n 条提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>-glob=&lt;pattern&gt;</code></td>
<td style="text-align:left">显示模式匹配的提交</td>
</tr>
<tr>
<td style="text-align:left"><code>-tags[=&lt;pattern&gt;]</code></td>
<td style="text-align:left">显示匹配tag的提交</td>
</tr>
<tr>
<td style="text-align:left"><code>-skip=&lt;n&gt;</code></td>
<td style="text-align:left">跳过n次提交</td>
</tr>
<tr>
<td style="text-align:left"><code>-merges</code></td>
<td style="text-align:left">仅显示合并提交</td>
</tr>
<tr>
<td style="text-align:left"><code>-no-merges</code></td>
<td style="text-align:left">不显示合并提交</td>
</tr>
<tr>
<td style="text-align:left"><code>--since</code>, <code>--after</code></td>
<td style="text-align:left">仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>--until</code>, <code>--before</code></td>
<td style="text-align:left">仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>--author</code></td>
<td style="text-align:left">仅显示作者匹配指定字符串的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>--committer</code></td>
<td style="text-align:left">仅显示提交者匹配指定字符串的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>--grep</code></td>
<td style="text-align:left">仅显示提交说明中包含指定字符串的提交。</td>
</tr>
<tr>
<td style="text-align:left"><code>-S</code></td>
<td style="text-align:left">仅显示添加或删除内容匹配指定字符串的提交。</td>
</tr>
</tbody>
</table>
<p>如果想要了解更多，可以使用<code>git help log</code>命令查看更多的细节。</p>
<h3> 检出提交</h3>
<p>在查看完历史提交后，你可以获取一个具体的提交的sha1校验和，通过它配合<code>git checkout</code>命令，可以将当前工作区的状态变为指定提交的状态。例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时工作区的文件内容已经变成了特定提交<code>9d3a0a371740bc2e53fb2ca8bb26c813016ab870</code>的状态，在与HEAD指针分离的情况下，所作的任何修改和提交都不会保存，除非新建一个分支。在已检出的情况下，使用如下命令来新建分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也可以在一开始就新建分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果想要回到HEAD指针，使命如下命令即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 删除文件</h2>
<p>如果想要删除仓库中的一个文件，仅仅只是删除工作区的文件是不够的，比如新建一个<code>bye.txt</code>，将其添加到工作区后，再将其从工作区删除，此时执行<code>git status</code>会有如下输出</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>git知晓此变化，但是删除文件这一修改并没有添加到暂存区，下一次提交时，该文件依旧会被提交到仓库中。所以应该同时将其暂存区的文件删除，为此git提供了<code>git rm</code>命令来删除暂存区的文件。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时会发现git不再追踪此文件。需要注意的是<code>git rm</code> 在执行时也会删除工作区的文件，倘若仅仅只是想删除暂存区或者仓库中的文件，可以使用如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如此一来，就不会对工作区的文件造成任何影响，将修改提交后，暂存区和仓库中的文件就会被删除，而工作区没有变化。</p>
<h2> 移动文件</h2>
<p>当想要移动文件或重命名文件时，可以使用<code>git mv</code>命令来进行操作。例如将<code>hello.txt</code>，改为<code>hello.md</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>git会感知到此变化，其实该操作等于执行了以下三个命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就算逐条执行这三条命令，git依旧会感知到这是一次renamed操作，更多时候还是使用<code>git mv</code>会方便些。</p>
<h2> 简短输出</h2>
<p>我们经常使用<code>git status</code>来查看本地仓库的状态，可以添加参数<code>-s</code>来获得更加简短的输出，git会以一种表格的方式来描述文件状态，例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述简短输出中，左边的状态表述栏有两列，第一列表示暂存区的状态，第二列表示工作区的状态，右边则是对应的文件。A表示新追踪的文件被添加到暂存区，M表示文件被修改，D表示文件被删除，R表示文件被重命名，??表示文件未追踪，下面看一些例子。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然除此之外可能还会有其他的组合，只需要知晓其意思即可。</p>
<h2> 撤销操作</h2>
<p>在使用git的过程中，经常可能会出现一些操作失误，想要反悔的情况，git当然也给了我们反悔的机会，从不至于将仓库弄的一团糟，下面会介绍几个情况。不过需要注意的是，有些撤销操作是不可逆的。</p>
<h3> 修正提交</h3>
<p>当你写完自己的代码后，信心满满的提交后，发现自己遗漏了几个文件，又或是提交信息中有错别字。发生这种情况时，只能是再提交一次，然后描述信息为：“遗漏了几个文件”或者是“修复了提交信息的错别字”，这样看着太别扭了，试想一下你的提交历史中都是这种东西，将会相当的丑陋。为此<code>git commit</code>命令提供了<code>--amend</code>参数，来允许你修正上一次提交。看下面的一个例子</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个例子</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>携带该参数后，git会将暂存区内的文件提交，如果说没有任何文件修改，git仅仅只会更新提交信息，修正后，提交历史中只会留下被修正的那个。</p>
<h3> 撤销提交</h3>
<p>当你发现提交错文件了，想要撤销提交，可以使用<code>git reset</code>，需要注意的是<code>git reset</code>命令使用不当是相当危险的，因为它会丢弃指定提交后的所有修改。对于撤销级别，有三个参数可以使用</p>
<ul>
<li><code>--soft</code>：仅撤销仓库中的内容，不影响暂存区和工作区，指定撤销节点的所有修改都会回到暂存区中。</li>
<li><code>--mixed</code>：默认，撤销仓库和暂存区中的修改，但是不影响工作区。</li>
<li><code>--hard</code>：使用该参数相当的危险，因为它同时会撤销工作区的代码，携带该参数执行后，会清空暂存区，并将工作区都恢复成指定撤销提交之前的状态。</li>
</ul>
<p>如果想要撤销多次提交，可以使用<code>git reset HEAD^n</code>，HEAD是一个指针，它永远指向当前分支的最新提交，<code>HEAD^n</code>即表示前n个提交。倘若想要撤销一个指定的提交，可以将该提交的sha1检验和作为参数使用来指定。比如下面这个命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>git reset --hard</code>可以达到将代码回退到某一个版本的效果，不过此前工作区中的所有改动都会消失。下面会将用几个例子做演示，首先对仓库进行一次新的提交</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面演示三个参数分别会造成什么影响，首先使用默认不带参数，可以看到此时回到了修改未暂存的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后使用<code>--soft</code>参数，再次查看仓库状态，可以看到回到了暂存区修改未提交的状态</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后使用<code>--hard</code>参数，此时查看仓库状态会发现什么都不会提示，因为该操作直接将工作区重置到了该次提交时的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的操作中，可以看到有些操作是无法恢复且相当危险的，使用<code>git reset</code>撤销的提交，在提交历史中会消失，如果想要找回可以使用命令<code>git reflog</code>，不过这是有时效性的，时间久了git会删除。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里我们可以看到被撤销的提交，以及其他被reflog记录的操作，想要恢复这些提交使用<code>git reset commit-id</code>即可。</p>
<p>使用<code>git reset</code>是比较危险的，为此，git提供了一种更加安全的撤销方式<code>git revert</code>。它会抵消掉上一次提交导致的所有变化，且不会改变提交历史，而且会产生一个新的提交。同样的，先做一个新提交，在使用<code>revert</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，在<code>revert</code>后，原本提交修改的内容消失了，提交历史中之前的提交仍然存在，并且还多了一个新提交。实际上git是将工作区和暂存区的内容恢复到了指定提交之前，并且自动add和commit，如果不想自动提交可以加上<code>-n</code>参数，此时查看仓库状态就会有提示</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>git已经提示了你使用<code>git revert --abort</code>来删除此次<code>revert</code>操作，或者<code>git revert --skip</code> 来忽略修改。如果想要<code>revert</code>多个提交，则必须依次指定。例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 撤销暂存</h3>
<p>取消暂存有两种情况，一种是将新文件移出暂存区，一种是撤销添加到暂存区的修改。在先前的例子中，将新文件添加到暂存区后，查看仓库状态时，git会这样输出</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中有这么一句：<code>(use "git rm --cached &lt;file&gt;..." to unstage)</code>，git已经告诉你了如何将这些文件取消暂存，对<code>hello.txt</code>执行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就可以将该文件移出暂存区。还有一种情况就是已经在暂存区的文件，将新的修改添加到暂存区过后，想要从暂存区撤回该修改，如下面的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时git已经提示了我们，使用<code>git restore --staged</code>来撤销暂存区的这一次修改。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>撤销后，会发现又回到了修改未被暂存的状态了，除了使用<code>git restore</code>之外，还可以使用 <code>git reset HEAD &lt;file&gt;</code>来撤销暂存区的修改，后者将暂存区指定文件的状态恢复成仓库分支中的状态。需要注意的是，这些命令都是对暂存区进行操作，不会影响到仓库和工作区。</p>
<h3> 撤销修改</h3>
<p>前面讲的都是对提交和暂存的撤销操作，当想要撤销工作区文件的修改时，将其还原成上一次提交或某一次提交的状态，在上面撤销暂存的例子中，git已经告诉我们了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有这么一句：<code>(use "git restore &lt;file&gt;..." to discard changes in working directory)</code>，告诉我们，使用<code>git restore &lt;file&gt;</code>来丢弃工作区指定文件的修改。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后会发现，文件回到了修改之前，git也不再提示文件有未暂存的修改 ，使用命令<code>git checkout -- hello.txt</code>具有同样的效果。需要注意的是，当你对工作区修改撤销后，是无法恢复的，你最好明白你在做什么。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>在git中，只要是提交到了仓库中的修改，绝大多数情况都是可以恢复的，甚至被删除的分支和使用<code>--amend</code>覆盖的提交也可以恢复。但是，任何未提交的修改，丢弃以后就可能再也找不到了。</p>
</div>
<h2> 标签操作</h2>
<p>在git中，你可以为某一个提交标注一个标签，表示这是一个阶段性变化，比如一个新的发行版，等等。通过命令<code>git tag -l</code>来查看一个仓库中的所有tag</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>同时它也支持模式匹配，比如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这行命令表示只查看主版本为1的tag。在git中，标签分为两种类型，轻量标签（lightweight）和附注标签（annotated），这两种类型还是有很大差别的，轻量标签只是一个特定提交的引用，而附注标签是存储在git中的一个完整对象，包含了许多有用的信息。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>人们对软件版本号的定义方式各有千秋，一个主流的方式是使用语义化版本号，前往<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener noreferrer">语义化版本 2.0.0 | Semantic Versioning (semver.org)</a>查看。</p>
</div>
<h3> 轻量标签</h3>
<p>创建轻量标签只需要提供标签名即可，如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在创建过后，使用<code>git show &lt;tagname&gt;</code>来查看该tag的信息</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到轻量标签显示的是commit的信息，之所以叫轻量是因为它仅仅是对提交的引用，当你仅仅只是临时需要一个tag，不想要其他的信息就可以使用轻量标签。</p>
<h3> 附注标签</h3>
<p>创建附注标签需要用到两个额外的参数，<code>-a</code>参数表示创建一个annotated tags，它接收一个tag名，<code>-m</code>参数表示对tag的描述信息。如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建后，对该tag执行<code>git show</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会发现除了展示commit的信息之外，还会展示标记标签的人，日期，信息等。</p>
<h3> 指定提交</h3>
<p><code>git tag</code>命令在创建标签时，默认是为HEAD指针，也就是最新的提交创建tag，当然也可以是一个特定的提交。只需要将该提交的sha1校验和作为参数即可。如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建完后，查看tag信息</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，就可以为一个指定的提交创建tag了。</p>
<h3> 删除标签</h3>
<p>在本地仓库删除一个tag，可以使用命令<code>git tag -d &lt;tagname&gt;</code>，比如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>删除后，再查看tag就会发现没有了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过需要注意的是，这仅仅只是在本地仓库删除标签，如果有远程仓库的话，需要单独删除，可以使用如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 推送标签</h3>
<p>当你的本地仓库关联了一个远程仓库后，如果你本地创建了tag，再将代码推送到远程仓库上，远程仓库是不会创建tag的。如果你想要推送某一个指定的标签可以使用如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想要推送所有标签，直接加上<code>--tags</code>参数即可。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，远程仓库上的tag就与本地仓库同步了。</p>
<h3> 检出标签</h3>
<p>使用命令<code>git checkout &lt;tagname&gt;</code>，就可以将工作区的内容变为该标签所提交时的状态，如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>git提醒你，现在处于与HEAD指针分离的状态，现在你做的任何的修改和提交都不会对仓库造成任何影响。如果你想要保存这些修改，可以创建一个新的分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者你也可以在一开始就创建一个新的分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>而后面如果你想要希望将这些修改同步到仓库中，这就涉及到后面分支这一文要讲的内容了。如果你想要回到头指针，执行如下命令即可。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 命令别名</h2>
<p>对于你经常使用的命令，如果觉得每次都要输入完整的命令而感到厌烦，命令别名可以帮到你。例子如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述命令分别为<code>commit</code>和<code>status</code>命令创建了别名，由于添加了<code>--global</code>参数，所以别名可以全局使用。执行别名试试</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有三个参数要提一下，分别是</p>
<ul>
<li><code>--add</code>，表示添加别名</li>
<li><code>--replace-all</code>，表示覆盖别名</li>
<li><code>--unset</code>，表示删除别名</li>
</ul>
<p>除此之外，也可以使用命令来清空所有别名</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令会直接将配置文件中的alias部分删掉。</p>
<h3> 配置文件</h3>
<p>除了使用命令之外，也可以使用配置文件，也就是<code>.gitconfig</code>文件，windows一般是<code>c:/$user/.gitconfig</code>，linux一般是<code>$HOME/.gitconfig</code>。打开配置文件就可以看到如下内容</p>
<div class="language-ini line-numbers-mode" data-ext="ini"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 外部命令</h3>
<p>除了给git自身的命令加别名外，也可以是外部命令，在添加外部命令时，需要在命令前加上<code>!</code>来表示这是外部命令。格式为</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如下面的命令，需要注意的是别名必须是单引号括起来。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行别名试试，就可以看到go的环境变量。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309022007232.png" type="image/png"/>
    </item>
    <item>
      <title>分支</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/git/2.branch.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/git/2.branch.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">分支</source>
      <description>分支 如果说有什么特性能让git从其它vcs中脱颖而出，那唯一的答案就是git的分支管理，因为它很快，快到分支切换无感，即便是一个非常大的仓库。一般仓库都会有一个主分支用于存放核心代码，当你想要做出一些修改时，不必修改主分支，可以新建一个新分支，在新分支中提交然后将修改合并到主分支，这样的工作流程在大型项目中尤其适用。在git中每一次提交都会包含一个指针，它指向的是该次提交的内容快照，同时也会指向上一次提交。</description>
      <category>git</category>
      <pubDate>Tue, 29 Nov 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 分支</h1>
<p>如果说有什么特性能让git从其它vcs中脱颖而出，那唯一的答案就是git的分支管理，因为它很快，快到分支切换无感，即便是一个非常大的仓库。一般仓库都会有一个主分支用于存放核心代码，当你想要做出一些修改时，不必修改主分支，可以新建一个新分支，在新分支中提交然后将修改合并到主分支，这样的工作流程在大型项目中尤其适用。在git中每一次提交都会包含一个指针，它指向的是该次提交的内容快照，同时也会指向上一次提交。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081917035.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>git的分支，实际上正是指向提交对象的可变指针，如图所示。通过如下命令可以看到分支所指向提交的情况</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 创建切换</h2>
<p>从图中和输出中我们可以看到，HEAD此时是指向main分支，于此同时，main分支与test分支都是指向的<code>f5602b9</code>这一提交，并且还有很多tag，除此之外，还可以看到<code>origin/main</code>这一远程分支。接下来创建一个新的分支试试，通过如下命令可以创建一个分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建完成后，使用<code>git checkout &lt;branchname&gt;</code>来切换到指定分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果想要创建的同时并切换切换成该分支可以使用<code>-b</code>参数，例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令<code>git checkout &lt;branchname&gt;</code>也可以切换分支，使用<code>git checkout -b &lt;branchname&gt;</code>也能达到创建并切换的效果，事实上<code>git switch</code>使用的还是<code>git checkout</code>。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p><code>git switch</code>命令相对<code>git checkout</code>命令比较新，同时也可能不那么稳定。</p>
</div>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081917091.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>分支切换后，HEAD指针就会指向test分支，HEAD指针永远指向当前所在的分支，通过它就可以知道现在仓库的状态处于哪一个分支。接下来做一个提交来看看。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081909312.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以从输出中看到，test分支此时指向的是<code>9105078</code>这个提交，而main分支依旧是指向的原来的那个提交。当分支切换回去时，会发现HEAD再次指向了main分支。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时再做出一些修改并提交，可以看到HEAD和main分支都指向了最新的提交。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来查看提交日志，git很形象的表示了所有分支的状态。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081910241.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>git的输出就如图所示，main与test两个分支最初都指向的同一个提交commit3，在随着有了新的提交后，它们都分别指向了各自不同的提交，当想要切换分支时，git就会将HEAD指针指向指定的分支，并将工作区恢复成该分支所指向提交的状态，在git中，分支的切换仅仅只是指针的移动，所以切换起来相当的迅速。正应如此，开发人员可以随心所欲的创建属于自己的分支来给仓库添加新的特性，这些变更在最后合并分支后都会出现在主分支中。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>刚刚提到的主分支，只是对开发人员的一个概念，git中没有什么特殊分支，起名为main仅仅只是将它看待成主分支，实际上它与test分支并没有什么不同，默认的master分支也只是git的一个默认名称而已。</p>
</div>
<p>在创建分支时，也可以不必从最新的提交创建，通过如下命令指定提交，就可以从指定的提交创建分支。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出中可以看到，jkl分支指向的是<code>a35c102</code>这一提交。</p>
<h2> 临时修改</h2>
<p>在分支切换时，git会将工作区切换到该分支所指向提交的状态，并且暂存区会被清空，这就意味着，如果在切换分支时有未提交的修改，那么这些修改将会丢失。不过git显然不允许这样的情况发生，它会这样提示你。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>如果你非要这么做，可以加上<code>--discard-changes</code>参数来丢弃修改或者<code>--merge</code>合并修改。</p>
</div>
<p>在进行危险操作时git总会提醒你不要这么做，从输出中可以得知，当本地有未提交的修改时，git不允许切换分支，要么把修改提交了，要么就使用一个名为<code>git stash</code>。它可以将本地未提交的修改临时保存起来，待将分支切换回来以后，还可以将这些修改复原，回到之前的状态，以便继续这个分支的开发工作。示例如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里先做了一些修改，将修改添加到了暂存区但未提交，只要是被追踪的文件发生变化，这里不添加到暂存区一样会被阻止，如果不添加到暂存区，git在stash时会自动添加将修改添加到暂存区。可以看到在切换分支时被git阻止了，于是使用<code>git stash</code>命令将这些修改临时存放后成功切换到了test分支。然后再切换回来，使用<code>git stash pop</code>来恢复最近一个临时保存的修改。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到仓库状态又变成了未暂存的修改，一旦临时修改被恢复过后，它就会被移出，正如pop所表达的含义一样。我们可以进行多次临时保存，并选择特定的修改来恢复。这里分别进行两次修改，然后临时保存两次。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过输出可以发现有两个临时保存的修改，存放的顺序就跟栈一样，后进先出，最上面的就是最新的修改。这时可以使用命令<code>git stash apply</code>来恢复指定的修改。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果恢复完成过后，想要删除的话，使用如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>git stash pop</code>就是将最近的一次修改恢复并删除。也可以使用<code>clear</code>命令来一次性删除所有的修改</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在上面的输出中可以看到，<code>stash</code>输出的修改列表除了索引不一样，其它都没什么区别，这样很难区分到底做了什么修改。为此，可以加上<code>-m</code>参数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出中可以看到，当<code>git stash</code>不带子命令直接执行时，其实就是执行的<code>git stash push</code>，加上<code>-m</code>参数以后，查看修改历史就可以看到我们自定义的信息了。</p>
<h2> 合并删除</h2>
<p>git支持多分支开发，也非常鼓励多分支开发。一般而言，一个项目会有一个主分支，也是就是main或master（只是一个名字而已，叫什么不重要），主分支的代码是最稳定的，通常软件发版就是在主分支发行。当你后期想要添加一个新特性，或者修复一个问题，你可以直接修改主分支代码，但这就破坏了主分支的稳定性，为此可以新建一个分支来做这类工作，新分支的代码可能不那么稳定，开发人员通常会在新分支上捣鼓各种奇奇怪怪的东西，等到稳定后就可以将修改合并到主分支上，又或者是放弃此前的工作，直接删除该分支。所以，在git中你可以随意的新建和删除分支并且不需要什么成本。</p>
<p>下面会做一些例子来进行演示，首先先看看仓库中有哪些分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，总共有三个分支，git用<code>*</code> 标注了当前所在的分支，为了方便演示先将<code>hello.txt</code>文件清空并提交。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>随后再新建一个feature分支并切换过去。这里之所以叫feature是表示新增特性，你也可以取其它名字，比如hotfix，即热修复，或者patch，表示补丁，这些名字并不是强制要求的，仅仅只是一个规范，你可以取你想要的任何名字。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到四个分支中，test与op分支指向的<code>0224b74</code>提交，而feature与main分支都指向的是最新的提交。接下来在feature分支做一些修改并提交。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309090937979.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到feature分支已经领先main两个提交了，前面提到过未提交的修改在切换分支后会丢失，这里将修改提交后切换分支就没什么问题了。这个时候想要合并分支的话，由于我们将main分支作为主分支，所以需要先切回到main分支，git会将当前所作的分支作为被并入的分支，然后再使用<code>git merge</code>命令合并。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>合并成功后，查看<code>hello.txt</code>文件就可以看到新的变化了。当一个分支成功合并以后，这个分支就没用了，所以可以将其删除。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>删除后再次查看分支列表，就会发现不存在了，此时main分支的代码就已经是最新的了。</p>
<h3> 恢复分支</h3>
<p>在进行日常操作时，总会不可避免将分支误删除，之前讲到过分支其实就是一个指向提交的指针，而删除分支只是删除这个指针，至于那些提交不会有任何变化，所以恢复的关键点在于找到提交。在先前的例子中，我们已经将feature分支删除了，为了恢复该分支，我们先看看git的引用日志。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键点在于这一条，这时我们在feature分支做的最后一个提交</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用该commitId创建一个新分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从输出中可以看到，在先前feature分支的提交都已经恢复了。</p>
<h3> 冲突解决</h3>
<p>上述过程就是一个多分支开发的例子，这个简单的案例中只涉及到了一个文件的变化，在使用的过程中很难会出什么问题。不过在实际项目中从主分支中创建一个新分支，主分支在合并前就可能有了很多的新的提交，这些提交可能是从其它分支中合并来的，新的提交可能会涉及到很多文件的新增，修改，删除，而新分支也是同样如此，这样一来在合并时就不可避免的会出现冲突，只有将冲突解决后，才能成功合并。如图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309090938745.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>为了演示冲突，先在从当前提交创建一个新分支，并做一些修改。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后切回main分支，再做一个修改并提交。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时查看提交历史，就跟上图描述的差不多</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在开始准备合并，git会提示你没法合并，因为有文件冲突，只有将冲突解决了才能合并。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时看看<code>hello.txt</code>文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会发现git已经给你标记好了哪些修改是main分支做的，哪些修改conflict分支做的，由于同时修改了同一个文件，所以产生了冲突。我们使用vim将文件修改成如下内容。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上只是去掉了git后面加的标记，因为这两个分支的修改我们都需要保留，只有将git冲突标记去掉后，git才会认为是真正解决了冲突，然后再将修改提交。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>main分支和conflict分支最初的父提交都是<code>0658483 </code>，而后两个分支分别做各自的修改，它们的最新提交分别是<code>fd66aec</code>和<code>2ae76e4</code>。这样一来，git在合并时就会比对这三个提交所对应的快照，进行一个三方合并。而在之前的feature分支中，由于main分支并未做出任何新的提交，所以合并后提交历史依旧是线性的，也就不需要三方合并。从提交历史中可以看到，此时两个分支的提交已经被合并了，而且还多了一个新的提交，这个提交被称为合并提交，它用来记录一次三方合并操作，这样一来合并操作就会被记录到提交历史中，合并后的仓库提交历史如图所示。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309091039034.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在提交历史中可以清晰的看到，这是一次合并提交</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Merge: fd66aec 2ae76e4</code>这一行描述了合并前两个分支所指向的最新的提交，通过这两个commitid，也可以很轻松的恢复原分支。</p>
<h2> 变基操作</h2>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309090938745.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在git中整合不同分支的方法除了合并<code>merge</code>之外，还有一个方法就是变基<code>rebase</code>。在之前的例子中，我们可以得知，合并操作会将对两个分支进行三方合并，最终结果是生成了一个新的提交，并且这个提交在历史中会被记录。而变基则相反，它不会生成一个新的提交，对于上图这种状态，它会将feature分支上所有的修改都移到main分支上，原本feature分支是从Commit2的基础之上新建来的，执行<code>rebase</code>操作后，feature分支中的Commit4将会指向Commit3，这一过程就被称作变基，就如下图所示。然后就只需要一个普通合并让main分支指向Commit5就完成操作了。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309091435384.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 双分支</h3>
<p>下面会例子来进行演示，首先在main分支对<code>README.md</code>文件做修改并提交。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在前一个提交的基础上新建一个名为<code>feature_v3</code>的分支，在该分支上对<code>hello.txt</code>进行修改并提交</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时仓库状态跟下面的输出一样，是分叉的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在feature_v3分支上对main分支执行变基操作，就会发现提交历史又变成线性的了，提交<code>63f5bc8</code>原本指向的父提交从<code>388811a</code>变成了main分支的 <code>0d096d1</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再切回main分支，对feature_v3进行合并。这种合并就不是三方合并了，只是让main分支指针移动到与feautre_v3分支所指向的同一个提交，所以也不会生成新的合并提交，这种合并被称为快进合并。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时仓库状态就类似下图。变基与三方合并结果并没有区别，只是变基操作不会被记录在提交历史中，且提交历史看起来是线性的，能够保持提交历史的简介。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309091457670.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 三分支</h3>
<p>似乎从目前看来，变基要比合并好用的多，不过事实并非如此。下面来演示三个分支变基的例子。先创建一个新分支叫v1，然后在main分支上做一些修改并提交，切换到v1分支上做一些修改并提交，在这个提交的基础上再建一个新分支v2，随后又在v2分支上做一些新提交，总共三个分支。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>经过一系列修改后，就有了三个分支，并且各自都有新提交，此时仓库提交历史如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似下图所描述的结构</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309091537147.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>假如我想要把v2分支的修改合并到main分支中，因为v2分支的修改已经工作完毕，可以考虑合并了，但v1分支中的修改还不稳定，需要继续完善，所以只想要应用v2的修改，但并不想应用v1的修改，这就需要用到<code>git rebase --onto</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过执行上述命令，git会将v2分支变基到main分支上，git会找出v2分支从v1分支分离后的修改，将其应用在main分支上。<code>--onto</code>参数就是干这活的，如果直接进行变基的话，v1和v2的修改都会被应用到main分支上。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过提交历史可以看到，此时的提交历史如下图所示</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309091552648.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>先别急着合并，在这之前，先将分支v1变基到v2分支上</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过提交历史可以看到，此时的提交历史又变成线性的了，然后再逐一合并</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，所有分支的提交都变成线性的了，就如下图所示。这个例子演示了如何在变基时，选择性的合并修改，即便是四个分支，五分支也是同样如此。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309091608582.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 缺点</h3>
<p>就目前而言的话，变基的使用还是相当愉快的，不过愉快的前提是这个仓库只有你一个人用。变基最大的缺点就是体现在远程仓库中多人开发的时候，下面来讲一讲它的缺点。变基的实质是丢弃一些现有的提交，然后再新建一些看起来一样但其实并不一样的提交，这里拿官网的例子举例<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA#_merge_rebase_work" target="_blank" rel="noopener noreferrer">Git - 变基 (git-scm.com)</a>，可以先去了解下远程仓库再来看这个例子。</p>
<p>图中分为远程仓库和本地仓库，你的本地仓库在远程仓库的基础之上做了一些修改。</p>
<figure><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后另外一个人做了一些合并修改，并推送到远程仓库，随后你又拉取了这些修改到你的本地仓库，并将修改合并到你本地的分支，此时提交历史是这样的。</p>
<figure><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>结果那个人吃饱了撑的又把合并操作撤销了，改用变基操作，然后又用<code>git push --force</code>覆盖了远程仓库上的提交历史。这时如果你再次拉取远程仓库上的修改，你就会发现本地仓库中多出来一些提交，这些多出来的提交，就是变基操作在目标分支上复原的提交。此时的提交历史如下图所示</p>
<figure><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到c6是原来远程仓库中三方合并c1，c4，c5产生的新提交，但是那个人将合并撤销后改用变基，这就意味着c6提交在远程仓库中被废弃了，不过在你的本地仓库并没有废弃，而且你本地仓库的c7提交是从c6提交合并而来的，c4'是变基操作将c4重新在目标分支上应用而产生的新提交。再次将远程分支合并过后，其实c6与c4'这两个提交内容是完全一样的，等于是你将相同的内容又合并了一次。本地仓库的提交历史就像下图一样</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309091658757.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>c8是由合并而产生的新提交，你的本地仓库中会同时存在c4与c4'这两个提交，它们两个理应不应该同时出现，这时查看提交历史，你会发现c4与c4'的提交信息完全一模一样。更大的问题是，假如你想要把你的修改提交到远程仓库上，等于就是你把别人通过变基操作丢弃掉的提交（c4，c6）又找了回来。</p>
<p>面对这种问题，你应该将远程分支作为目标分支进行变基，就是执行如下命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Git 将会进行如下操作：</p>
<ul>
<li>检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）</li>
<li>检查其中哪些提交不是合并操作的结果（C2，C3，C4）</li>
<li>检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）</li>
<li>把查到的这些提交应用在 <code>teamone/master</code> 上面</li>
</ul>
<p>最终就会如下图所示，是一个线性的提交历史。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309091713225.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>导致这种情况的原因就在于，你已经基于远程仓库的提交进行新的开发了，而对方却使用变基使得提交废弃了。建议使用变基时，最好只在你本地进行，并且只对<strong>没有推送到远程仓库的提交</strong>进行变基，这样才能安全的享受到变基带来的好处，否则的话你就有大麻烦了。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309081917035.png" type="image/png"/>
    </item>
    <item>
      <title>远程仓库</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/git/3.remote.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/git/3.remote.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">远程仓库</source>
      <description>远程仓库 之前的所有演示都基于本地仓库的，git同样也支持远程仓库，如果想要与他人进行协作开发，可以将项目保存在一个中央服务器上，每一个人将本地仓库的修改推送到远程仓库上，其他人拉取远程仓库的修改，这样一来就可以同步他人的修改。对于远程仓库而言，对于公司而言，都会有自己的内网代码托管服务器，对于个人开发者而言，可以选择自己搭建一个代码托管服务器，又或者是选择第三方托管商。如果你有精力折腾的话可以自己搭，不过我推荐选择第三方的托管商，这样可以将更多精力专注于项目开发上，而且能让更多人发现你的优秀项目。</description>
      <category>git</category>
      <pubDate>Sat, 03 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 远程仓库</h1>
<p>之前的所有演示都基于本地仓库的，git同样也支持远程仓库，如果想要与他人进行协作开发，可以将项目保存在一个中央服务器上，每一个人将本地仓库的修改推送到远程仓库上，其他人拉取远程仓库的修改，这样一来就可以同步他人的修改。对于远程仓库而言，对于公司而言，都会有自己的内网代码托管服务器，对于个人开发者而言，可以选择自己搭建一个代码托管服务器，又或者是选择第三方托管商。如果你有精力折腾的话可以自己搭，不过我推荐选择第三方的托管商，这样可以将更多精力专注于项目开发上，而且能让更多人发现你的优秀项目。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111324350.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 第三方托管</h2>
<p>自建托管网站就是自己搭建的，第三方代码托管网站就是第三方搭建的，他们通过提供优质的代码托管服务，来吸引各式各样的开发人员与开源项目，时至今日，很多托管商基本上都不在局限于代码托管的功能。使用第三方托管商提供的平台，可以让开发者更专注于项目开发，而有些第三方托管商会将自己的项目开源，以供进行私有化部署，并为此提供配套的企业级服务。做的比较好的第三方托管商有以下几个</p>
<ul>
<li>Github</li>
<li>GitLab</li>
<li>BiteBucket</li>
<li>Gitee</li>
<li>sourceforge</li>
<li>Coding</li>
</ul>
<p>其中，GitHub是使用最普及的，可以说，干程序员这行就没有不知道GitHub的，本文将选择Github来作为远程仓库进行讲述。</p>
<h2> Git代理</h2>
<p>在本文开始讲解怎么进行远程仓库的操作之前，有一个相当重要的东西需要解决，那就是网络问题。在国内，Github是无法正常访问的，正常访问Github网站以及它提供的代码托管服务都会相当的缓慢，慢到只有几KB/s，在这种情况下，只能通过魔法上网来解决。</p>
<p>首先你需要自己付费购买代理服务，一般代理商都会给你提供相应的代理工具，比如我使用的代理工具是Clash for windows，它的本地代理端口是<code>7890</code>，并且同时支持http和socks5协议</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111928298.png" style="zoom:50%;">
<p>在知晓了代理端口以后，就可以给Git bash 配置代理了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的是全局设置，你可以只为特定的域名设置代理</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>代理设置完毕后，再使用远程托管服务就会流畅许多。</p>
<h2> 克隆仓库</h2>
<p>在GitHub上有着成千上万的开源仓库，如果你想要获取一个开源仓库的源代码，最好的方式就是克隆仓库，比如Go这门编程语言的开源仓库，事实上这是镜像仓库，源仓库在谷歌。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111910320.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>通过Code按钮可以获取该仓库的url</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111911700.png" style="zoom:50%;">
<p>然后在本地找一个你觉得合适的位置来放置该项目，随后执行命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Go源代码的大小有500MB左右，在将代码克隆到本地以后，你就可以开始独自研究，修改，并编译这些源代码了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上<code>git clone</code>的url参数也可以是本地仓库，例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>git在将仓库克隆到本地时或者检出远程分支时，会自动创建跟踪分支，跟踪分支是与远程分支有着直接关系的本地分支，比如远程分支叫<code>origin/main</code>，那么本地的跟踪分支就与之同名叫<code>main</code>，先查看下分支情况</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到这里有四个分支，首先<code>main</code>属于跟踪分支，<code>origin/main</code>属于远程跟踪分支，它是对于远程仓库中的分支的引用。我们后续在工作区的修改都是基于跟踪分支，远程跟踪分支是不可写的，git会在每一次fetch时更新远程跟踪分支。通过给<code>git branch</code>命令加上<code>-vv</code>参数，可以查看本地所有的跟踪分支。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到git只为main分支自动创建了跟踪分支。假设远程仓库初始状态如下</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309112135355.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>将代码克隆到本地后，本地仓库的状态如下图，在最开始时两个分支都指向的同一个提交。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309112136917.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当你在本地做了一些修改并提交，发现远程仓库上有新提交，并使用<code>git fetch</code>抓取了修改后，于是两个分支各自指向了不同的提交。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309112139906.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这时，为了同步修改，你需要将远程跟踪分支与本地跟踪分支使用<code>git merge</code>合并，于是两个分支又指向了同一个提交。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309112141589.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最终你将提交通过<code>git push</code>推送到了远程仓库，而此时远程仓库的状态就如下图。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309112145929.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这基本上就是一般远程仓库的工作流程。</p>
<h2> 关联仓库</h2>
<p>在本地已有仓库的情况下，可以通过<code>git  remote</code>命令将其与远程仓库关联，已知远程仓库的URL为</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么执行<code>git remote add &lt;name&gt; &lt;url&gt;</code>来将其关联</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过<code>git remote -v</code>来查看本地仓库与之关联的远程仓库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仓库关联成功以后通过<code>show</code>子命令来查看细节</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果后续不再需要了可以删除掉</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过<code>git remote rename</code>来修改关联名称</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者使用<code>git remote set-url</code>来更新url</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个本地仓库也可以多同时关联多个仓库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上gitea这个url并不存在，只是我随便编的，git在关联远程仓库时并不会去尝试抓取它，除非加上<code>-f</code>参数，因为url不存在，抓取的结果自然会失败。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 拉取修改</h2>
<p>在本地仓库与远程仓库刚关联时，仓库内的代码多半是不一致的，为了同步，首先需要拉取远程仓库的修改。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后查看本地分支就会发现多出来了一个分支<code>remotes/github/main</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该分支就是远程仓库上的分支，<code>git fetch</code>命令就是将远程仓库上的修改抓取到了本地的<code>remotes/github/main</code>分支上，但实际上我们的工作分支是<code>main</code>分支，所以我们需要改将其合并</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果想抓取所有远程分支的修改，可以带上<code>--all</code>参数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如果提示<code>fatal: refusing to merge unrelated histories </code>，可以加上<code>--allow-unrelated-histories</code>参数，之所以发生这个问题是因为两个仓库的历史不相关，是独立的。</p>
</div>
<h3> 跟踪分支</h3>
<p>在抓取修改后，git并不会创建跟踪分支，在这种情况下，需要手动创建一个分支，然后将指定的远程分支设置为其上游分支</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>或者使用更简洁但具有同样效果的命令</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以及加上<code>--track</code>参数来自动创建同名的本地跟踪分支</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者你也可以只带分支名，当git发现有与之同名的远程分支就会自动跟踪</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当不再需要跟踪分支时，可以直接通过如下来撤销该分支的上游</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 拉取合并</h3>
<p>每一次抓取修改后都需要手动合并或许有点麻烦，为此git提供了<code>git pull</code>命令来一次性完成这个步骤。格式是如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果要合并的本地分支就是当前分支，则可以省略冒号以及后面的参数，例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，它也支持<code> --allow-unrelated-histories</code>参数，以及所有<code>git fetch</code>支持的参数。</p>
<h2> 推送修改</h2>
<p>当你在本地完成了修改，并提交到了本地仓库时，如果想要将提交推送到远程仓库，就需要用到<code>git push</code>命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该命令执行时，默认会推送当前分支的提交，如果当前分支在远程仓库上并不存在，远程仓库就会自动创建该分支，git也在控制台中输出了整个创建的过程。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者你也可以推送指定分支以及指定远程分支的名称</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想要删除远程分支，只需要加上一个<code>--delete</code>参数即可，例如</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> SSH</h2>
<p>在与远程仓库进行交互的时候，默认使用的是HTTP方式，它的缺点很明显，就是每一次都要手动输入账号密码，为此，使用SSH协议来替代HTTP会更好。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310060939481.png" alt="github支持ssh协议" tabindex="0" loading="lazy"><figcaption>github支持ssh协议</figcaption></figure>
<p>接下来要在本地创建ssh密钥对，打开gitbash，执行如下命令，过程中会要求输入一些信息，根据自己情况来定。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，它会生成在<code>~/.ssh/</code>目录下，git也是默认从这里去读取你的密钥文件。<code>id.rsa</code>是私钥文件，不可以泄露，否则这个密钥对就没有安全意义了。<code>id.rsa.pub</code>是公钥文件，这是需要向外部暴露的。来到github的setting中，添加新的SSH Keys。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310060950740.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>将公钥文件的内容复制到输入框中，再点击按钮添加公钥。完事后执行如下命令测试下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到成功通过SSH认证了，再通过SSH方式克隆一个远程仓库试一试。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到成功了，在github密钥管理界面，也能看到密钥的使用情况。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310061002875.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如此便配置好了通过SSH方式使用git。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111324350.png" type="image/png"/>
    </item>
    <item>
      <title>托管服务器</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/git/4.gitserver.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/git/4.gitserver.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">托管服务器</source>
      <description>托管服务器 在远程仓库中，有许多优秀的第三方代码托管商可以使用，这对于开源项目而言可能足够使用，但是对于公司或者企业内部，就不能使用第三方的代码托管了，为此我们需要自行搭建代码托管服务器，好在市面上有许多开源的自建解决方案，比如bitbucket，gitlab等。 Gitlab gitlab是一个采用Ruby开发的开源代码管理平台，支持web管理界面，下面会演示如何自己搭建一个GitLab服务器，演示的操作系统为Ubuntu。 关于gitlab更详细的文档可以前往GitLab Docs | GitLab，本文只是一个简单的介绍与基本使用。</description>
      <category>git</category>
      <pubDate>Mon, 05 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 托管服务器</h1>
<p>在远程仓库中，有许多优秀的第三方代码托管商可以使用，这对于开源项目而言可能足够使用，但是对于公司或者企业内部，就不能使用第三方的代码托管了，为此我们需要自行搭建代码托管服务器，好在市面上有许多开源的自建解决方案，比如bitbucket，gitlab等。</p>
<h2> Gitlab</h2>
<p>gitlab是一个采用Ruby开发的开源代码管理平台，支持web管理界面，下面会演示如何自己搭建一个GitLab服务器，演示的操作系统为Ubuntu。</p>
<p>关于gitlab更详细的文档可以前往<a href="https://docs.gitlab.com/16.3/ee/" target="_blank" rel="noopener noreferrer">GitLab Docs | GitLab</a>，本文只是一个简单的介绍与基本使用。</p>
<p>开源镜像地址：<a href="https://github.com/gitlabhq/gitlabhq" target="_blank" rel="noopener noreferrer">gitlabhq/gitlabhq: GitLab CE Mirror | Please open new issues in our issue tracker on GitLab.com (github.com)</a></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>gitlab要求服务器的最小内存为4g，低于这个值可能会无法正常运行。</p>
</div>
<h3> 安装</h3>
<p>首先更新一下索引</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后安装几个软件包</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>前往<a href="https://packages.gitlab.com/gitlab/gitlab-ce" target="_blank" rel="noopener noreferrer">gitlab/gitlab-ce - Packages · packages.gitlab.com</a>官方安装包网站，选择属于你自己对应版本的软件包，这里选择的是<code>ubuntu/focal</code></p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309101552264.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>进入该版本，用curl拉取并执行脚本，或者你也可以复制脚本到本地执行</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309101555335.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后用apt再安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者你也可以wget把安装包下载到本地手动安装</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309101602136.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>安装过程可能会有点久，安装包大概有一两个G，当你看到如下输出时就说明安装成功了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置</h3>
<p>gitlab安装完毕后，我们需要做一些初始化的配置。上面的输出<code>configuration in /etc/gitlab/gitlab.rb file</code>已经告知配置文件的地址</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第一点就是修改外部URL，格式为<code>schema://host:port</code> ，端口不填默认为80端口。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完后运行，让gitlab重新加载配置。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后会有这么一段输出</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认密码存放在指定文件中，且24小时后会自动删除，所以建议及时修改，在浏览器中输入<code>external_url</code>，并输入默认的账号密码，访问gitlab。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309102027969.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在Admin Area中，访问users模块</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309102029162.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这里的stranger就是默认的管理账号，点击edit修改账号名称和密码。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309102030012.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>至此，基础的使用配置就完成了，可以开始使用了。如果阅读英文有障碍的话，可以前往<code>Admin Area/Settings/Preferences/Localization</code>调整默认的语言设置，支持简繁中。</p>
<h3> 邮箱</h3>
<p>gitlab大大小小的通知都要用邮箱来进行，邮箱不配置的话，默认发信人就是<code>gitlab@服务IP地址</code>，主要部分在配置文件的这一块。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完后，使用<code>gitlab-ctl reconfigure</code>重新加载配置，通过命令<code>gitlab-rails console</code>打开控制台，执行</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>测试下能否正常发送邮件，成功就说明配置正常。</p>
<h3> 优化</h3>
<p>由于gitlab是ruby写的，这个语言最大的问题就是耗内存和性能低，在写这篇文章的时候，我用的是腾讯云活动打折买整的3年2c4g的云服务器，有时候内存爆满访问502，体验比较糟糕，但是服务器价格不菲，升级的费用相当昂贵。为了能够让贫民机器也能够运行，下面讲一下怎么去做一些简单的优化，让gitlab能够在大多数情况下正常运行。整体就两个思路</p>
<ol>
<li>开启交换内存</li>
<li>关闭一些不必要的插件和功能，节省资源、</li>
</ol>
<p>第一种方法开启交换内存就是内存不够用了拿磁盘来凑，建议自己去了解，不属于本文要讲的内容。下面主要讲一下哪些功能是可以关闭的。</p>
<p>1.Gravatar，这是一个公共的头像托管平台，头像这种功能没什么太大的必要，建议关闭，设置的地方在<code>Admin Area/Setting/General/Account and limit/</code>下</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309102133897.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>关闭后，用户头像就会变成文字而非图像。</p>
<p>2.关闭Prometheus监控，这是一个gitlab的监控组件，如果只是个人使用可以关闭来节省资源，在配置文件中</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 导入</h3>
<p>下面要开启一个很有用的特性，就是让gitlab支持从github导入项目，还支持其它的平台，主要有</p>
<ul>
<li>Github</li>
<li>BitBucket Cloud</li>
<li>FogBugz</li>
<li>Gitea</li>
</ul>
<p>也支持url导入，想从什么来源导入就需要去设置里面专门开启</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309102137168.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后在github中创建一个personal token，需要勾选repo部分，在创建新项目的时候选择导入</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111018705.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>选择github，输入你的personal token，然后就会进入导入页面</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111019943.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>进入到导入页面后，就可以自己选择要导入哪些仓库了。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111019402.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 其它</h3>
<p>gitlab总体来说使用起来跟github非常相似，分为三个大的部分，如下图</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309102034198.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>Your work，就是工作区，仓库的创建，组织的管理等等。</li>
<li>Explore，就类似探索广场，如果你只是自己使用，这个部分没啥太大的用处。</li>
<li>Admin Area，就是后台管理负责的部分，包括用户管理，语言管理，配置管理等等关于这个网站大大小小的细节。</li>
</ul>
<p>到目前为止已经可以基本使用了，介绍的话真要一个个介绍得写到猴年马月，其它具体怎么使用建议看官方文档。gitlab功能很全，但也比较笨重，它更适合中大型的公司项目，有几百上千人的规模。（光是在我的服务器上搭建测试gitlab，就已经卡死机四五次了）</p>
<h2> Gogs</h2>
<p>开源地址：<a href="https://github.com/gogs/gogs" target="_blank" rel="noopener noreferrer">gogs/gogs: Gogs is a painless self-hosted Git service (github.com)</a></p>
<p>文档：<a href="https://gogs.io/" target="_blank" rel="noopener noreferrer">Gogs: A painless self-hosted Git service</a></p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111357482.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果你只是一个独立开发者，或是一个小团队，我建议使用<a href="https://gogs.io/docs" target="_blank" rel="noopener noreferrer">Gogs</a>，它很小巧，同时也是用go语言进行开发的，所以配置要求相当低，不会像gitlab一样动辄要求2c4g以上的服务器才能运行，即便是在树莓派上也能跑，比较适合小团队。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111337172.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以前往<a href="https://try.gogs.io/" target="_blank" rel="noopener noreferrer">在线体验 - Gogs</a>体验一下功能，页面和功能都相当简洁。</p>
<h2> Gitea</h2>
<p>开源地址：<a href="https://github.com/go-gitea/gitea" target="_blank" rel="noopener noreferrer">go-gitea/gitea</a></p>
<p>文档地址：<a href="https://docs.gitea.com/zh-cn/" target="_blank" rel="noopener noreferrer">文档 | Gitea Documentation</a></p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111356763.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Gitea是由Gogs fork发展而来的，两者的目标都是为了构建尽量小巧的代码托管平台，但是功能要比Gogs更加丰富，属于是Gogs的加强版，个人比较推荐使用这个。</p>
<h3> 前期准备</h3>
<p>gitea比gitlab小巧很多，所以很多东西需要我们自己进行配置。gitea的orm是XORM，所以XORM支持的数据库基本上都支持，这里使用的是Mysql，通过docker进行搭建。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后创建一个名为gitea的用户</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后授权</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最后测试连接</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>确保你的git版本大于等2.0，然后还要创建用户</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建工作路径</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>导出环境变量</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用wget下载文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>创建软连接</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 配置文件</h3>
<p>配置文件地址在<code>/var/lib/gitea/custom/conf/app.ini</code>，如果没有需要自行创建，配置文件模板地址在<a href="https://github.com/go-gitea/gitea/blob/release/v1.20/custom/conf/app.example.ini" target="_blank" rel="noopener noreferrer">gitea/custom/conf/app.example.ini</a>。Gitea的配置项相当的多，且不像Gitalb那样支持热加载，总体来说分为</p>
<ul>
<li>数据库配置</li>
<li>站点设置</li>
<li>服务器设置</li>
<li>邮箱设置</li>
<li>三方服务设置</li>
<li>初始管理员设置</li>
</ul>
<p>刚开始的话配置好数据库就行了，其它配置gitea后面会有UI界面进行引导，端口默认为3000。</p>
<div class="language-ini line-numbers-mode" data-ext="ini"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 定义Linux服务</h3>
<p>service文件源地址在<a href="https://github.com/go-gitea/gitea/blob/release/v1.20/contrib/systemd/gitea.service" target="_blank" rel="noopener noreferrer">gitea/contrib/systemd/gitea.service at release/v1.20 · go-gitea/gitea (github.com)</a></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将上述内容复制到<code>/etc/systemd/system/gitea.service</code>，然后启动服务</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 初始配置</h3>
<p>然后访问地址，根据gitea的引导进行初始化配置，gitea并不会像gitlab一样可以热加载配置，gitea所有的配置都需要修配置文件。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111550996.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>你也可以在初始化时设置管理员账号，或者也可以在后续注册，第一个用户默认为管理员，其它的配置自己根据需求来定。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111552282.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>记得确保当前用户具有修改配置文件的权限，然后点击安装，加载几秒后就可以了。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111652405.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后进入到主页面就可以使用了</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111656403.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>运行后相当的流畅，这里放一张性能图。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111658664.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 导入仓库</h3>
<p>导入的话支持以下几个仓库</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111659595.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>还是以github为例，拿到自己的personal token，输入想要导入的url</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309111700583.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>这些操作基本上跟gtilab一致。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309101552264.png" type="image/png"/>
    </item>
    <item>
      <title>ubuntu自定义系统服务</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/linux/linuxservice.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/linux/linuxservice.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">ubuntu自定义系统服务</source>
      <description>ubuntu自定义系统服务</description>
      <category>linux</category>
      <pubDate>Sat, 28 Jan 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> ubuntu自定义系统服务</h1>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111508436.png" style="zoom: 150%;">
<!-- more -->
<hr>
<p>在开发项目时，对于一些后台应用，可以自定义成linux的service，这样能够更加方便的管理。</p>
<p>首先在<code>/etc/systemd/system</code>下，创建一个<code>xxx.service</code>的文件，<code>xxx</code>是服务名。</p>
<p>service文件有特殊的配置格式，下面是一个简单的例子</p>
<div class="language-txt line-numbers-mode" data-ext="txt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>type</code>有以下几种取值</p>
<ul>
<li>
<p>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</p>
</li>
<li>
<p>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</p>
</li>
<li>
<p>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</p>
</li>
<li>
<p>Type=dbus：当前服务通过D-Bus启动</p>
</li>
<li>
<p>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</p>
</li>
<li>
<p>Type=idle：若有其他任务执行完毕，当前服务才会运行，即后台运行</p>
</li>
</ul>
<p>Restart：定义了退出后，Systemd 的重启方式。可以设置的值如下：</p>
<ul>
<li>
<p>no（默认值）：退出后不会重启；</p>
</li>
<li>
<p>on-success：当进程正常退出时（退出状态码为0），才会重启；</p>
</li>
<li>
<p>on-failure：当进程非正常退出时(退出状态码非0)，包括被信号终止和超时，才会重启；</p>
</li>
<li>
<p>on-abnormal：当被信号终止和超时，才会重启；</p>
</li>
<li>
<p>on-abort：当收到没有捕捉到的信号终止时，才会重启；</p>
</li>
<li>
<p>on-watchdog：看门狗超时退出，才会重启；</p>
</li>
<li>
<p>always：总是重启。</p>
</li>
</ul>
<p>KillMode：定义 Systemd 如何停止服务，可以设置的值如下：</p>
<ul>
<li>
<p>control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉；</p>
</li>
<li>
<p>process：只杀主进程；</p>
</li>
<li>
<p>mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号；</p>
</li>
<li>
<p>none：没有进程会被杀掉。</p>
</li>
</ul>
<p>创建完成后，执行命令重新加载服务文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随后使用<code>service hello service </code> 即可开启</p>
]]></content:encoded>
    </item>
    <item>
      <title>所谓模式</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/pattern/00.start.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/pattern/00.start.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">所谓模式</source>
      <description>所谓模式 要说将设计模式发扬光大的语言还得是Java，虽然本质上来说，设计模式是一门语言无关的学问，但几乎所有设计模式的教学语言都是用的是Java，毫无疑问Java是使用设计模式最多的语言，因为它是一个很典型的面向对象的语言，万物皆对象，很显然设计模式就是面向对象的，这是一个优点也是一个缺点，因为有时候过度设计同样会造成难以维护的问题。设计模式起源于建筑工程行业而非计算机行业，它并不像算法一样是经过严谨缜密的逻辑推算出来的，而是经过不断的实践与测试总结出来的经验。使用设计模式是为了代码重用性更好，更容易被他人理解，以及更好维护的代码结构。</description>
      <category>设计模式</category>
      <pubDate>Thu, 28 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 所谓模式</h1>
<p>要说将设计模式发扬光大的语言还得是Java，虽然本质上来说，设计模式是一门语言无关的学问，但几乎所有设计模式的教学语言都是用的是Java，毫无疑问Java是使用设计模式最多的语言，因为它是一个很典型的面向对象的语言，万物皆对象，很显然设计模式就是面向对象的，这是一个优点也是一个缺点，因为有时候<strong>过度设计</strong>同样会造成难以维护的问题。设计模式起源于建筑工程行业而非计算机行业，它并不像算法一样是经过严谨缜密的逻辑推算出来的，而是经过不断的实践与测试总结出来的经验。使用设计模式是为了代码重用性更好，更容易被他人理解，以及更好维护的代码结构。</p>
<p>对于Go而言，也很有学习设计模式的必要，不过需要注意的是，并不是任何时候都需要设计模式，设计模式本就是前人总结的经验，也会有不适用的时候，这些需要自行判断，拒绝言必设计模式。学习设计模式是为了提升编码水平，而不是限制我们的思想。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>Go本身是没有类的说法，与之相似的只有结构体，但是Go又是一门比较偏向于面向对象的语言，所以往后所称的类都是在指接口或结构体。</p>
</div>
<h2> 类型</h2>
<p>设计模式中总共有6大原则，23种设计模式。设计模式大概可分为三类：创建型，结构型，行为型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建型</td>
<td>工厂模式，抽象工厂模式，单例模式，建造者模式，原型模式</td>
</tr>
<tr>
<td>结构型</td>
<td>适配器模式，桥接模式，过滤器模式，组合模式，装饰器模式，外观模式，享元模式，代理模式</td>
</tr>
<tr>
<td>行为型</td>
<td>责任链模式，命令模式，解释器模式，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，空对象模式，策略模式，模板模式，访问者模式</td>
</tr>
</tbody>
</table>
<h2> 原则</h2>
<p>6大原则分别是：</p>
<ul>
<li>开闭原则</li>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>迪米特法则</li>
<li>合成复用原则</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>设计模式这种东西光看介绍是看不懂的，背下来也没用，因为本就是实践才出来东西，不亲自敲一遍是不知道到底是个怎么回事，而且一千个人有一千个写法，例如在本站的设计模式看不懂，说不定去看看其他人的实现就豁然开朗了。顺便提醒一下，如果带着纯粹的面向对象的眼光去看待和学习Go语言，将会十分的痛苦与折磨，Go抛弃了类和继承的概念，对于习惯了Java这类语言的程序员来说是十分不友好的。</p>
</div>
<p>本章借鉴了：<a href="https://github.com/senghoo/golang-design-pattern" target="_blank" rel="noopener noreferrer">senghoo/golang-design-pattern: 设计模式 Golang实现－《研磨设计模式》读书笔记 (github.com)</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>设计原则</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/pattern/01.principle.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/pattern/01.principle.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">设计原则</source>
      <description>设计原则 这六大原则是比较经典的，它们是所有设计模式的基石，也是编码的基本规范，前面讲到不要过度设计，但六大原则是一个优秀的代码应当遵守最基本的规范。 开闭原则 这是一个十分经典的原则，也是最基础的原则，就只有10个字的内容，对拓展开放，对修改关闭。一个程序应当具有相应的拓展性，假设开发了一个Go第三方依赖库，倘若调用者想要自定义功能只能去修改依赖库的源代码，但是每个人都有不同的需求，难道每个人都要改一遍源代码吗，这么做的结果显然是非常恐怖的，代码会变得异常难以维护。 单一职责原则</description>
      <category>设计模式</category>
      <pubDate>Sun, 01 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 设计原则</h1>
<p>这六大原则是比较经典的，它们是所有设计模式的基石，也是编码的基本规范，前面讲到不要过度设计，但六大原则是一个优秀的代码应当遵守最基本的规范。</p>
<h2> 开闭原则</h2>
<p>这是一个十分经典的原则，也是最基础的原则，就只有10个字的内容，<strong>对拓展开放，对修改关闭</strong>。一个程序应当具有相应的拓展性，假设开发了一个Go第三方依赖库，倘若调用者想要自定义功能只能去修改依赖库的源代码，但是每个人都有不同的需求，难道每个人都要改一遍源代码吗，这么做的结果显然是非常恐怖的，代码会变得异常难以维护。</p>
<h2> 单一职责原则</h2>
<p>一个接口，或则一个结构体，或者一个函数，都应当被封装的只有一个职责。这个原则是为了降低代码耦合度，应当尽可能负责更少的功能，而不是全部糅杂在一起。</p>
<h2> 里氏替换原则</h2>
<p>这个原则的原意会比较晦涩难懂，在实现接口或者”继承“时会用到的比较多，原文是：“如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致”。替换指的是任何实现T类型的对象或者子类，都可以当作成T类型的对象来使用，行为一致指的得是被替换后，原有的功能正常使用，不会有任何变化。</p>
<p>里氏替换原则本质上就是多态，结合依赖倒转原则一起使用就是面向接口编程的核心思想。</p>
<h2> 依赖倒转原则</h2>
<p>依赖倒转原则指的是：针对抽象接口编程，而非针对具体实现。例如在编写一个函数或方法时，对于参数我们都会将其设置为对应的接口类型，而不是接口的实现，这样有利于后续的拓展。</p>
<h2> 接口隔离原则</h2>
<p>接口隔离原则值得是尽量降低接口的耦合度，接口要尽量的小，而不是把所有东西都糅杂到接口里，依赖该接口的调用者，不应当访问到不需要用到的接口方法，接口内不应该存在调用者不需要的接口给方法。</p>
<h2> 最少知道法则</h2>
<p>又称迪米特法则，接口与接口之间，模块与模块之间，实体与实体之间应当只存在最低限度的认识和相互作用，使得功能相对独立而受到的影响最少。</p>
<h2> 合成复用原则</h2>
<p>复用时尽可能的使用组合聚合的关系，而不是继承。继承确实可以很简单的复用，但是这会破坏封装性，灵活性低，耦合度高。</p>
]]></content:encoded>
    </item>
    <item>
      <title>创建型模式</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/pattern/02.create.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/pattern/02.create.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">创建型模式</source>
      <description>创建型模式 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。 这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。 简单工厂模式 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 在Go中是没有构造函数的说法，一般会定义Newxxxx函数来初始化相关的结构体或接口，而通过Newxxx函数来初始化返回接口时就是简单工厂模式，一般对于Go而言，最推荐的做法就是简单工厂。</description>
      <category>设计模式</category>
      <pubDate>Tue, 03 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 创建型模式</h1>
<p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。 这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p>
<h2> 简单工厂模式</h2>
<p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>在Go中是没有构造函数的说法，一般会定义<code>Newxxxx</code>函数来初始化相关的结构体或接口，而通过<code>Newxxx</code>函数来初始化返回接口时就是简单工厂模式，一般对于Go而言，最推荐的做法就是简单工厂。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于Go而言，工厂模式显得不那么重要，因为Go并不像Java万物都需要<code>new</code>出来，也并不需要一个专门的接口或者结构体来统一管理创建对象，并且Go的调用是基于包而不是结构体或者接口。</p>
<p><strong>优点</strong>：封装了创建的逻辑</p>
<p><strong>缺点</strong>：每新增一个生物的实现，就要修改一次创建逻辑</p>
<h2> 工厂方法模式</h2>
<p>工厂方法的区别在于，简单工厂是直接创建对象并返回，而工厂模式只定义一个接口，将创建的逻辑交给其子类来实现，即将创建的逻辑延迟到子类。</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点</strong>：封装了创建逻辑，将创建逻辑延迟到子类</p>
<p><strong>缺点</strong>：新增一个生物实现时不需要再修改原有的逻辑，但需要新增一个对应的工厂实现。</p>
<h2> 抽象工厂模式</h2>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ul>
<p>接下来创建一个职业接口，有工匠和士兵两个职业，人分为亚洲人，欧洲人。倘若继续使用工厂方法模式，就需要给人创建一个抽象工厂，再分别创建两个人种创建具体工厂，职业也是类似，一个工厂只能创建同一类的实体，这样做会导致代码量大幅度增加。抽象工厂就是为了解决这个问题而生的。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点</strong>：当更换一套适用的规则时，例如将全部亚洲人换成欧洲人，可以做到无缝更换，只需要换一个工厂即可，不会有任何影响。</p>
<p><strong>缺点</strong>：当内部出现变化的话，几乎所有工厂都要做出对应的变化，例如新增一个人种或新增一个职业。</p>
<h2> 建造者模式</h2>
<p>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p>
<p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</p>
<p>具体建造者类（ConcreteBuilder）：实现Builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p>
<p>产品类（Product）：要创建的复杂对象。</p>
<p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p>
<p>下面以造汽车为例子，汽车需要安装引擎，轮胎，地盘，车架。需要一个汽车建造者接口，和两个实现，分别是卡车建造者和公交车建造者，最后是一个指挥者。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一般建造者模式在部件构建顺序和次序不太复杂的时候，都会选择将指挥者嵌入建造者中，本例选择分离了出来，比较符合单一职责原则，并且可以修改一下逻辑，改为链式调用会更好些。</p>
<p><strong>优点</strong>：建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p>
<p><strong>缺点</strong>：造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<h2> 原型模式</h2>
<p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>
<p>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</p>
<p>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</p>
<p>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在Go中深克隆一个对象并不属于设计模式的范畴</p>
</div>
<h2> 单例模式</h2>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>懒汉方式是延迟加载，即被访问时才加载，饿汉方式是当包加载时该单例就被加载。</p>
]]></content:encoded>
    </item>
    <item>
      <title>结构型模式</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/pattern/03.structure.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/pattern/03.structure.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">结构型模式</source>
      <description>结构型模式 结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式， 前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型 模式具有更大的灵活性。 代理模式 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 抽象主题（Subject）接口： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理（Proxy）类 ：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问，控制或扩展真实主题的功能。</description>
      <category>设计模式</category>
      <pubDate>Fri, 06 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 结构型模式</h1>
<p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式， 前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型 模式具有更大的灵活性。</p>
<h2> 代理模式</h2>
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<ul>
<li>
<p>抽象主题（Subject）接口： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</p>
</li>
<li>
<p>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</p>
</li>
<li>
<p>代理（Proxy）类 ：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问，控制或扩展真实主题的功能。</p>
</li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述这种代理方式是静态代理，对Java有过了解的人可能会想着在Go中搞动态代理，但显然这是不可能的。要知道动态代理的核心是反射，Go确实支持反射，但不要忘了一点是Go是纯粹的静态编译型语言，而Java看似是一个编译型语言，但其实是一个动态的解释型语言，JDK动态代理就是在运行时生成字节码然后通过类加载器加载进JVM的，这对于Go来讲是完全不可能的事情。</p>
<h2> 适配器模式</h2>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<p>举个例子，现在有一个苹果手机，它只支持苹果充电器，但是手上只有一个安卓充电器，这时候需要一个适配器让安卓充电器也可以给苹果手机充电。</p>
<p>适配模式分类适配和对象适配，区别在于前者在适配原有组件时使用的是继承，而后者是组合，通常建议用后者。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 装饰模式</h2>
<p>装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p>
<ul>
<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色 ：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<p>在Go语言中可以通过实现或者匿名组合可以很轻易的实现装饰者模式，装饰者模式又分为全透明和半透明，区别在于是否改变被装饰接口的定义。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是全透明的装饰模式</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是半透明装饰模式，半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。</p>
<p><strong>代理模式和透明装饰者模式的区别</strong>：</p>
<p><strong>相同点</strong>：</p>
<ul>
<li>都要实现与目标类相同的业务接口</li>
<li>都要声明目标对象为成员变量</li>
<li>都可以在不修改目标类的前提下增强目标方法</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li>目的不同装饰者是为了增强目标对象静态代理是为了保护和隐藏目标对象</li>
<li>获取目标对象构建的地方不同装饰者是由外界传递进来，可以通过构造方法传递静态代理是在代理类内部创建，以此来隐藏目标对象</li>
</ul>
<h2> 外观模式</h2>
<p>又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性，是迪米特法则的典型应用。</p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
</ul>
<p>例子：以前到家需要自己手动开电视，开空调，现在有了智能控制器，可以直接控制电视和空调，不再需要手动操作</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点</strong>：</p>
<p>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</p>
<p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</p>
<p><strong>缺点</strong>：</p>
<p>不符合开闭原则，修改很麻烦</p>
<h2> 桥接模式</h2>
<p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>例子：需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI等。该播放器包含了两个维度，适合使用桥接模式。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p>
<h2> 组合模式</h2>
<p>又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>
<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<p>抽象根节点定义默认行为和属性，子类根据需求去选择实现和不实现哪些操作，虽然违背了接口隔离原则，但是在一定情况下非常适用。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>组合模式分为透明组合模式和安全组合模式，区别在于，树枝节点与叶子节点在接口的表现上是否一致，前者是完全一致，但是需要额外的处理避免无意义的调用，而后者虽然避免了无意义的调用，但是对于客户端来说不够透明，叶子节点与树枝节点具有不同的方法，以至于不能很好的抽象。</p>
<h2> 享元模式</h2>
<p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<p>享元（Flyweight ）模式中存在以下两种状态：</p>
<p>1.内部状态，即不会随着环境的改变而改变的可共享部分。</p>
<p>2.外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</p>
<ul>
<li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li>
<li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li>
<li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li>
<li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ul>
<p>众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</p>
<p><strong>优点</strong>：</p>
<p>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能，享元模式中的外部状态相对独立，且不影响内部状态</p>
<p><strong>缺点</strong>：</p>
<p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p>
]]></content:encoded>
    </item>
    <item>
      <title>行为型模式</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/pattern/04.behavior.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/pattern/04.behavior.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">行为型模式</source>
      <description>行为型模式 行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 模板方法模式 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</description>
      <category>设计模式</category>
      <pubDate>Mon, 09 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 行为型模式</h1>
<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<h2> 模板方法模式</h2>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<ul>
<li>
<p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>
<ul>
<li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>
<li>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。</li>
</ul>
</li>
<li>
<p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>
</li>
</ul>
<p>很典型的一个例子，go 标准库中排序<code>sort</code>包下 的<code>Interface</code>接口，其内部定义了三个基本方法和几个模板方法，倘若想要自定义数据结构排序，就必须要实现这三个方法，模板方法内会将基本方法的返回值当作排序的依据。</p>
<p>例：北方人都喜欢吃面，而煮面的步骤都是相同的，只是其中的细节和顺序不同，分为，烧水，下面，挑面，放调料。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>go语言是不提供继承机制的，这里是用匿名组合和手动让父类持有子类引用来模拟的，官方的解决办法是在<code>sort</code>包下，直接将模板方法作为了私有的函数，而不是成员方法，个人认为官方的解决办法会更好一些。</p>
<h2> 观察者模式</h2>
<p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ul>
<p>例：一个公众号有很多个订阅用户，公众号更新时会自动通知用户，用户收到通知便会做出相应的行为。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 备忘录模式</h2>
<p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p>
<ul>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>备忘录有两个等效的接口：</p>
<p><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</p>
<p><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</p>
</div>
<h4> 白箱模式</h4>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 黑箱模式</h4>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点</strong>：</p>
<p>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录 中，并由管理者进行管理，这符合单一职责原则。</p>
<p><strong>缺点</strong>：</p>
<p>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<h2> 责任链模式</h2>
<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>Gin框架内的中间件就是责任链模式的一个应用。</p>
</div>
<p>例子：现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实代码也还可以再简化，本质上调用链传的只是一个个方法，可以不需要<code>Handler</code>接口，将其换为类型为<code>Func(Handlee) bool</code>的类型会更好一些。</p>
<p><strong>优点</strong></p>
<p>降低了对象之间的耦合度该模式降低了请求发送者和接收者的耦合度。</p>
<p>增强了系统的可扩展性可以根据需要增加新的请求处理类，满足开闭原则。</p>
<p>增强了给对象指派职责的灵活性当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p>
<p>责任链简化了对象之间的连接</p>
<p><strong>缺点</strong></p>
<p>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理， 该请求可能一直传到链的末端都得不到处理。 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</p>
<h2> 策略模式</h2>
<p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用 算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分 割开来，并委派给不同的对象对这些算法进行管理。</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口实现。此角色给出所有 的具体策略类所需的接口。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<p>一个商店同时支持微信支付和支付宝支付，只要传入对应的支付方式就可以支付。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>策略类之间可以自由切换，由于策略类都实现同一个接口，所以使它们之间可以自由切换。</li>
<li>易于扩展，增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</li>
<li>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</li>
</ul>
<h2> 命令模式</h2>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象 进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
<ul>
<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>
<li>具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用 命令对象的入口。</li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 迭代器模式</h2>
<p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</p>
<ul>
<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>
<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、 next() 等方法。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对 象的遍历，记录遍历的当前位置。</li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 状态模式</h2>
<p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变 时改变其行为。</p>
<ul>
<li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete State）角色：实现抽象状态所对应的行为。</li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 解释器模式</h2>
<p>解释器模式定义一套语言文法，并设计该语言解释器，使用户能使用特定文法控制解释器行为。解释器模式的意义在于，它分离多种复杂功能的实现，每个功能只需关注自身的解释。对于调用者不用关心内部的解释器的工作，只需要用简单的方式组合命令就可以。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 访问者模式</h2>
<p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 中介者模式</h2>
<p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以 独立地改变它们之间的交互。</p>
<ul>
<li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对 象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽 象方法，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交 互时，由中介者对象负责后续的交互。</li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Rust安装</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/rust/install.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/rust/install.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Rust安装</source>
      <description>Rust安装</description>
      <category>rust</category>
      <pubDate>Wed, 06 Dec 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Rust安装</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312061513880.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>在这之前早已听说过rust的大名，虽然我在知乎上看到的rust貌似都是负面的评价？不过也看到了许多由Rust编写的工具，在了解到Rust的一些设计理念后，觉得有些方面做的要比Go好，就打算来试一试。</p>
<p>文档：<a href="https://www.rust-lang.org/zh-CN/tools/install" target="_blank" rel="noopener noreferrer">安装 Rust - Rust 程序设计语言 (rust-lang.org)</a></p>
<p>由于我现在使用的是windows系统，所以本文采用win的环境来进行演示，与Linux上的安装方式差别也不算太大。</p>
<h2> 安装</h2>
<p>学习语言的第一步就是就是安装它，这一块rust做的确实挺好的，官网的中文支持也非常好，有一个专门负责语言自身的安装工具：rustup，所以我们只需要下载rustup就行了。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312061514947.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>在此之前还需要下载MSVC也就是<a href="https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/" target="_blank" rel="noopener noreferrer">Microsoft C++ 生成工具</a>，没有它的话就没法编译。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408102125583.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后再下载rustup-init.exe，点击执行后是一个命令行，新手的话选默认安装即可，熟悉之后再自定义安装，然后它就会帮你安装好rust和cargo，并且配置环境变量。如果遇到下载缓慢问题，安装<a href="#%E9%95%9C%E5%83%8F">镜像</a>部分配置即可。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408102130005.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>组件安装成功后，执行如下命令确认安装成功</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>能够正确输出版本就说明安装成功了。</p>
<h2> 镜像</h2>
<p>在安装rustup以及用cargo安装依赖时，由于服务器在国外，避免不了下载速度缓慢的问题，这里建议使用字节跳动提供的rust镜像：<a href="https://rsproxy.cn/" target="_blank" rel="noopener noreferrer">RsProxy</a>。</p>
<p>设置 Rustup 镜像， 修改配置 ~/.zshrc 或 ~/.bashrc</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>设置 <a href="http://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a> 镜像， 修改配置 ~/.cargo/config.toml，已支持git协议和sparse协议，&gt;=1.68 版本建议使用 sparse-index，速度更快。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 编辑器</h2>
<p>这个就看个人喜好了，用什么其实都能写，neovim+cargo一样能写，毕竟rust自身的工具链很完善，不过我是windows系统，编辑器的话推荐vscode和rustover。</p>
<p>使用vscode的话要下载rust拓展，建议下载<code>rust-analyzer</code>，这是社区的rust插件，官方的已经不维护了。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312061524391.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果是rustover的话基本上就是开箱即用。</p>
<h2> 工具链</h2>
<p>rust安装后会下载一系列工具链，简单介绍以下</p>
<ul>
<li>cargo：rust包管理工具</li>
<li>rustc：rust编译器</li>
<li>clippy：静态代码优化工具</li>
<li>rustfmt：代码格式化工具</li>
<li>rust-std：标准库</li>
</ul>
<h2> 术语&amp;介绍</h2>
<p><strong>项目类型</strong></p>
<p>rust项目可以通过cargo工具来进行创建，rust项目分为两种类型</p>
<ul>
<li>bin：表示项目会被编译为二进制文件</li>
<li>lib：表示项目是一个依赖库</li>
</ul>
<p>默认创建bin类型的项目。</p>
<br>
<p><strong>编译模式</strong></p>
<p>在开发本地项目时，cargo编译模式分两种</p>
<ul>
<li>debug：编译优化少，速度快，生成的二进制文件运行性能低下，就是开发模式</li>
<li>release：编译优化多，速度慢，生成的二进制文件性能高，也就是生产模式</li>
</ul>
<p>默认情况下采用debug模式。</p>
<br>
<p><strong>项目结构</strong></p>
<p>一个初始的rust项目结构如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>cargo.lock</code>和<code>cargo.toml</code>是用于管理依赖的，跟nodejs一样，项目的入口文件是<code>src/main.rs</code>，编译出来的文件会在<code>target</code>目录，以<code>debug</code>和<code>release</code>进行区分。</p>
<p><strong>一些术语</strong></p>
<ul>
<li>crate：crate 是一个二进制项或者库（这个东西该怎么翻译都不知道）</li>
<li>package：提供一系列功能的一个或者多个 crate</li>
</ul>
<h2> cargo</h2>
<p>cargo的特性如果要细扣的话有很多，对于新手来说其实只需要记住几个使用的命令就够了</p>
<p>创建项目</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>运行项目</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>检查代码</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成离线文档，生成的路径位于<code>target/doc</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它还会为将你项目所有依赖的文档整合到一起，如下图</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//upload/202408121925112.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 案例</h2>
<p>这是官方的一个入门案例，是一个简单的猜数字游戏。</p>
<div class="language-rust line-numbers-mode" data-ext="rs"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>短短30行代码，里面的内容涉及到了</p>
<ul>
<li>所有权与借用</li>
<li>match语句</li>
<li>输入输出</li>
<li>关联函数</li>
<li>循环语句</li>
<li>错误处理</li>
<li>外部crate</li>
</ul>
<h2> 个人评价</h2>
<p>Rust的难度并没有简单到像Go一样可以看几个例子就学会语法，它的学习成本并不低，如果熟练掌握了应该会成为一个很强大的工具。个人感觉有些地方设计的非常好，比如错误处理，泛型，枚举，并且依赖管理这方面做的也比Go好很多。它也确实能让人感觉到是一个现代化的语言，自带语言版本管理工具，完善的依赖管理，丰富的文档，跨平台支持良好，就目前带给我的体验而言，感觉没有什么可以抱怨的点。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312061513880.png" type="image/png"/>
    </item>
    <item>
      <title>goland索引失效</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/goland_invalid_ref.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/goland_invalid_ref.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">goland索引失效</source>
      <description>goland索引失效 问题相当的恼火</description>
      <category>问题记录</category>
      <pubDate>Tue, 17 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> goland索引失效</h1>
<p>问题相当的恼火</p>
<!-- more -->
<hr>
<h3> 问题</h3>
<p>最近在用goland写代码的时候，经常会出现某个包的类型无法解析的情况，但实际上没有任何的错误。比如这一行代码引用了<code>user.PageOption</code>，</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310221542332.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>goland报错提示引用无法正常解析</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310221543827.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>但实际上根本就没有任何的错误</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310221544683.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>go vet</code>也检测不到任何的错误，编译也可以正常通过。出现这种情况的话就没法进行引用快速跳转，智能提示等，这种情况还会发生在函数，接口，结构体，字段上，并且一旦有其它类型引用了这些它们，那么该类型也会变得“无法正常解析”，突出一个离谱，这样很影响效率。</p>
<h3> 解决</h3>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310221556764.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>解决不了，摆烂！这个问题我已经在youtrack反映过了，问题链接：<a href="https://youtrack.jetbrains.com/issue/GO-15632/reference-index-invalid-frequently" target="_blank" rel="noopener noreferrer">youtrack</a>。工作人员让我升级到2023.2.3，但实际上我就是在2.3版本发现问题才降到2.2的。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310221552165.png" style="zoom:50%;">
<p>结果发现降下来没有任何的改善，在bug修复之前唯一能做的就只有等待。不过总归要有一个临时的解决办法，既然是索引出了问题，那就把索引清空了重新对项目进行索引。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310221551987.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>但如果每次发生这种情况都要重启一次的话，那就太浪费时间了，goland重启+构建索引的时间基本上有几分钟了，但凡gomod的依赖多一点，花的时间就更久，不过除此之外也没别的办法了。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310221542332.png" type="image/png"/>
    </item>
    <item>
      <title>海边的一段代码</title>
      <link>https://246859.github.io/my-blog-giscus/posts/life/2023_01_22.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/life/2023_01_22.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">海边的一段代码</source>
      <description>海边的一段代码 过年的时候在厦门的海滩上，别人都在写和谁谁相爱一辈子，而我写了一段代码。</description>
      <category>生活随笔</category>
      <pubDate>Sun, 22 Jan 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 海边的一段代码</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111956319.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>过年的时候在厦门的海滩上，别人都在写和谁谁相爱一辈子，而我写了一段代码。</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310111956319.png" type="image/png"/>
    </item>
    <item>
      <title>一次70KM短途骑行</title>
      <link>https://246859.github.io/my-blog-giscus/posts/life/2023_02_27.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/life/2023_02_27.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">一次70KM短途骑行</source>
      <description>一次70KM短途骑行 从学校出发到江边，硬生生从山底爬到山顶，全程70KM。</description>
      <category>生活随笔</category>
      <pubDate>Mon, 27 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 一次70KM短途骑行</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/2023227骑行.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从学校出发到江边，硬生生从山底爬到山顶，全程70KM。</p>
<!-- more -->
<hr>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310112002883.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310112002088.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/2023227%E9%AA%91%E8%A1%8C.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>暑假骑行</title>
      <link>https://246859.github.io/my-blog-giscus/posts/life/2023_10_09.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/life/2023_10_09.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">暑假骑行</source>
      <description>暑假骑行 暑假在江边骑行</description>
      <category>生活随笔</category>
      <pubDate>Sat, 22 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 暑假骑行</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091722442.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>暑假在江边骑行</p>
<!-- more -->
<hr>
<p>早上异常的湿热，空气里全是水，站着不动都能汗湿，中午以后直接暴晒，顶着39度的太阳骑行，随行的学弟直接被晒的神志不清，回去以后小臂晒掉一层皮。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091725819.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091725849.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091722442.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>黑暗之魂I：重制版</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/darksoul1.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/darksoul1.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">黑暗之魂I：重制版</source>
      <description>黑暗之魂I：重制版 开山之作，地图设计极其优秀，三部曲中氛围最好，也是最喜欢的。</description>
      <category>游戏杂谈</category>
      <pubDate>Mon, 12 Aug 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 黑暗之魂I：重制版</h1>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091210402.jpg" style="zoom:150%;">
<p>开山之作，地图设计极其优秀，三部曲中氛围最好，也是最喜欢的。</p>
<!-- more -->
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>黑暗之魂II：原罪学者</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/darksoul2.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/darksoul2.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">黑暗之魂II：原罪学者</source>
      <description>黑暗之魂II：原罪学者 自身足够优秀，但是相比于它的前辈和后辈就有点黯然失色了。</description>
      <category>游戏杂谈</category>
      <pubDate>Fri, 09 Apr 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 黑暗之魂II：原罪学者</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091200973.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>自身足够优秀，但是相比于它的前辈和后辈就有点黯然失色了。</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091200973.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>黑暗之魂III：火之将熄</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/darksoul3.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/darksoul3.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">黑暗之魂III：火之将熄</source>
      <description>黑暗之魂III：火之将熄 延续了一贯的风格，魂系列的佳作。</description>
      <category>游戏杂谈</category>
      <pubDate>Tue, 08 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 黑暗之魂III：火之将熄</h1>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091205455.jpg" style="zoom:150%;">
<p>延续了一贯的风格，魂系列的佳作。</p>
<!-- more -->
<hr>
]]></content:encoded>
    </item>
    <item>
      <title>艾尔登法环</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/elden_ring.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/elden_ring.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">艾尔登法环</source>
      <description>艾尔登法环 魂系列集大成之作，唯一一个全成就的游戏，首发预购的含金量</description>
      <category>游戏杂谈</category>
      <pubDate>Fri, 25 Feb 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 艾尔登法环</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091102051.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>魂系列集大成之作，唯一一个全成就的游戏，首发预购的含金量</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091102051.png" type="image/png"/>
    </item>
    <item>
      <title>激流快艇</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/gp.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/gp.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">激流快艇</source>
      <description>激流快艇 初中在家里的智能电视上玩的激流快艇2，童年回忆之一，第三部是18年出的，人长大了但电视还是那个电视，现在还能玩不过卡跟ppt一样。</description>
      <category>游戏杂谈</category>
      <pubDate>Mon, 09 Oct 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 激流快艇</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091035367.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>初中在家里的智能电视上玩的激流快艇2，童年回忆之一，第三部是18年出的，人长大了但电视还是那个电视，现在还能玩不过卡跟ppt一样。</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091035367.png" type="image/png"/>
    </item>
    <item>
      <title>天国拯救</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/kingdom_come.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/kingdom_come.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">天国拯救</source>
      <description>天国拯救 一个铁匠儿子成长为剑术大师的故事，剧情挺好，战斗太难了，为了看剧情开修改器过的。</description>
      <category>游戏杂谈</category>
      <pubDate>Sun, 05 Sep 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 天国拯救</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091146687.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一个铁匠儿子成长为剑术大师的故事，剧情挺好，战斗太难了，为了看剧情开修改器过的。</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091146687.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>生化危机2 重制版</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/re2.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/re2.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">生化危机2 重制版</source>
      <description>生化危机2 重制版 第一次玩的时候还有点吓人，后面逛警察局就跟回家一样，游戏质量很高。</description>
      <category>游戏杂谈</category>
      <pubDate>Sat, 10 Jul 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 生化危机2 重制版</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091115507.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>第一次玩的时候还有点吓人，后面逛警察局就跟回家一样，游戏质量很高。</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091115507.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>只狼：影逝二度</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/sekrio.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/sekrio.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">只狼：影逝二度</source>
      <description>只狼：影逝二度 老贼非常成功的创新，游戏内容不算特别多，但胜在短小精悍。</description>
      <category>游戏杂谈</category>
      <pubDate>Sat, 07 Nov 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 只狼：影逝二度</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091218744.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>老贼非常成功的创新，游戏内容不算特别多，但胜在短小精悍。</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091218744.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>巫师三：狂猎</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/witcher.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/witcher.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">巫师三：狂猎</source>
      <description>巫师三：狂猎 先看小说再玩游戏，我愿称之为开放世界天花板。</description>
      <category>游戏杂谈</category>
      <pubDate>Thu, 17 Dec 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 巫师三：狂猎</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091154859.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>先看小说再玩游戏，我愿称之为开放世界天花板。</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202310091154859.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>在Linux上搭建K8s集群</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/k8s_install.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/k8s_install.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">在Linux上搭建K8s集群</source>
      <description>在Linux上搭建K8s集群 最近捣鼓了下用虚拟机搭建k8s集群，坑还是挺多的。</description>
      <category>技术日志</category>
      <pubDate>Mon, 25 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 在Linux上搭建K8s集群</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309251850239.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最近捣鼓了下用虚拟机搭建k8s集群，坑还是挺多的。</p>
<!-- more -->
<hr>
<figure><img src="https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最近在学习k8s，不得不说这玩意运行起来还是相当的麻烦，这里记录一下，以免后面忘了。事先准备好三台ubuntu22.04虚拟机，一台用作control plane，两台用作worker node。</p>
<h2> 前置准备</h2>
<p>在开始安装k8s之前，需要做一些前置的准备。</p>
<h3> 关闭firewalld</h3>
<p>k8s有着自己的网络策略配置功能，关闭friewalld是为了避免起冲突。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 禁用selinux</h3>
<p>selinux是linux的一个安全子系统，很多服务器未为了避免麻烦都会把它关了，ubuntu在装机的时候不会自带这玩意，但如果你装了的话可以按照下面的步骤关闭。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 关闭swap</h3>
<p>kubelet运行时明确不支持swap，也就是交换内存，一部分原因是想让程序在内存耗尽以后正常OOM而不是一直靠swap苟着从而造成不必要的损失。如果未关闭swap直接启动的话，kubelet在启动时会显示如下信息告诉你应该关闭swap，否则不让你启动。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>首先执行命令关闭交换分区</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后修改<code>fstab</code>文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注释掉如下行</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行如下命令查看swap分区情况，如果关闭了的话就不会有任何显示</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 配置网络</h3>
<p>转发 IPv4 并让 iptables 看到桥接流量</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过运行以下指令确认 <code>br_netfilter</code> 和 <code>overlay</code> 模块被加载：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通过运行以下指令确认 <code>net.bridge.bridge-nf-call-iptables</code>、<code>net.bridge.bridge-nf-call-ip6tables</code> 和 <code>net.ipv4.ip_forward</code> 系统变量在你的 <code>sysctl</code> 配置中被设置为 1</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> CRI</h2>
<p>Container Runtime Interface（CRI），即容器运行时接口，要想使用K8s的话，需要系统提供CRI，目前实现了CRI的软件的有</p>
<ul>
<li>containerd，推荐用这个，比较轻量。</li>
<li>docker engine，并没有实现CRI但是可以通过其它方法桥接，不过一般安装了docker engine的系统都会有containerd，因为containerd就是docker的一部分，所以还是建议用containerd。</li>
<li>CRI-O</li>
<li>MCR</li>
</ul>
<h3> containerd</h3>
<p>下面会用containerd来做演示，其实containerd安装过程就是docker安装过程，先设置docker官方的apt仓库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="http://xn--containerd-j05qpn034ff9b232ee69h.io" target="_blank" rel="noopener noreferrer">最后就只安装containerd.io</a>，不用安装dcoker-ce和docker-cli。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者你也可以直接下载containerd的二进制文件，它也是用go写的。在安装好后，需要配置systemd cgroup驱动，在containerd配置文件中</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改如下的配置项</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>使用如下命令可以重置containerd配置</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<p>从软件包安装的话可能会默认禁用CRI，在配置文件中可能会看到这么一行，将其去掉就行。</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改完后重启containerd</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 安装</h2>
<p>配置下k8s的阿里云apt源</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更新证书</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再更新源</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后安装<code>kubeadm</code>，<code>kubectl</code>，<code>kubelet</code>，这三个最好软件版本保持一致。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>完成后确认版本</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>确认版本一致后，看看k8s的镜像，后续必须pull这些镜像，因为这是k8s集群运行的必要组件。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到目前为止，系统上会有下面这几个东西</p>
<ul>
<li><code>kebuadm</code>，用来快速启动和搭建k8s集群的工具，可以省去我们很多操作。</li>
<li><code>kubelet</code>，k8s集群命令行管理工具</li>
<li><code>kubelet</code>，代表着一个节点，是k8s集群的基本单位。</li>
<li><code>crictl</code>，容器运行时管理工具，只不过它是为k8s工作的，正确使用的前提是系统上安装了支持CRI的软件并正确指定了endpoint。</li>
<li><code>ctr</code>，ctr是containerd的命令管理工具，containerd实现了CRI。</li>
</ul>
<h3> cri endpoint</h3>
<p>ctrctl虽然是容器运行时管理工具，但是它并没有具体的实现，只是定义了一组接口规范。要想正常工作还得依赖具体的实现了CRI的软件，之前已经安装好了containerd，所以运行前要先指定crictl的<code>runtime-endpoint</code>，也就是containerd的sock地址。</p>
<p>通过查看配置文件<code>etc/containerd/config.toml</code>可以得知</p>
<div class="language-toml line-numbers-mode" data-ext="toml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么endpoint就是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以执行如下命令配置crictl</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 拉镜像</h3>
<p>kubeadm支持通过命令预先拉取需要用到的组件镜像，也就是之前list出来的镜像，执行如下命令就可以预先拉取要用到的镜像。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是不出意外的话，意外就会发生了，上述的镜像仓库是<code>registry.k8s.io</code>，是由谷歌托管的，国内基本上没法访问，甚至于在线获取版本信息都不行</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法就是国内的镜像，阿里云有一个镜像仓库，地址如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>网上有很多教程直接在<code>kubeadm init</code>时直接指定了阿里云镜像仓库，这样会导致kubelet没法正常运行，会说找不到组件的镜像，因为kubelet运行的时候只认<code>registry.k8s.io</code>镜像，而通过阿里云镜像仓库拉下来的镜像的前缀是<code>registry.aliyuncs.com/google_containers</code>，所以kubelet自然就没法启动了。所以对应的，拉取完下面的镜像后，应该将其名字改回去。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>crictl并不能修改镜像名，这是ctr应该干的事情，为了能够查看到k8s的镜像，指定命名空间<code>k8s.io</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个个改名太麻烦了，所以我写了一个脚本，来自动化完成这个过程。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者也可以</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 初始化</h3>
<p>接下来使用kubeadm来初始化，这个操作只用在master节点进行。init时有很多参数，开始前可以看看命令帮助。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来就开始初始化，如果上面的配置都做好了的话，是不会出现问题的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309251850239.png" type="image/png"/>
    </item>
    <item>
      <title>数据库被注入恶意信息</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/mysqlinject.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/mysqlinject.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">数据库被注入恶意信息</source>
      <description>数据库被注入恶意信息</description>
      <category>问题记录</category>
      <pubDate>Fri, 22 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 数据库被注入恶意信息</h1>
<!-- more -->
<hr>
<h2> 分析</h2>
<p>前段时间搭建了个gitea自用，有一天上去过后发现web一直显示500，想着重启试试，结果发现再也重启不能。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在日志这一块，看到了这么个东西，类似一串js代码，后面去看了下数据库，不看不得了，一看吓一跳，数据库里很多表的字段内容都被纂改了</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309221547220.png" style="zoom:50%;">
<p>完整内容如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>中间是一段base64编码的url，解码过后就是</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>大概是想实现js代码被加载的时候自动跳转到这个网站，这个网站后面去看了下，就是个普通的色情网站。</p>
<h2> 问题</h2>
<p>问题出现在root密码太过简单，就是123456，由于在使用的时候用的是另一个数据库账号，初始化的root密码忘记改了，所以还是留着123456没有变，这才有了可乘之机。</p>
<h2> 解决</h2>
<p>最后是手动将脏数据清洗掉，才恢复了正常，以后还是要定时备份，做好安全工作。</p>
]]></content:encoded>
    </item>
    <item>
      <title>记一次服务器被黑的解决过程</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/hack.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/hack.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">记一次服务器被黑的解决过程</source>
      <description>记一次服务器被黑的解决过程 只能说离谱，以后还是要多注意这方面的东西。</description>
      <category>问题记录</category>
      <pubDate>Tue, 12 Sep 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 记一次服务器被黑的解决过程</h1>
<p>只能说离谱，以后还是要多注意这方面的东西。</p>
<!-- more -->
<hr>
<p>一大早起来，就看到腾讯云异常登录的通知，就大概明白是咋回事了，这是我在腾讯云上的一个轻量应用服务器，倒也算不上第一次被黑，上一次被黑的时候入侵者仅仅只是放了一个挖矿木马就没了，其它什么也没动。这一次不仅搞挖矿把服务器资源都跑满了，而且还把我root用户的ssh密钥都改了，一大早起来就得赶紧解决。这里放一张图，看看资源使用情况，基本上都已经爆满了。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309120816314.png" style="zoom: 80%;">
<h2> 原因</h2>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309120919508.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>究其原因，是因为在前几天为了在服务器上搭建自用的gitea，创建了一个新用户<code>git</code>来跑服务，也就是此次异常登录的用户，当时给它添加到了sudo组，而且也忘记做远程登录限制，也没有ssh密钥，密码也是非常简单的<code>123456</code>，被暴力破解应该是轻而易举的，只是没想到睡一觉起来就G了，以后在这一块看来是一点都不能松懈。下面是截取的一部分登录尝试记录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 解决</h2>
<p>首先是之前的用户都登陆不上去了，这里只能用服务器默认用户在腾讯云后台重置密码，密码重置完后，登陆到服务器上，top看一下</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309120850327.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>可以看到第一行xrx这个东西已经把cpu跑满了，内存也没剩下多少并且还多了一个cheeki用户。然后来看看这个玩意的运行路径</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再locate一下看看</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中这个<code>ini.sh</code>应该是被混淆过的，全是乱码，key文件和passwd可能是用来解码的。此时看下git用户的<code>.bash_history</code>都是我自己留下的记录，操作记录也是可以被隐藏的。目前root目录我是进不去的，直接把这个进程kill了也无济于事，一般来说会有定时任务来定时重启这些木马，查看系统定时任务，差不多就是特定的地方拉取脚本然后执行，并且在重启的时候还会后台运行这几个进程。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到该文件修改时间就是凌晨一点，差不多就是我在睡觉的时候。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>差不多在同一时间，<code>/etc/passwd</code>文件也被修改了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>不幸的是，passwd命令也被掉包了，即便通过root权限，也无法直接修改用户的密码，而且我修改的密码可能会通过网络被上传到后台。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>把盗版的passwd先删掉，然后用apt重新安装一个</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>后面的任务是拿到root账号，这里通过腾讯云后台提供的重置密码功能，把root账号的密码给重置了，然后用默认账户登录上去再切换到root，可以看到密钥已经被改了，修改时间也是凌晨</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并且还上锁了，无法删除</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>尝试解锁后成功了，庆幸没有对方修改chattr命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>把所有密钥都删除，然后再删除木马文件和定时任务，然后再重启看看，是否恢复正常。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>删除之后的话基本上服务器占用就变正常了，为了彻底解决，这里把ssh的配置设置的更加严格一些，禁止密码登录，禁止root登录，修改ssh默认端口号。差不多后续就不会出什么问题了，除非有什么其它软件漏洞。下面是修改后的占用图，就是正常状态了。</p>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309121531013.png" style="zoom:80%;">
<p>下面是一些用到的文章</p>
<ul>
<li>
<p><a href="https://cloud.tencent.com/developer/article/1026521?areaId=106001" target="_blank" rel="noopener noreferrer">Linux系统是否被植入木马的排查流程梳理-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
<li>
<p><a href="https://cloud.tencent.com/developer/article/1828412" target="_blank" rel="noopener noreferrer">Linux服务器被黑 排查思路(上)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202309120919508.png" type="image/png"/>
    </item>
    <item>
      <title>记一次Redis线上数据突然丢失的问题</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/redisdataloss.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/redisdataloss.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">记一次Redis线上数据突然丢失的问题</source>
      <description>记一次Redis线上数据突然丢失的问题</description>
      <category>问题记录</category>
      <pubDate>Sat, 22 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 记一次Redis线上数据突然丢失的问题</h1>
<!-- more -->
<hr>
<p>之前的项目用到了redis来存放一些游戏的模组信息以及一些非结构化配置，突然有一次甲方告诉我系统出问题了，我一去看发现redis里面的数据全没了，由于redis没有开启日志，一时半会排查不出来是什么问题。就把redis aof备份粒度做的更细了一些，暂时想到的可能是RDB跟AOF覆盖掉了，但是这种情况应该非常小，事后还做好了日志方便下次排查，弄好之后这件事就这么过去了，</p>
<p>直到两个星期后，又发生了这个问题，查看到系统日志是下午15:26:51发生的问题，对比redis日志，刚开始还是一些正常的备份信息，像下面这样</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到出问题的时间点的时候就发现不对劲了，</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>尤其是这一段<code>Connecting to MASTER 35.158.95.21:60107</code>，这个IP并不是甲方的IP，并且系统是单机应用，redis都是直接和后端部署在同一个物理机上的，并没有采用redis集群和主从复制。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>复制master数据后，我们的数据就没了，然后备份过后redis数据也没了。多半是redis密码太简单导致的问题，于是修改密码后再看后续的情况。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Dstm项目完结</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/dstm.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/dstm.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Dstm项目完结</source>
      <description>Dstm项目完结</description>
      <category>技术日志</category>
      <pubDate>Sat, 08 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Dstm项目完结</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307081548886.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<!-- more -->
<hr>
<p>Dstm全名Don’t Starve Together Manager，中文名饥荒联机版控制面板，基于docker实现，这个项目所有的内容由我独自一人完成，前前后后总共花费了接近三个月的时间，虽然钱有点少，但是收获还是蛮多的，于是写了这一篇文章记录一下。</p>
<h2> 历程</h2>
<p>这个项目只是我在在校个人接的一个项目，所以没有严格的什么招标投标的流程。甲方是一个体量不算大的云服务商（注册资金100万左右），以前在他们那边买过云服务器，他们主营业务是《我的世界》面板服务器和VPS，本人也算是他们的一个老客户了。4月初的时候来找我谈这个项目，想要拓展饥荒这款游戏的业务，最初提出的是想要做一款类似翼龙的面板，由于老板本身不了解技术，需求提的很模糊（让我明白沟通的重要性），并且我对于这款游戏也是没有任何游玩经验，4月份大部分时间都是在熟悉游戏相关的内容以及模组拓展部分，并且花了两个星期写了一个前端的demo展示给甲方看，这之后才正式谈妥。4月末5月初算是真正明确了项目的方向，最开始前端挑选了一个相当优秀的开源脚手架（Vben），内置了丰富的功能和组件，让我节省了大量的时间和精力，让我能够专注于后端代码的编写，后端项目是完全从零开始的，没有用其他的脚手架，所以花费的时间会更多一些，难度自然也就更大。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307081635524.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>对于前端而言，虽然我主要学习方向是后端，以前多多少少学过前端的内容，虽然界面做出来算不上多美观，但是至少界面简洁，功能正常。以前在编写mc插件的时候用的最多的就是js，有着脚手架的加持和开源的UI组件库，对我而言整个前端开发的过程并没有遇到太大的阻挠。</p>
<p>后端是这个项目难度最大的点，面板需要管理一群docker虚拟容器，此前对于docker还仅停留在使用的程度，这是我从未接触过的领域，并且还要熟悉饥荒这款游戏的内容，模组，脚本等等，饥荒的游戏脚本大部分都是由lua编写的（还好以前了解过）。面对一堆的陌生的内容，在初期可以说是花费了大量的时间去查资料和学习（不得不感慨中文互联网信息实在太匮乏了），docker这部分有docker官方提供的Docker Engine API，饥荒这部分的资料来源是克雷官方的fortum论坛和百度贴吧论坛（贴吧老哥是真的强），以及一些饥荒有关的开源项目（感谢开源）。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307081636532.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>到了写这篇文章的时候，项目功能已经全部完成，总计125个接口，只剩下最后的一点测试。一路过来也是挺不容易的，在推进项目的过程中还要兼容学校的课程，期末了还要考试，不过到最后还是在暑假初期结束这个项目。</p>
<h2> 技术栈</h2>
<p>项目本身是前后端分离的，前端主要采用的vue3框架，后端采用go作为开发语言。</p>
<h3> 结构</h3>
<figure><img src="https://apifox.com/api/v1/projects/2672982/resources/388681/image-preview" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h3> 前端</h3>
<ul>
<li>框架：Vue3</li>
<li>构建工具：Vite</li>
<li>开发语言：TypeScript</li>
<li>脚手架：Vben-amdin <a href="https://github.com/vbenjs/vue-vben-admin" target="_blank" rel="noopener noreferrer">Github 开源地址</a></li>
<li>Ajax：Axios</li>
<li>状态管理：pinia</li>
<li>路由：Vue-Router-Next</li>
<li>UI组件库：Ant-Design-Vue</li>
</ul>
<h3> 后端</h3>
<ul>
<li>开发语言：Go 1.20.2</li>
<li>Http框架：Gin</li>
<li>数据库：Mysql，Redis</li>
<li>ORM：GORM</li>
<li>认证：JWT</li>
<li>配置管理：viper</li>
<li>权限管理：casbin</li>
<li>日志框架：zap</li>
<li>定时任务：robfig/cron</li>
</ul>
<h3> 数据库</h3>
<p>mysql主要是用于存放一些结构化的信息，例如api权限表，用户信息，实例信息，策略信息以及端口映射等等，这个项目的表结构并不复杂，就七张表，</p>
<p>因为大部分信息都是直接从dockerapi中读取的，系统本身并不需要存放什么过多的数据。</p>
<p>redis主要用于存放一些非结构化的信息，系统分发的token和密钥，用于主动过期处理，另外还会存放每一个实例的模组下载信息，以及系统设置。redis数据格式相对mysql而言较为松散，没有那么严格的结构，项目均是采用json格式存放的redis数据。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307081658970.png" alt="测试服的界面" tabindex="0" loading="lazy"><figcaption>测试服的界面</figcaption></figure>
<h2> 主要难点</h2>
<p>下面这些难点是困扰我比较久的，虽然每一个点描述的比较少，但实际上为了解决它们，我花费了相当多的时间去试错和测试。</p>
<h3> 实例资源限制</h3>
<p>容器即实例，资源限制这一块是docker利用docker提供的支持，在最开始了解时，发现有两种方法，一种是使用devicemapper驱动的LVM，另一种是使用overlay2驱动的xfs文件系统的quota功能。项目选择了devicemapper，因为了解的早一些，不过docker官方在后续版本声明devicemapper驱动可能会停止维护了。</p>
<h3> 创意工坊模组</h3>
<p>模组是这个游戏相当重要的一块功能，这部分主要是借助steamcmd和SteamWebApi来解决的，一部分模组会直接提供url以供下载，另一部分则需要使用steamcmd来进行下载。</p>
<h3> 模组信息解析</h3>
<p>饥荒的模组都是由lua脚本编写的，项目采用了一个开源的由go编写的lua虚拟机，通过lua虚拟机来解析模组信息，将lua信息解析成go对象。</p>
<h3> 世界设置解析</h3>
<p>这一部分应该算得上是最繁杂的了，最初想的是一个个手动维护配置项，但是多大两百个的配置项让人望而却步。后来需要去读取游戏文件的中的tex文件，将其转换成图片格式的文件，然后再读取游戏脚本以获取文本翻译和世界配置的每一个配置项。</p>
<h3> 服务端管理</h3>
<p>一个饥荒服务器有两个服务端，地面服务端与洞穴服务端，使用screen进行管理，通过将预先编写好的管理脚本打包到镜像中，后续的管理就变得相当方便。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202307081548886.png" type="image/png"/>
    </item>
    <item>
      <title>go后端日期时区的问题记录</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/gotime.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/gotime.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">go后端日期时区的问题记录</source>
      <description>go后端日期时区的问题记录 记录一次go后端日期时区问题的记录</description>
      <category>问题记录</category>
      <pubDate>Sat, 01 Jul 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> go后端日期时区的问题记录</h1>
<p>记录一次go后端日期时区问题的记录</p>
<!-- more -->
<hr>
<p>在通常的前后端交互中，日期是一个经常很令人头痛的问题，需要统一格式，统一时区等等。</p>
<p>在最近的一个项目中，前端根据<code>YYYY/MM/DD hh:mm:ss</code>格式传给后端，后端解析成<code>time.Time</code>类型，但是这犯了一个很严重的错误。</p>
<p>在解析日期字符串时，如果没有按照格式传递时区偏移，例如<code>+0800 CST</code> 等格式，go将会默认解析为<code>+0000 UST</code>的时区，由于数据库设置为了同步设置了东八区，一看传过来的数据是UST时区的，就误认为需要修正时区，结果就是存储到数据库的数据会比实际时间多出八小时。</p>
<p>解决办法1：</p>
<p>前端在传递给后端日期时，前端自己带上时区信息，<code>+0800 CST</code>类似这种</p>
<p>解决办法2：</p>
<p>后端根据客户端请求头中的时区信息， 将传递过来的日期加上时区信息</p>
<p>当添加上正确的时区信息过后，时间的读写才会是正常的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>docker内存显示异常的bug</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/dockermem.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/dockermem.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">docker内存显示异常的bug</source>
      <description>docker内存显示异常的bug 源于项目开发过程中的一个发现</description>
      <category>问题记录</category>
      <pubDate>Thu, 29 Jun 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> docker内存显示异常的bug</h1>
<p>源于项目开发过程中的一个发现</p>
<!-- more -->
<hr>
<p>此前接了一个开发饥荒虚拟容器管理平台的项目，其中有一个功能就是实时显示容器的内存使用状况，后来奇怪的发现容器的内存趋势图在容器创建后的5分钟内达到了几乎100%</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202306292022189.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>初次遇到这个问题，百思不得其解，以为是自己程序的编写错误，后来在容器中<code>top</code>了一下发现真实占用可能就40%左右。后面去翻阅了docker cli计算内存占用的源代码，<a href="https://github.com/moby/moby/blob/eb131c5383db8cac633919f82abad86c99bffbe5/cli/command/container/stats_helpers.go#LL110C62-L110C62" target="_blank" rel="noopener noreferrer">Docker Cli 计算内存源代码地址</a>，逻辑基本上是一致，那么只剩一种可能，这的确就是docker的bug。</p>
<p>在经过测试后，这个bug诱发的原因是饥荒容器在创建时会下载一个接近4个g的游戏服务端，在此过程中会消耗一定的资源，内存占用会逐渐攀升，但是等到下载完毕后增长的趋势依旧不停，从而造成了内存虚高。</p>
<p>为此编写了一个测试，这在github的issue里有更详细的介绍，<a href="https://github.com/moby/moby/issues/45727" target="_blank" rel="noopener noreferrer">issue address</a></p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202306292022189.png" type="image/png"/>
    </item>
    <item>
      <title>64位Ubuntu上运行32位可执行文件</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/linuxexe.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/linuxexe.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">64位Ubuntu上运行32位可执行文件</source>
      <description>64位Ubuntu上运行32位可执行文件 记录64位Ubuntu上运行32位可执行文件的问题</description>
      <category>问题记录</category>
      <pubDate>Sat, 08 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 64位Ubuntu上运行32位可执行文件</h1>
<p>记录64位Ubuntu上运行32位可执行文件的问题</p>
<!-- more -->
<hr>
<p>最近在捣鼓Steamcmd开游戏专用服务器，下载下来的tar包中，解压出来的steamcmd可执行文件是32位的，命令如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当时的使用系统uname如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>64位系统是无法直接运行32位可执行文件的，最开始半天不知道怎么回事，一直报<code>No such file and directory</code>，发现问题后下载32位依赖运行库即可</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下载完成后即可正常运行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>在Linux搭建DST专用服务器</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/dst.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/dst.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">在Linux搭建DST专用服务器</source>
      <description>在Linux搭建DST专用服务器 本文主要讲解了如何在Linux环境下搭建Dont Starve Together的专用服务器，以及一些坑。</description>
      <category>技术日志</category>
      <pubDate>Sun, 09 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 在Linux搭建DST专用服务器</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304091448764.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本文主要讲解了如何在Linux环境下搭建Dont Starve Together的专用服务器，以及一些坑。</p>
<!-- more -->
<hr>
<h2> 环境准备</h2>
<p>在开始之前需要准备以下东西：</p>
<ul>
<li>一台装了Linux系统的云服务器，本文使用的是Ubuntu20LTS。</li>
<li>SSH客户端，本文使用的XShell</li>
<li>SFTP客户端，本文使用的是FillZilla</li>
</ul>
<p>云服务器安全组要放行10800到12000范围端口，饥荒服务端差不多都在这个范围内，协议使用UDP。</p>
<h2> 创建用户</h2>
<p>与服务器进行ssh连接过后，创建一个专门用于DST管理的用户，这样与系统隔离，方便后续管理。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后进入dst的ssh目录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成ssh密钥对，将公钥注册到服务器中</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>把私钥保存下来这样后续就可以使用ssh私钥进行登录。</p>
<h2> 依赖准备</h2>
<p>首先首先要给软件管理工具加一个i386的架构，有warning忽略掉，然后看看加进去没有</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后再下载所需要的32位依赖</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述依赖是必须安装的，否则在运行可执行文件时会报错无法找到文件。</p>
<h2> 安装SteamCMD</h2>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如何在Linux上安装SteamCMD官方有非常详细的中文教程，<a href="https://developer.valvesoftware.com/wiki/SteamCMD:zh-cn" target="_blank" rel="noopener noreferrer">Steam 控制台客户端 - Valve Developer Community (valvesoftware.com)</a></p>
</div>
<p>先切换到dst用户</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后下载SteamCMD压缩包</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将其解压到steam目录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后进入steam目录执行steamcmd.sh脚本启动进行安装</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>或者也可以直接下载软件包，然后再启动steamcmd</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>等待安装完成后在steamcmd里面执行如下命令来设置安装目录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>需要注意的是设置安装目录必须在登录之前操作，登陆后不能再修改该项</p>
</div>
<p>然后再登录steam，一般使用匿名登录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>等待登录完成后下载饥荒服务端，343050是它的appid，这里大概要等个几分钟，下载完毕后先退出。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>进入到server目录下看看是不是安装到指定目录了，如下就说明安装成功了</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 开服</h2>
<p>前往克雷官网，登录并注册申请服务器token</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304092018313.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>点击添加新的服务器</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304092018095.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>完成后点击下载设置，使用sftp将该文件夹传入<code>/home/dst/.klei/DoNotStarveTogether</code>目录下，这是默认的存档位置，没有这个文件夹就自行创建该文件夹。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304092020790.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>然后需要下载一个多终端管理工具screen</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后在<code>/home/dst</code>目录下创建<code>master.sh</code>和<code>caves.sh</code>，内容如下</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后运行脚本即可，如下</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304092026834.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>当两个maser终端和caves终端都输出sim paused时，说明开服成功，进入游戏在搜索你设置的服务器名称</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304092028986.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>能够搜索到并成功进入服务器，说明服务器搭建完毕。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304091448764.png" type="image/png"/>
    </item>
    <item>
      <title>VuePress使用百度统计分析网站流量</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/statistic.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/statistic.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">VuePress使用百度统计分析网站流量</source>
      <description>VuePress使用百度统计分析网站流量 VuePress结合百度统计，分析网站的访问情况</description>
      <category>技术日志</category>
      <pubDate>Tue, 12 Jul 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> VuePress使用百度统计分析网站流量</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021705229.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>VuePress结合百度统计，分析网站的访问情况</p>
<!-- more -->
<hr>
<p>关于网站统计和分析，常用的有如下这些服务商，统计系统主要只是统计数据，分析系统在统计的同时还可以进一步分析数据，对于我而言仅仅只是需要统计一下网站的访问量即可，所以选择统计系统。</p>
<figure><img src="https://picx.zhimg.com/80/45924912141b6a0162c61cf7e0764b5f_1440w.webp?source=1940ef5c" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>本文主要讲的是百度统计，国内使用起来方便一些，虽然百度统计有些功能下线了，可能是因为业务不行吧，但是对我这种轻度用户来说足够使用了，谷歌分析会涉及到一些翻墙的事情。</p>
<h2> 注册</h2>
<p>百度统计：<a href="https://tongji.baidu.com/web5/10000539386/welcome/login" target="_blank" rel="noopener noreferrer">百度统计——一站式智能数据分析与应用平台 </a>，首先前往百度统计页面，登录账号，完成后进入产品即可，个人开发者使用免费版即可。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021714418.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 新增网站</h2>
<p>来到<strong>使用设置/网站列表</strong>页面，点击新增网站</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021715003.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>按照你自己的网站信息去填写表单</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021716906.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h2> 获取代码</h2>
<p>添加成功后，来到代码管理，复制生成的JS代码</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021719873.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>如果只是一般的HTML页面，可以选择直接将复制后的代码放入<code>index.html</code>中的<code>&lt;head&gt;</code>标签内，但我是用的VuePress，不可能每次编译完后手动加到生成的<code>index.html</code>中，所以找到项目中的配置文件<code>.vuepress/config.ts</code>，像如下编写即可。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>VuePress复制代码时不需要<code>&lt;script&gt;</code>标签</p>
</div>
<h2> 安装检查</h2>
<p>上述操作弄完后，将网站重新部署，然后在使用设置页面的网站列表点击安装检查</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021726479.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一般在部署完十几分钟后可以正常使用，如果代码安装检查失败可以检查一下是不是在外网或者域名填写错误。</p>
<h2> 统计查看</h2>
<p>在网站概况中可以很清晰的看到网站的浏览量趋势统计和图表</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021729234.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>也可以看到访问者的地域分布统计</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304022049101.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>对于我的小站来说，上述功能已经足够使用了，更多功能的话还请自己去慢慢发现。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021705229.png" type="image/png"/>
    </item>
    <item>
      <title>神界原罪2</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/divinity.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/divinity.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">神界原罪2</source>
      <description>神界原罪2 一款十分精彩的RPG，不论是战斗还是剧情都很出色。</description>
      <category>游戏杂谈</category>
      <pubDate>Sun, 02 Apr 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 神界原罪2</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021221784.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一款十分精彩的RPG，不论是战斗还是剧情都很出色。</p>
<!-- more -->
<hr>
<p>其实这款游戏我很早就听说它的大名了，但是直到最近才开始打算正式的去体验一下，最后历时71个小时通关了该作。在当今快节奏的时代，各种游戏都在越来越趋于快餐化，力求让玩家能够以更少的操作得到更好的体验，神界原罪2显然并不属于此类，作为一款比较传统的RPG游戏，如果不静下心来体验，那么将会错过非常多的细节和剧情，同样的也会丧失很多乐趣。</p>
<h2> 背景设定</h2>
<figure><img src="https://imgsa.baidu.com/forum/pic/item/6d288498a9014c08ef8fcd1c047b02087af4f4e5.jpg" alt="二代故事舞台只是绿维珑一个很小的部分" tabindex="0" loading="lazy"><figcaption>二代故事舞台只是绿维珑一个很小的部分</figcaption></figure>
<p>故事发生在一个名为绿维珑的大陆上，大陆上的七个神根据自己的模样创造了主要的种族，分别是人类，精灵，矮人，侏儒，蜥蜴人，兽人这六个主要种族。人族数量最多，遍布世界各地，精灵生活在森林里，寿命十分长寿，矮人强壮有力，科技也很发达，蜥蜴人的古代帝国历史十分悠久，同样也是一个非常强大的势力，侏儒在这个世界观里面属于是科技最发达的一个种族，甚至造出了”计算机“，兽人的存在感最弱。世界上有一种物质叫秘源，体内拥有这种物质的人被称为秘源术士，有的是强大的魔法师，或是骁勇善战的战士，抑或是百步穿杨的弓箭手。秘源的使用会导致世界帷幕的破碎，从而引来了另一个世界的生物--虚空异兽，为了抵抗虚空，七神献出了各自一半的力量交给最强的秘源术士--神谕者，让他来领导世界抵抗虚空世界，然而上述只是七神的洗脑版本。真实情况是，在很久以前，一位永生族的学者研究发现了世界帷幕的存在，从帷幕上可以获得秘源的力量，而帷幕的另一边就是虚空，他向神王报告了此事，但是神王觉得虚空太过危险，于是下令停止研究。但是神王下属的七个领主却找到了这名学者，获取了帷幕的力量，将神王和永生族人全部打入了虚空，永生族人全都变成了虚空异兽，七领主将自己包装成了神的模样并创造了自己的种族，并让他们的种族信仰自己，这就是神的原罪。而在几千年后，一个名为温迪戈的秘源术士引发了一场灾难，事后被神谕教团押往欢乐堡，在前往欢乐堡的复仇女神号船上，主角们的故事就正式开始了。</p>
<h2> 主角团</h2>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021221784.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>主角团六人分别是沉睡了千年的永生族亡灵费恩，因曾经被奴役而踏上复仇之路的精灵希贝儿，体内寄宿着恶魔而走上驱魔之路的歌手洛思，曾经参加黑环战争导致精灵种族大灭绝而心灰意冷的孤狼雇佣兵伊凡，被恶魔蛊惑导致驱逐出王室蜥蜴人猩红王子，反抗矮人女王暴政失败而流落当海盗的矮人贵族比斯特，游戏剧情本身是一部群像剧，六个开始毫无关联的秘源术士，在冒险的过程中会产生各种羁绊，他们的过往经历和剧情相互交错，最终都会汇聚到一起，踏上了同一个征途 -- 成为神谕者。</p>
<h2> 任务系统</h2>
<p>该作的任务引导很弱，并不像育碧那种直接在地图上标明了该去哪里，要做什么步骤，为了能让玩家更有代入感，游戏选择了以一种日记的方式来记录每一个任务推进的过程，玩家每发现一条线索或者是触发了什么事件都会被记录在日记上。虽然游戏本身是开放世界地图，但是每一个任务并不会告诉你该去哪里该怎么做，所有任务的细节和流程全部都隐藏在大量的NPC文本对话中。这样做的好处是，可以让玩家更见能够带入主角的视角来体验剧情，同样的缺点也很明显，由于游戏本身非常自由，任务的弱引导经常过导致玩家到处闲逛不小心触发了一个剧情线，而提前开启该线可能会导致原本的支线流程失败或者没有达到想要的结果等等后果，我本身在玩的时候就经常会出现这种情况，不过在第一章过后熟悉了游戏本身的机制后就会习惯性非常留意每一个NPC所说的细节，也就不再会存在满地图乱跑的情况了。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021230410.png" alt="任务系统" tabindex="0" loading="lazy"><figcaption>任务系统</figcaption></figure>
<h2> 战斗系统</h2>
<p>游戏的战斗部分是回合制+策略战棋，角色开场拥有有限的行动点数，不论是移动，还是攻击还是释放技能，都会消耗行动点数，一些特殊技能还会消耗秘源点数。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021345009.png" alt="战斗部分" tabindex="0" loading="lazy"><figcaption>战斗部分</figcaption></figure>
<p>游戏中有很多不同的职业，每一个职业在属性天赋能力上都有着不同的权重，总体来说常见的流派分为法师，弓手，战士，刺客，辅助，召唤师这几个，除此之外还有一些邪门的流派比如陷阱流等等。游戏本身十分的自由，在中期后便可以无限的洗点，所以玩家可以随时随地的决定自己的职业。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021346878.png" alt="人物界面" tabindex="0" loading="lazy"><figcaption>人物界面</figcaption></figure>
<p>在游戏的前期，资源匮乏，可以学习的技能比较少，以平A为主的物理系职业比较吃香，到了中期地图浮木镇以后，法师的输出就开始成熟了，而到后期法师的伤害几乎是完爆物理职业。游戏中法师最强的一个技能，大地学派的大地之怒十分变态，即便是在最终战中，辅助将所有的怪聚集在一起后，只需要一个大地之怒便可以秒杀所有敌人结束战斗，足以可见其伤害有多么恐怖。</p>
<h2> 结语</h2>
<p>尽管游戏本身很优秀，但是后两章地图由于资金问题肉眼可见的质量明显下降，总体来说游戏体验最佳的部分就是第一章欢乐堡和第二章浮木镇，后期的战斗也变得相对比较无聊，但这些并不影响神界原罪2成为一款十分优秀的CRPG作品，甚至是该界的天花板。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021221784.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>血源诅咒</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/bloodborn.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/bloodborn.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">血源诅咒</source>
      <description>血源诅咒 心中永远的神作游戏，没有之一</description>
      <category>游戏杂谈</category>
      <pubDate>Sun, 01 Jan 2017 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 血源诅咒</h1>
<figure><img src="https://img.3dmgame.com/uploads/allimg/170717/316-1FGGG244.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>心中永远的神作游戏，没有之一</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://img.3dmgame.com/uploads/allimg/170717/316-1FGGG244.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>风来之国</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/eastward.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/eastward.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">风来之国</source>
      <description>风来之国 它让我想起了小时候躲在被窝里在捧着老式诺基亚玩的一款塞班像素游戏</description>
      <category>游戏杂谈</category>
      <pubDate>Mon, 20 Sep 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 风来之国</h1>
<figure><img src="https://blob.keylol.com/forum/202104/26/235332fwzmvhyw2brmbwcj.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>它让我想起了小时候躲在被窝里在捧着老式诺基亚玩的一款塞班像素游戏</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://blob.keylol.com/forum/202104/26/235332fwzmvhyw2brmbwcj.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>烟火</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/firework.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/firework.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">烟火</source>
      <description>烟火 一款小体量的恐怖游戏，像一本短暂又令人回味的小说</description>
      <category>游戏杂谈</category>
      <pubDate>Mon, 15 Mar 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 烟火</h1>
<img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/firework.jpg" style="zoom:200%;">
<p>一款小体量的恐怖游戏，像一本短暂又令人回味的小说</p>
<!-- more -->
<hr>
<p>正文</p>
]]></content:encoded>
    </item>
    <item>
      <title>古剑奇谭三：梦付千秋星垂野</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/gujianqitan.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/gujianqitan.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">古剑奇谭三：梦付千秋星垂野</source>
      <description>古剑奇谭三：梦付千秋星垂野 高中时在WebGame上掏钱买的一款国产游戏，应该是那段时间国产游戏行业的一道光</description>
      <category>游戏杂谈</category>
      <pubDate>Wed, 02 Jan 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 古剑奇谭三：梦付千秋星垂野</h1>
<figure><img src="https://th.bing.com/th/id/R.cd979e8c62da7290fde16c6080042814?rik=rxs41US0GuFXCQ&amp;riu=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F0837aafae38223909e07185b86185f6da5c75663.jpg&amp;ehk=LU2HP%2BnwwYcKlAGYQikcmnN3p8edyK67hv%2FRW%2Fo6EIg%3D&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>高中时在WebGame上掏钱买的一款国产游戏，应该是那段时间国产游戏行业的一道光</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://th.bing.com/th/id/R.cd979e8c62da7290fde16c6080042814?rik=rxs41US0GuFXCQ&amp;riu=http%3a%2f%2fi2.hdslb.com%2fbfs%2farchive%2f0837aafae38223909e07185b86185f6da5c75663.jpg&amp;ehk=LU2HP%2bnwwYcKlAGYQikcmnN3p8edyK67hv%2fRW%2fo6EIg%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" type="image/"/>
    </item>
    <item>
      <title>Minecraft</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/mc.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/mc.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Minecraft</source>
      <description>Minecraft 从小学就开始玩了，从啥都不会到自己搭建游戏服务器，再到自己编写游戏插件，踏上编程之路也全是因为它。</description>
      <category>游戏杂谈</category>
      <pubDate>Sun, 20 Sep 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Minecraft</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/mc.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>从小学就开始玩了，从啥都不会到自己搭建游戏服务器，再到自己编写游戏插件，踏上编程之路也全是因为它。</p>
<!-- more -->
<hr>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/mc.png" type="image/png"/>
    </item>
    <item>
      <title>僵尸毁灭工程</title>
      <link>https://246859.github.io/my-blog-giscus/posts/game/pzb.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/game/pzb.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">僵尸毁灭工程</source>
      <description>僵尸毁灭工程 一款十分真实的丧尸沙盒生存游戏，心中同题材下最好的游戏。</description>
      <category>游戏杂谈</category>
      <pubDate>Thu, 01 Dec 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 僵尸毁灭工程</h1>
<figure><img src="https://p.qpic.cn/mwegame/0/35174daa0ac19eea6357e12924a107ca/" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>一款十分真实的丧尸沙盒生存游戏，心中同题材下最好的游戏。</p>
<!-- more -->
<hr>
<p>有那么一段时间我比较沉迷于丧尸这个题材，不论是小说还是电影或者是游戏，在尝试了非常多的这类题材作品过后，最后发现了代入感最强的还是这一款名为《僵尸毁灭工程》的沙盒生存游戏。不过在稍微了解了这个游戏的历史后，发现它居然有好几年的制作历史了，并且一直在持续更新中，在创意工坊中有着大量的玩家自制的MOD可供使用，生态也算是非常的好了。</p>
<h2> 真实感</h2>
<figure><img src="https://pic4.zhimg.com/v2-aaa96d369f69d684eed906f8dddfe6b7_r.jpg" alt="僵毁中的医学人体图" tabindex="0" loading="lazy"><figcaption>僵毁中的医学人体图</figcaption></figure>
<p>虽然游戏本身的画面并不是特别出色，甚至角色还是多边形人，但是丝毫不会减少游戏的魅力--真实。游戏在很多地方都力求还原现实，比如角色遇到丧尸会害怕，当处于恐惧状态时，会跑的更快，但是攻击伤害会更低。当翻窗进废弃房屋搜寻物资时，需要注意窗户上是否有碎玻璃，否则会划伤身体，而清理玻璃必须要戴手套或者使用工具，否则徒手清理也会受伤。当玩家受伤时，需要进行及时的包扎和消毒，如果不及时照顾伤口可能会导致伤口感染，感染后就可能会增加恶化的几率，伤口过深可能会引起破伤风，这时候需要更加专业的医疗工具来进行治疗。当角色遇到的负面事情过多时，就会陷入抑郁状态，而过度抑郁会导致角色状态大幅度下降等等，上述所描述的这些也只是游戏中众多细节中的其中几种，正是这些看起来十分繁琐的细节促成了很强的沉浸感和代入感，玩家可以很直观的体会到一个普通人在面对丧尸危机大爆发的无力感和绝望感。</p>
<h2> 背景</h2>
<p>游戏在初代其实是想走线性流程这个方向，那时候是有固定的剧情，但是到了后续更新变成了开放世界沙盒模式，剧情也删减了很多，就现在而言几乎没有什么剧情，但是有一个基本的背景设定（顺便提一下游戏早期只有四个人开发，一路走来可以说是十分的励志）。僵尸毁灭工程的故事发生在上个世界90年代的美国肯塔基州，病毒爆发地点位于路易斯维尔市，也就是地图上右上角的那个大城市，在军方的生化实验室病毒泄露后，短短几天事情便发展到了不可控的地步，直到最后蔓延到了全球。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202304021913341.png" alt="肯塔基架空地图" tabindex="0" loading="lazy"><figcaption>肯塔基架空地图</figcaption></figure>
<p>而作为主角的玩家，只是一个平平无奇的普通人，唯一的目标就是搜寻资源并在这个末世活下去，除此之外游戏开始之后便不会再有任何的剧情。</p>
<h2> 流程</h2>
<p>游戏机制算得上十分复杂，玩家需要注意的东西挺多的，第一次玩可能会摸不着头脑，需要考虑到季节，天气，温度，时间，饥饿，口渴，疲劳，忧郁，无聊，受伤，负重等等。在正常的流程中，一般是7月9号夏天开局，你的职业可以是一个普通的上班族，也可以是警察或者是建筑工人，或者是退伍军人，在刚开始的几天仍然会正常播放电视节目和广播节目，彻底沦陷后整个世界只剩一片寂静。门外可能已经聚集了不少丧尸，这时手无寸铁的你需要利用手上一切可以使用的工具，溜出房子去寻找一个安全的庇护所。第一件要做的事就是武装自己，可以是平底锅，棒球棒，撬棍，或者是钢管，切记千万不要随便开枪，枪声会引来一大群丧尸，这反而会成为丧尸们的开饭铃。在找到武器后玩家需要将自己身体的重要部位保护起来，一旦被丧尸造成伤口后果是不堪设想的，你需要穿一些厚实的衣服，但注意别太暖和了，否则运动一小会你就会中暑。</p>
<p>当有了基本的自我保护能力后，你需要搜集食物和水源，因为不久后城市里就会断水断电，在超市和便利店里可能还会有一些其他幸存者没有搜刮完的食物，这些地方往往危机四伏，冰箱里的食物记得尽早食用，食物腐烂后会导致食物中毒，在医疗崩溃的条件下生病基本等同于死亡，这也是为什么即便再渴也不要随便引用来历不明的水。看见医疗物资一定要记得带上，末世下医疗物资十分珍贵，即便是感冒都可能要人命。居住的庇护所至少要有两层，因为在一楼沦陷的情况下还可以从二楼逃跑，切记时刻给自己留退路，在睡觉的时候一定要记得关门，没有人知道夜里会发生什么事情，在丧尸入侵庇护所后，如果尸体过多不清理掉，很有可能会导致你感染。在完全的断水断电后，对于水源你可以接雨水或者到河边取水后煮沸了再饮用，对于食物你可以不断的出去搜寻物资，或者将找到的种子耕种成农作物自给自足。在基本的稳定下来后，你可以短暂的放松一下了，长时间神经的紧绷会让你十分敏感，这可能会导致抑郁，尝试看录像带或者看漫画来缓解和放松心情。在外出搜寻的过程中，你可能会偶尔听到直升机的声音，在看到直升机后千万不要像个傻子一样大声呼救，马上躲到建筑物内不要让它发现。新闻直升机在发现你后并不会实施救援，而一直盘旋在你头顶拍摄新闻素材，尤其喜欢拍摄幸存者被丧尸撕咬的画面，螺旋桨所发出的巨大噪声会把几乎半个城市的丧尸全部吸引过来，这时候你基本上就是死路一条。</p>
<p>在解决了温饱过后，如果你运气好在废弃房子的仓库里搜到发电机，那么你可以去所剩无几的加油站的油箱中加油，这样一来你的房子就可以使用冰箱和厨具了，切记发电机产生的气体是有毒的，你需要将它放在室外。如果能找到一辆还能开的车就更完美了，开车的时候注意不要开太快，否则出了车祸后果将不堪设想，不要开车去撞丧尸，因为车的损耗承受不起，在开车回家时不要发出太大的噪声，否则你只会把丧尸引到庇护所去。大城市里面虽然物资丰富，但几乎遍地丧尸，小镇虽然物资少，但是更加安全，切记物资再珍贵也没有命贵。有些丧尸生前是运动员，奔跑的速度非常快，遇到这类丧尸一定要避开。在探索建筑物时，每一道门后面都可能藏有危险，切记不要拿脸开门。有时候野外并不一定就比城市更加安全，夜晚的树林同样危机四伏。如果在深山老林中碰巧发现了军事基地，拿到强大的武器后，你就拥有了与尸潮一战的能力。丧尸们总是会有规律的活动，在一个月的某几天，它们的数量会达到顶峰，这是最危险的时候，丧尸会如潮水般向你的庇护所袭来，你需要奋战到最后一刻来保护你的基地。如果失守了，也不要忘了留得青山在，不怕没柴烧。</p>
<figure><img src="https://ts1.cn.mm.bing.net/th/id/R-C.c02ad2d0d95f4872067737420690445c?rik=HqY%2B09mKPj3gkA&amp;riu=http%3A%2F%2Fi2.hdslb.com%2Fbfs%2Farchive%2F52b46f10c9537dee758573433c55ab3794d26ab9.jpg&amp;ehk=vmotHDavUbFII%2BqgBVfvhlRMoWRkkcKj8FGGAOm%2FiEk%3D&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>最后，你在这艰难的末世中顽强的存活了下来，此时病毒已经蔓延到了世界各地，整个世界一片寂静，就算你每天开着收音机也不会有任何回应。对于这绝望的世界，你可以开枪了解自己来结束这痛苦的一生，或者是带着一整车物资外出寻找新的希望，也可以带着武器前往大型商场享受屠杀丧尸的最后狂欢，不论选择哪一种，末世都始终会持续下去，当你死后，会有新的幸存者会继承你的意志并继续活下去。</p>
<h2> 结语</h2>
<p>同样的题材也有很多优秀的游戏，即便僵毁画面很复古，但是僵尸毁灭工程满足了我一切对于末世的幻想，非常对我的胃口，在我心目中就是最好的丧尸题材游戏，美中不足的是游戏中人类NPC和动物几乎没有出现，互动也很少，不过这些可以通过加入第三方MOD来添加更多有趣的玩法。</p>
]]></content:encoded>
      <enclosure url="https://p.qpic.cn/mwegame/0/35174daa0ac19eea6357e12924a107ca/" type="image/"/>
    </item>
    <item>
      <title>Typora配合图床搭建教程</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/pic.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/pic.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Typora配合图床搭建教程</source>
      <description>Typora配合图床搭建教程 Typora配合搭建完毕后的图床，可以有效的解决的md文件的图片引用问题。</description>
      <category>技术日志</category>
      <pubDate>Fri, 24 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Typora配合图床搭建教程</h1>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/wallhaven-953v9d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Typora配合搭建完毕后的图床，可以有效的解决的md文件的图片引用问题。</p>
<!-- more -->
<hr>
<p>Typroa是一款很流行的Markdown编辑器，但是苦图片引用问题久矣，本地编写好的md文件发送给别人后，就好经常出现图片丢失问题，这种情况下只有两个方法：</p>
<ul>
<li>把图片一起打包</li>
<li>引用在线图片</li>
</ul>
<p>一起打包显然会使得文件变得非常臃肿，在线图片也并不好找，同样的上述情况也适用于各个Markdown静态文档生成框架，举例VuePress，每个框架对于静态图片的引用都有着不同的规则，假设日后更换其他的框架图片引用问题将会非常的令人头疼。所以对于个人开发者而言，非常有必要搭建个人图床。</p>
<br>
<h2> PicGo</h2>
<p><strong>一个用于快速上传图片并获取图片 URL 链接的工具</strong>，支持许多云服务商的对象存储，例如阿里云，腾讯云，七牛云等等，同时也支持Gitee，Github，软件技术基于Vue+Electron。</p>
<p>PicGo下载：<a href="https://github.com/Molunerfinn/PicGo#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85" target="_blank" rel="noopener noreferrer">Molunerfinn/PicGo: A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder (github.com)</a></p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324201548045.png" alt="image-20230324201548045" tabindex="0" loading="lazy"><figcaption>image-20230324201548045</figcaption></figure>
<p>下载完成后，打开是下面这个样子。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324201612971.png" alt="image-20230324201612971" tabindex="0" loading="lazy"><figcaption>image-20230324201612971</figcaption></figure>
<p>这个是最简陋的版本，一个个手动上传肯定是很累的，这里打开Typora的设置（如果是其他Markdown编辑器应该也是同理）</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324201808929.png" alt="image-20230324201808929" tabindex="0" loading="lazy"><figcaption>image-20230324201808929</figcaption></figure>
<p>但此时PicGo还未配置成功，点击验证图片上传肯定是会失败的，接下来有两个选择。</p>
<h2> GItee</h2>
<p>这里之所以使用Gitee而不使用Github，主要是Github国内的访问速度太感人了，想要达到正常速度必须自行搭建CDN，所以这里利用一下免费的GItee。不过Gitee前不久已经加了防盗链，如果是在网站上引用图床肯定是会失效的，但如果只是在本地Markdown文件引用依旧可以成功。</p>
<h3> 创建仓库</h3>
<p>首先需要创建一个<strong>公开</strong>的仓库，不公开访问不了，名称建议英文，最好不要带特殊符号。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324202452126.png" alt="image-20230324202452126" tabindex="0" loading="lazy"><figcaption>image-20230324202452126</figcaption></figure>
<h3> 私人令牌</h3>
<p>接下来要获取私人令牌</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324202548316.png" alt="image-20230324202548316" tabindex="0" loading="lazy"><figcaption>image-20230324202548316</figcaption></figure>
<p>在个人设置中创建一个私人令牌。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324202639749.png" alt="image-20230324202639749" tabindex="0" loading="lazy"><figcaption>image-20230324202639749</figcaption></figure>
<p>描述随意，建议只放开这几个权限，生成后记住你的私人令牌。</p>
<h3> 下载插件</h3>
<p>打开PciGo软件，点开插件设置，搜索Gitee，下载gitee-Uploader。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324202915702.png" alt="image-20230324202915702" tabindex="0" loading="lazy"><figcaption>image-20230324202915702</figcaption></figure>
<p>等待安装完毕后，在图床设置中填写gitee的配置项</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324203304435.png" alt="image-20230324203304435" tabindex="0" loading="lazy"><figcaption>image-20230324203304435</figcaption></figure>
<p>完成后点击确认，并设置为默认图床，然后到上传区测试结果即可</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202303242051716.png" alt="image-20230324205101674" tabindex="0" loading="lazy"><figcaption>image-20230324205101674</figcaption></figure>
<br>
<h2> 腾讯云Cos</h2>
<p>作者恰好前不久买了腾讯云对象存储的资源包，就刚好拿来当图床用，其他云服务商的配置过程都是类似的。首先在对象存储控制台中访问密钥</p>
<h3> 申请密钥</h3>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324203515364.png" alt="image-20230324203515364" tabindex="0" loading="lazy"><figcaption>image-20230324203515364</figcaption></figure>
<p>然后前往密钥界面</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324203613705.png" alt="image-20230324203613705" tabindex="0" loading="lazy"><figcaption>image-20230324203613705</figcaption></figure>
<p>记住<code>APPID</code>，<code>SecretId</code>，<code>SecretKey</code></p>
<h3> 创建桶</h3>
<figure><img src="https://gitee.com/FLoat1024/pic/raw/master/img/image-20230324204211170.png" alt="image-20230324204211170" tabindex="0" loading="lazy"><figcaption>image-20230324204211170</figcaption></figure>
<p>在创建存储桶时必须要保证桶的权限是公共读私有写，也就是可以匿名访问，记住<code>BucketId</code>和区域后就可以前往PicoGo中填写配置。</p>
<h3> 填写配置</h3>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324203822706.png" alt="image-20230324203822706" tabindex="0" loading="lazy"><figcaption>image-20230324203822706</figcaption></figure>
<p>填写完配置项后确认并设置为默认图床，然后在上传区测试即可。</p>
<figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/image-20230324203857990.png" alt="image-20230324203857990" tabindex="0" loading="lazy"><figcaption>image-20230324203857990</figcaption></figure>
<br>
<h2> 最后</h2>
<p>配置完成后的效果是Typora直接复制图片就会上传到个人图床，这样日后文件迁移也会方便的多，当然前提是得有一个稳定的图床。</p>
]]></content:encoded>
      <enclosure url="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/wallhaven-953v9d.png" type="image/png"/>
    </item>
    <item>
      <title>VuePress博客教程</title>
      <link>https://246859.github.io/my-blog-giscus/posts/code/vuepresshope.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/code/vuepresshope.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">VuePress博客教程</source>
      <description>VuePress博客教程 VuePress是一个vue驱动的静态网站生成器，非常适合来写静态文档，当然也可以拿来编写个人博客，配合第三方开发的主题可以做出非常精美的静态网站。</description>
      <category>技术日志</category>
      <pubDate>Tue, 12 Jul 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> VuePress博客教程</h1>
<figure><img src="https://vuepress.vuejs.org/hero.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>VuePress是一个vue驱动的静态网站生成器，非常适合来写静态文档，当然也可以拿来编写个人博客，配合第三方开发的主题可以做出非常精美的静态网站。</p>
<hr>
<!-- more -->
<br>
<p>本文主要介绍的是如何使用VuePress编写个人博客，由于默认主题比较的简洁，可以考虑采用第三方主题，这里推荐使用<a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a>，它有以下优点：</p>
<ul>
<li>开箱即用</li>
<li>完整的博客功能</li>
<li>markdown增强</li>
<li>文章信息统计</li>
<li>众多插件支持</li>
<li>图片预览</li>
<li>Vue3+TypeScript</li>
<li>以及众多的其他优点</li>
</ul>
<p>该主题提供非常多的功能，可以让省去很多麻烦的配置，专注于文档编写，并且该主题作者也是VuePress项目成员之一。</p>
<br>
<h2> 安装</h2>
<p>创建vuepress-theme-hope 项目，选择你自己的包管理器：</p>

<p>过程中会要求配置一些东西，过程中会有一个选项选择项目类型，<code>blog</code>博客或者<code>docs</code>文档，根据自己的需求选择就好，然后等待一会儿就可以完成项目的创建。</p>
<br>
<h2> 配置</h2>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成项目创建后，<code>.vuepress</code>是项目的配置文件夹，下面是一些文件夹的作用：</p>
<ul>
<li><code>.cahce</code> ：用于缓存文件的文件夹</li>
<li><code>.temp</code>：存放临时文件的文件夹</li>
<li><code>dist</code>：存放打包文件的文件夹</li>
<li><code>public</code>：存放公共静态资源的文件夹</li>
<li><code>navbar</code>：存放导航栏配置的文件夹</li>
<li><code>sidebar</code>：存放侧边栏配置的文件夹</li>
<li><code>styles</code>：存放项目的样式文件</li>
<li><code>config.ts</code>：主要配置文件</li>
<li><code>theme.ts</code>：项目主题配置文件</li>
</ul>
<p>对于博客而言，首先需要确保<code>theme.ts</code>文件内的插件配置<code>blog</code>项为<code>true</code></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 主页</h3>
<p><code>REAMDE.md</code>也要根据博客来进行相应的修改</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于博客主页的详细的<code>Frontmatter</code>配置可以前往<a href="https://theme-hope.vuejs.press/zh/config/frontmatter/blog-home.html" target="_blank" rel="noopener noreferrer">博客主页 Frontmatter 配置 | vuepress-theme-hope (vuejs.press)</a>。</p>
<br>
<h2> 图片</h2>
<p>vuepress-theme-hope主题对于图片有很好的支持，且支持：</p>
<ul>
<li>左右滑动按顺序浏览页面内其他的图片</li>
<li>查看图片的描述</li>
<li>对图片进行缩放</li>
<li>全屏浏览图片</li>
<li>下载图片</li>
<li>分享图片</li>
</ul>
<p>在编写md文件时，只需要将文件放入<code>public</code>文件夹内，然后通过<code>/</code>开头的路径访问即可，例如<code>test</code>图片位于<code>/public/test/test.png</code>，那么对于的markdown如下</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当在主题选项中设置 <code>plugin.mdEnhance.imgSize: true</code> 时，可以使用 <code>=widthxheight</code> 指定图像大小。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更多图片用法可以前往<a href="https://theme-hope.vuejs.press/zh/guide/markdown/image.html" target="_blank" rel="noopener noreferrer">图片 | vuepress-theme-hope (vuejs.press)</a>。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>这里需要注意的是，该主题摘要部分的图片渲染有点问题，所以建议使用Gitee作为图床，Github搭建站点。</p>
</div>
<br>
<h2> 博客页面路径</h2>
<p>博客提供的默认路径如下，如果它们与你的已有路径发生冲突，并且你不想调整自己的路径，你可以对它们进行修改。</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>描述</th>
<th>默认路径</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>article</code></td>
<td>文章列表</td>
<td><code>/article/</code></td>
</tr>
<tr>
<td><code>category</code></td>
<td>分类地图页</td>
<td><code>/category/</code></td>
</tr>
<tr>
<td><code>categoryItem</code></td>
<td>特定分类列表</td>
<td><code>/category/:name/</code></td>
</tr>
<tr>
<td><code>tag</code></td>
<td>标签地图页</td>
<td><code>/tag/</code></td>
</tr>
<tr>
<td><code>tagItem</code></td>
<td>特定标签列表</td>
<td><code>/tag/:name/</code></td>
</tr>
<tr>
<td><code>star</code></td>
<td>星标文章列表</td>
<td><code>/star/</code></td>
</tr>
<tr>
<td><code>timeline</code></td>
<td>时间线列表</td>
<td><code>/timeline/</code></td>
</tr>
</tbody>
</table>
<h2> Markdown增强</h2>
<p>这块功能特别强大，东西非常多，建议去官网自己看。<a href="https://theme-hope.vuejs.press/zh/guide/markdown/intro.html" target="_blank" rel="noopener noreferrer">启用 Markdown 增强 | vuepress-theme-hope (vuejs.press)</a></p>
<br>
<h2> 文章信息</h2>
<p>使用<code>frontmatter</code>可以控制文章的一些基本属性，下面是一个例子。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>date</code>：日期</p>
<p><code>article</code>：是否添加进文章列表</p>
<p><code>start</code>：是否收藏，也可以是数字，数字越大排序权重越高</p>
<p><code>sticky</code>：是否置顶，也可以是数字，数字越大排序权重越高</p>
<p><code>category</code>：分类，YAML列表格式</p>
<p><code>tag</code>：标签，YAML列表格式</p>
<p>更多配置项可以前往<a href="https://theme-hope.vuejs.press/zh/config/frontmatter/info.html" target="_blank" rel="noopener noreferrer">信息 Frontmatter 配置 | vuepress-theme-hope (vuejs.press)</a>。</p>
<h2> 功能</h2>
<h3> 阅读时间</h3>
<p>配置<code>theme.tx</code>下的<code>plugins.readingTime.wordPerMinute</code>，如下</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br>
<h3> 评论</h3>
<p>主题支持Gisus，Waline，Twikoo，Artalk，四种评论插件，这里为了方便我们就采用Giscus，利用GitHub dicussion制作的评论，其他三种都需要额外去对应官方申请应用，Giscus是完全开源免费的，对于我们个人博客而言已经完全足够使用了。</p>
<ul>
<li><a href="https://giscus.app/zh-CN" target="_blank" rel="noopener noreferrer">giscus主页</a></li>
<li><a href="https://plugin-comment2.vuejs.press/zh/config/giscus.html" target="_blank" rel="noopener noreferrer">Giscus 选项 | 评论插件 (vuejs.press)</a></li>
</ul>
<p>前提是你需要先安装 <a href="https://github.com/apps/giscus" target="_blank" rel="noopener noreferrer">Giscus App</a>，使其有权限访问对应仓库，然后需要创建一个公开的GitHub仓库，并且开启Discussion功能，在仓库中的settings中开启即可。然后在Giscus官网中填写仓库名称，和分类，还有一些配置项，根据自己的喜好来即可，最后giscus会生成一个<code>&lt;script&gt;</code>标签，不过我们并不需要该标签，只需要获取其中的<code>data-reop</code>，<code>data-repo-id</code>，<code>data-category</code>，<code>data-category-id</code> 这四个属性即可。然后填入<code>theme.ts</code>中的<code>plugins</code>项中，如下：</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除此之外还有一些其他的外观配置项，请自行了解，配置完毕后重启应用，访问一篇文章通过Oauth2登录Github即可评论。</p>
<br>
<h2> 插件</h2>
<p>vuepress-theme-hope提供了许多可以使用的主题，这些主题都需要额外的安装才能使用，下面是一些常用的主题。</p>
<br>
<h3> 搜索</h3>
<p>安装 <code>vuepress-plugin-search-pro</code>：</p>

<p>从 <code>vuepress-plugin-search-pro</code> 导入 <code>searchProPlugin</code> 并将其应用至 <code>config.ts</code> 下的 <code>plugins</code> 选项：</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启项目，然后就可以在导航栏上看到搜索框了。</p>
<br>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>经过以上的配置后，已经达到一个基本的博客要求了，但是除去上面这些功能之外，vuepress-theme-hope还有很多有趣的功能和插件，请自行前往官网了解。</p>
</div>
<h2> 部署</h2>
<p>部署的话对于这种小体量静态网站，没有必要去购买专门的云服务器，可以直接使用Github Page功能，或者国内访问更快的Gitee。这里使用的是Github Workflows自动部署。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>推送完代码后Github会自动执行Actions，然后将网站打包的内容推送到<code>gh-pages</code>分支，然后Github会自动更新静态网站的内容。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>需要注意的是要开启Github Action允许修改仓库的权限。</p>
</div>
]]></content:encoded>
      <enclosure url="https://vuepress.vuejs.org/hero.png" type="image/png"/>
    </item>
    <item>
      <title>Mysql忘记数据库密码</title>
      <link>https://246859.github.io/my-blog-giscus/posts/problem/mysqlpassword.html</link>
      <guid>https://246859.github.io/my-blog-giscus/posts/problem/mysqlpassword.html</guid>
      <source url="https://246859.github.io/my-blog-giscus/rss.xml">Mysql忘记数据库密码</source>
      <description>Mysql忘记数据库密码 记录了Mysql忘记密码的几种解决方式</description>
      <category>问题记录</category>
      <pubDate>Sun, 12 Sep 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Mysql忘记数据库密码</h1>
<p>记录了Mysql忘记密码的几种解决方式</p>
<!-- more -->
<hr>
]]></content:encoded>
    </item>
  </channel>
</rss>