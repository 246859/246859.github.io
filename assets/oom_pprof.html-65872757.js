import{_ as a,W as o,X as t,Y as r,Z as e,$ as i,a1 as n}from"./framework-a4c02b8f.js";const s={},c=e("h1",{id:"记一次因日志而引发的oom问题",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#记一次因日志而引发的oom问题","aria-hidden":"true"},"#"),i(" 记一次因日志而引发的OOM问题")],-1),p=e("figure",null,[e("img",{src:"https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404141415851.png",alt:"",tabindex:"0",loading:"lazy"}),e("figcaption")],-1),d=n(`<hr><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2><p>在最近的项目中，后端隔三岔五就会因为内存爆满而崩溃，这种情况差不多两三天就会发生一次。由于在项目中在向Steam请求模组信息时会开启多个协程并发请求，因此猜测可能是因为协程未能正常退出而导致的内存泄露问题，于是便通过pprof来对应用进行性能分析。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ go tool pprof <span class="token parameter variable">-http</span><span class="token operator">=</span>:8080 http://127.0.0.1:9090/debug/pprof/heap
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过对pprof的可视化分析，发现与猜测的结果并不一致，在分析的过程中，发现获取服务端状态的这个接口在调用时内存占用会猛增，该接口主要用于判断游戏服务端是否启动，判断的逻辑就是去读取游戏服务端的日志文件，而有些用户的游戏服务端会一直开着，导致其文件大小可能会非常大，目前最大的发现有800MB，由于在读日志的时候是将其全量加载到内存中，那么这样一来就会导致内存占用升高。</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202404141710273.png" alt="图片已脱敏" tabindex="0" loading="lazy"><figcaption>图片已脱敏</figcaption></figure><p>并且在日志读取完后还要对其进行处理，由于go语言的字符串写时复制特性限制，在处理日志的时候还会拷贝一份副本，分配的内存就会更大。由于很多的功能都依赖于游戏日志，比如获取与服务端交互的命令结果，判断服务端的启动状态等等，它们在不断频繁地将日志全量加载到内存中后，必然会导致内存不足而OOM。</p><p>所以问题的根本原因就在于，游戏日志的读取加载的方法不正确。</p><h2 id="解决" tabindex="-1"><a class="header-anchor" href="#解决" aria-hidden="true">#</a> 解决</h2><p>由于日志文件过大，所以不应该将其全量加载到内存中，在进行逐个分块读取过后，内存占用了有了较为明显的下降。</p>`,10);function l(h,m){return o(),t("div",null,[c,p,r(" more "),d])}const u=a(s,[["render",l],["__file","oom_pprof.html.vue"]]);export{u as default};
