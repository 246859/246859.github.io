import{_ as a,W as n,X as s,a1 as e}from"./framework-a4c02b8f.js";const t={},p=e(`<h1 id="经典排序算法" tabindex="-1"><a class="header-anchor" href="#经典排序算法" aria-hidden="true">#</a> 经典排序算法</h1><p>用Go实现经典的几个排序算法</p><h2 id="稳定排序" tabindex="-1"><a class="header-anchor" href="#稳定排序" aria-hidden="true">#</a> 稳定排序</h2><p>稳定排序指的是排序过后相同元素的相对位置不会发送变化。</p><br><h3 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a> 冒泡排序</h3><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312021141370.gif" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>从下标0开始，不断将两个数字相比较，如果前一个数大于后一个数字，那么就交换位置，直至末尾。外层循环每一轮结束后，就能确定一个值是第<code>i+1</code>大的元素，于是后续的元素就不再去交换，所以内层循环的终止条件是<code>len(slice)-(i+1)</code>。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>slice<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> slice<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> slice<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
				slice<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> slice<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> slice<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> slice<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>时间复杂度：O(n^2）</strong></p><p>情况最差时，切片完全是逆序的，就需要交换总共 (n-1)+(n-2)+(n-3)+...+1 次 ，对其进行数列求和为 (n^2-n)/2 ，忽略低阶项则为O(n^2)</p><p><strong>空间复杂度：O(1）</strong></p><p>算法进行过程中没用到任何的额外空间，所以为O(1)</p><h3 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h3><h3 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h3><h2 id="不稳定排序" tabindex="-1"><a class="header-anchor" href="#不稳定排序" aria-hidden="true">#</a> 不稳定排序</h2><p>不稳定排序指的是排序过后元素的相对位置会发送变化。</p><h3 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h3><h3 id="希尔排序" tabindex="-1"><a class="header-anchor" href="#希尔排序" aria-hidden="true">#</a> 希尔排序</h3><h3 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h3><h3 id="计数排序" tabindex="-1"><a class="header-anchor" href="#计数排序" aria-hidden="true">#</a> 计数排序</h3><h3 id="基数排序" tabindex="-1"><a class="header-anchor" href="#基数排序" aria-hidden="true">#</a> 基数排序</h3><h3 id="桶排序" tabindex="-1"><a class="header-anchor" href="#桶排序" aria-hidden="true">#</a> 桶排序</h3><h3 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h3><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3>`,25),o=[p];function c(i,r){return n(),s("div",null,o)}const u=a(t,[["render",c],["__file","sort.html.vue"]]);export{u as default};
