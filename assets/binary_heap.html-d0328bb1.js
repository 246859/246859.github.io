import{_ as e,W as o,X as i,Y as c,Z as n,$ as s,a0 as t,a1 as p,C as l}from"./framework-a4c02b8f.js";const u={},r=n("h1",{id:"堆-二项堆",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#堆-二项堆","aria-hidden":"true"},"#"),s(" 堆-二项堆")],-1),k=n("figure",null,[n("img",{src:"https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161653801.png",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),d=p(`<hr><p>堆是一种特殊的数据结构，它的特点在于可以在O(1)的时间内找到堆内的最大值或最小值。它一般有两种类型，大顶堆或小顶堆。大顶堆是最大值在堆顶，子节点均小于根节点；小顶堆是最小值在堆顶，子节点均大于根节，同时堆也是优先队列比较常见的实现种类。堆只是这类数据结构的统称，并非特指某种具体实现，一般来说它支持以下几种操作，</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Heap<span class="token punctuation">[</span>T any<span class="token punctuation">]</span> <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token comment">// 添加若干元素到堆中</span>
	<span class="token function">Push</span><span class="token punctuation">(</span>e <span class="token operator">...</span>T<span class="token punctuation">)</span>
	<span class="token comment">// 查看堆顶元素</span>
	<span class="token function">Peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>
	<span class="token comment">// 返回堆顶元素，并将其从堆中删除</span>
	<span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>
	<span class="token comment">// 替换指定元素</span>
	<span class="token function">Fix</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> k T<span class="token punctuation">)</span>
	<span class="token comment">// 删除指定元素</span>
	<span class="token function">Remove</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span>
	<span class="token comment">// 两个堆合并</span>
	<span class="token function">Merge</span><span class="token punctuation">(</span>heap Heap<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这些操作在其它文章可能叫法不一样，但大致的作用都是类似的，也可能有更多的拓展。</p><p>今天要讲的就是堆里面最简单的实现，二项堆，或者叫二叉堆，其英文名为BinaryHeap，下面统称为二项堆。二叉堆在表现上通常是一个近似完全二叉树的树，如下图</p><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161717587.png" style="zoom:50%;"><p>对于二项堆而言，它的关键操作在于元素的上浮和下沉，这个过程会频繁的遍历整个树，所以一般二项堆不会采用树节点的方式实现，而是使用数组的形式。将上图的二叉树转换成数组后就如下图所示：</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161723238.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对于堆每一个节点，其在数组中的下标映射为：</p><ul><li>父节点：<code>(i-1)/2</code></li><li>左子节点：<code>i*2+1</code></li><li>右子节点：<code>i*2+2</code></li></ul><p>这种规则很好理解，下面演示上浮和下沉操作，默认为小顶堆。</p><h2 id="上浮" tabindex="-1"><a class="header-anchor" href="#上浮" aria-hidden="true">#</a> 上浮</h2><p>在前面的基础之上，向堆中添加了一个新元素，我们将其添加到数组的末尾，如下图</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161742023.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后让其不断的与它的父节点进行比较，如果小于父节点，就进行交换，否则就停止交换。对于2而言，它的父节点位于下标<code>(7-1)/2=3</code>处，也就是元素8，显然它是小于8的，于是它两交换位置。</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161747062.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后再与其父节点5进行比较，小于5，则交换位置，然后再与父节点3进行比较，小于3，于是再次交换，最终整个堆就如下图所示：</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161750694.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>此时2就是堆顶元素，它也的确是最小的那一个元素，于是堆调整完毕，这个过程也就称之为上浮。整个过程只是在不断的与它的父节点进行比较，总比较次数为3，同时这也是树的高度，对于一个含有n个数量的堆来说，添加一个新元素的时间复杂度为O(logn)。代码实现如下</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>heap <span class="token operator">*</span>BinaryHeap<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">up</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// parent = index / 2 - 1</span>
	<span class="token keyword">for</span> pi <span class="token operator">:=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> pi <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		v<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		pv<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span>

		<span class="token keyword">if</span> heap<span class="token punctuation">.</span><span class="token function">cmp</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> pv<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> containers<span class="token punctuation">.</span>EqualTo <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>

		lists<span class="token punctuation">.</span>Swap<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>list<span class="token punctuation">,</span> i<span class="token punctuation">,</span> pi<span class="token punctuation">)</span>
		i <span class="token operator">=</span> pi
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="下沉" tabindex="-1"><a class="header-anchor" href="#下沉" aria-hidden="true">#</a> 下沉</h2><p>对于堆顶元素而言，如果要将其从堆中删除，首先将其与最后一个元素交换位置，然后再移除尾部元素。如下图所示</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161804777.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后此时堆顶元素不断与其子节点进行比较，如果比子字节大就交换位置，每一次交换时，优先交换两个子节点中更小的那一个。比如8的子节点是4，和5，那么将8与4进行交换。</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161806563.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>再继续与子节点进行比较然后交换，最终如下图所示</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312161808745.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>此时堆再次调整完毕，堆顶元素仍然是最小值。整个过程只是在不断的与子节点进行比较交换，下沉操作的时间复杂度也为O(logn)。代码实现如下</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>heap <span class="token operator">*</span>BinaryHeap<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">down</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	size <span class="token operator">:=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// left_son = index * 2 + 1</span>
	<span class="token comment">// right_son = left_son + 1</span>
	<span class="token keyword">for</span> si <span class="token operator">:=</span> i<span class="token operator">&lt;&lt;</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> si <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> si <span class="token operator">=</span> i<span class="token operator">&lt;&lt;</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		ri <span class="token operator">:=</span> si <span class="token operator">+</span> <span class="token number">1</span>

		sv<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>si<span class="token punctuation">)</span>
		rv<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>ri<span class="token punctuation">)</span>

		lv<span class="token punctuation">,</span> li <span class="token operator">:=</span> sv<span class="token punctuation">,</span> si

		<span class="token comment">// check if right is less than left</span>
		<span class="token keyword">if</span> ri <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> heap<span class="token punctuation">.</span><span class="token function">cmp</span><span class="token punctuation">(</span>sv<span class="token punctuation">,</span> rv<span class="token punctuation">)</span> <span class="token operator">==</span> containers<span class="token punctuation">.</span>GreaterThan <span class="token punctuation">{</span>
			lv <span class="token operator">=</span> rv
			li <span class="token operator">=</span> ri
		<span class="token punctuation">}</span>

		<span class="token comment">// check if iv is less than lv</span>
		iv<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token keyword">if</span> heap<span class="token punctuation">.</span><span class="token function">cmp</span><span class="token punctuation">(</span>iv<span class="token punctuation">,</span> lv<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> containers<span class="token punctuation">.</span>EqualTo <span class="token punctuation">{</span>
			<span class="token keyword">break</span>
		<span class="token punctuation">}</span>

		lists<span class="token punctuation">.</span>Swap<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span>list<span class="token punctuation">,</span> i<span class="token punctuation">,</span> li<span class="token punctuation">)</span>
		i <span class="token operator">=</span> li
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="构建" tabindex="-1"><a class="header-anchor" href="#构建" aria-hidden="true">#</a> 构建</h2><p>对于构建二项堆而言，一个简单的做法是将其视为一个空的堆，然后不断的对每一个末尾的元素执行上浮操作，那么它的时间复杂度就是O(nlogn)。</p>`,31),m={href:"https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap",target:"_blank",rel:"noopener noreferrer"},v=p(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>heap <span class="token operator">*</span>BinaryHeap<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>es <span class="token operator">...</span>T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>es<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>es<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		heap<span class="token punctuation">.</span><span class="token function">up</span><span class="token punctuation">(</span>heap<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token comment">// push one then up one that is the normal method which will run in O(nlogn) time</span>
		<span class="token comment">// but another faster method as follows that reference https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap</span>
		heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>es<span class="token operator">...</span><span class="token punctuation">)</span>
		<span class="token comment">// get the last possible subtree root node position</span>
		size <span class="token operator">:=</span> heap<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
		<span class="token comment">// iterate over all subtree root node bottom up, and execute down operation in per root node</span>
		<span class="token comment">// Assuming that the subtrees of height h have all been binary heapified, then for the subtrees of height h+1,</span>
		<span class="token comment">// adjusting the root node along the branch of the maximum child node requires at most h steps to complete the binary heapification.</span>
		<span class="token comment">// It can be proven that the time complexity of this algorithm is O(n).</span>
		<span class="token keyword">for</span> i <span class="token operator">:=</span> size<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>
			heap<span class="token punctuation">.</span><span class="token function">down</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>构建</td><td>O(n)</td></tr><tr><td>查看最小值</td><td>O(1)</td></tr><tr><td>插入</td><td>O(log n)</td></tr><tr><td>删除</td><td>O(log n)</td></tr><tr><td>合并</td><td>O(n)</td></tr></tbody></table><p>二项堆是所有实现中最简单的一个，总体来说难度不大，性能尚可，足够满足基本使用。</p>`,4),b={class:"hint-container tip"},h=n("p",{class:"hint-container-title"},"提示",-1),g={href:"https://github.com/246859/containers/blob/main/heaps/binary_heap.go",target:"_blank",rel:"noopener noreferrer"};function f(y,_){const a=l("ExternalLinkIcon");return o(),i("div",null,[r,k,c(" more "),d,n("p",null,[s("有一种办法可以做到O(n)的时间复杂度，它的思路是：首先将给定的输入序列按照二叉树的规则在分布在数组当中，自底向上从最后一个父节点开始，每一个父节点就代表着一个子树，对这个子树的根节点执行下沉操作，这样一直操作到整个二项堆的根节点，由于所有局部的子树都已经完成堆化了，对于这个整体根节点的下沉操作也最多只需要比较O(h)次，h是整个树的高度，可以证明这个过程的时间复杂度为O(n)，详细的证明过程在"),n("a",m,[s("wiki"),t(a)]),s("中可以查阅，而二项堆的合并过程也与构建的过程大同小异。代码实现如下")]),v,n("div",b,[h,n("p",null,[s("有关二项堆的具体实现，可以前往"),n("a",g,[s("containers/heaps/binary_heap.go"),t(a)]),s("进行了解，这是我自己写的常用数据结构的库，支持泛型。")])])])}const x=e(u,[["render",f],["__file","binary_heap.html.vue"]]);export{x as default};
