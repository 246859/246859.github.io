import{_ as i,W as t,X as e,Y as c,Z as n,$ as a,a0 as l,a1 as p,C as o}from"./framework-a4c02b8f.js";const u={},r=n("h1",{id:"kv存储模型-bitcask",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#kv存储模型-bitcask","aria-hidden":"true"},"#"),a(" KV存储模型 --- Bitcask")],-1),d=n("figure",null,[n("img",{src:"https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101433828.png",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),k=n("hr",null,null,-1),m=n("h2",{id:"简介",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#简介","aria-hidden":"true"},"#"),a(" 简介")],-1),g=n("p",null,[a("在面向磁盘的Key/value数据库设计中，常见存储模型的有B+Tree，LSM，前者读性能优秀，后者写性能优秀，它们两个已经有了非常多的实践案例，比如基于B+Tree的"),n("code",null,"BoltDB"),a("，基于LSM的"),n("code",null,"LevelDB"),a("。不过今天的主角讲的并不是它们两个，而是另一个存储模型Bitcask，它最早是由一个日本分布式存储公司Riak提出的理论，与LSM类似，它是一种日志结构的快速KV哈希表，不过它实现起来要比LSM简单的多。")],-1),v={href:"https://riak.com/assets/bitcask-intro.pdf",target:"_blank",rel:"noopener noreferrer"},b=p(`<p>Riak公司最初希望寻找一个满足以下条件的存储引擎</p><ul><li>读写低延迟</li><li>高吞吐量随机写入</li><li>在高负载情况下，行为可以预测</li><li>具有处理比内存更大空间数据的能力</li><li>崩溃友好，可以快速恢复而不丢失数据</li><li>易于备份和恢复</li><li>简单易懂的数据格式，且易于实现</li><li>简单的使用协议</li></ul><p>找到满足上面部分条件的很容易，但是满足全部条件的几乎没有，于是这促使他们开始自己去研究一种日志化结构的KV存储引擎，受到LSM的启发，而后便设计了Bitcask这一个可以满足上述所有要求的存储模型，所以Bitcask实际上也是一种类LSM的结构。</p><h2 id="设计" tabindex="-1"><a class="header-anchor" href="#设计" aria-hidden="true">#</a> 设计</h2><p>在了解完Bitcask的历史后，下面来说说它究竟是如何设计的。</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101550346.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一个Bitcask实例就是一个文件夹，文件夹存放着若干个数据文件，这些文件分为Active Data File和Older Data File。在某一时刻，数据会被写入到Active Data File也就是活跃文件，当文件存放的数据达到阈值后，当前活跃文件将被关闭并成为旧数据文件，旧数据文件一旦被关闭过后，日后永远都不会再对其写入数据。然后会创建一个新的活跃数据文件用于写入新数据，同一时刻只能有一个进程对活跃数据文件写入数据。文件的写入操作是通过追加（append only）的方式进行，由于是顺序IO所以不需要多余的磁盘寻址操作。</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101602964.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Bitcask的数据格式同样很简单，如图所示，由以下几个部分组成</p><ul><li>crc，循环冗余校验码</li><li>tstamp，时间戳</li><li>ksz，键的所占用的空间大小</li><li>value_sz，值所占用的空间大小</li><li>key，存放键</li><li>value，存放值</li></ul><p>每一次对活跃数据文件写入数据，就会添加一条新的数据条目，对于删除操作而言，并不会真的去删除文件里面的数据，而且将其作为一个特殊的数据条目写入文件中来标记该数据被删除，待到下次文件合并时，数据才会被真正的删除。Bitcask数据文件只不过是这些数据条目的线性序列，如下图所示。</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101613871.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在向磁盘写完数据以后，就会去更新keydir&quot;。&quot;keydir&quot;并不是一个真的文件夹，它是一个维护在内存中的索引结构，负责映射每一个key的元信息。这些元信息包括</p><ul><li>file_id，标识数据存放在哪一个文件</li><li>value_sz，数据所占用的空间大小</li><li>value_pos，数据在文件中的位置</li><li>tstamp，时间戳</li></ul><p>如下图所示</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101620287.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当更新数据时，并不会去更新旧数据文件中的指定数据条目，而是向当前的活跃数据文件添加新的数据条目，然后keydir会原子的更新最新数据的位置，旧数据依旧保存在磁盘中，往后的数据读取操作会使用keydir中的最新位置来进行访问，至于旧数据条目会在后续的合并过程中被删除。</p><p>对于读数据而言，只需要进行一次磁盘寻道。首先会从内存中维护的keydir找到与之匹配的数据元信息，得知数据存放在哪一个文件，以及文件中的位置信息，然后再去对应的数据文件中读取响应的数据条目信息，凭借着操作系统的预读文件缓存，这一过程可能会比预期的还要更快。</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101643358.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在上面的删除和更新操作中，都会产生额外的新数据条目，对于旧数据条目则不会再使用，随着时间的推移，这种冗余的数据条目会越来越多，就会占用相当大一部分的空间，为此需要就需要去清理这些旧的数据文件，这个过程就称之为合并。在合并过程中，会遍历所有的旧数据文件，然后输出一系列只包含最新数据的文件，在合并的同时，还会创建Hint File，也就是索引文件，每一个合并过后的Merged Data File都有一个对应的Hint File，Hint File中的数据条目与内存中的keydir相对应，前者是后者的持久化体现。Hint File只存储数据元信息，并不存储实际的数据，它的作用是为了在Bitacask实例启动时，更快速的构建内存索引。</p><figure><img src="https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202311101706570.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这些就是Bitcask所有的设计内容，可以看得出确实比较简单和容易理解。官方还做了以下几点的说明</p><ol><li>Bitcask读性能依赖于操作系统的文件系统缓存，他们曾经讨论设计过关于Bitcask的内部缓存，这可能会使Bitcask变得更复杂，且不清楚这样做的带来的性能收益是否可以抵过随之而来的复杂性，毕竟设计的初衷就是要足够简单。</li><li>Bitcask不会对数据进行任何的压缩，因为这种行为的收益与损耗依赖具体的应用。</li><li>在早期的测试中，一台低配的笔记本电脑上，Bitcask每秒可以执行5000-6000次左右的写入操作。</li><li>在早期的测试中，Bitcask可以存储10倍于内存的数据而不会出现性能下降的情况。</li><li>在早期的测试中，即便有数百万个key，keydir所占用的内存也不到GB。</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>Bitacask在设计之初就不是追求<strong>最快</strong>的速度，作者觉得快到足够使用即可，它使用内存来做索引，用磁盘来存储数据，具有实现简单，可读性强，性能优秀等众多优点。由于它只有一个写入点，且只能是串行写入，所以尤其适合存储大量只需一次IO就能写入的小块数据，对于大块数据而言，会使得吞吐量非常低。</p><p>鉴于其简单的设计，非常适合初学者学习和入门，社区里面也有很多开源实现，比如<code>nutsDB</code>，<code>roseDB</code>，两者都是嵌入式KV数据库，均为go语言实现。动手自己实现一个基于Bitacask的数据库，可以加深理解。</p><h2 id="api" tabindex="-1"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h2><p>Riak官方在文档中描述了Bitcask参考的API，仅仅只有几个接口，下面以go语言的伪代码展示。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> BitCask <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建一个新的bitcask实例</span>
	<span class="token function">Open</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span> <span class="token punctuation">(</span>db<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token comment">// 获取指定的键值</span>
	<span class="token function">Get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token comment">// 新建或插入键值</span>
	<span class="token function">Put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token comment">// 删除指定的键值</span>
	<span class="token function">Delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token comment">// 列出所有可用的键</span>
	<span class="token function">List</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>key<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token comment">// 迭代键值</span>
	<span class="token function">Fold</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token comment">// 合并</span>
	<span class="token function">Merge</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token comment">// 同步磁盘</span>
	<span class="token function">Sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
    <span class="token comment">// 关闭实例</span>
	<span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,29);function h(f,y){const s=o("ExternalLinkIcon");return t(),e("div",null,[r,d,c(" more "),k,m,g,n("p",null,[a("Bitcask文档："),n("a",v,[a("riak-bitcask"),l(s)])]),b])}const B=i(u,[["render",h],["__file","bitcask.html.vue"]]);export{B as default};
