const e=JSON.parse('{"key":"v-146ba71a","path":"/posts/alg/sort.html","title":"经典排序算法","lang":"zh-CN","frontmatter":{"date":"2022-10-23T00:00:00.000Z","article":true,"category":"算法","tag":["sort","data struct","go"],"description":"经典排序算法 用Go实现经典的几个排序算法 稳定排序 稳定排序指的是排序过后相同元素的相对位置不会发送变化。 冒泡排序 img 从下标0开始，不断将两个数字相比较，如果前一个数大于后一个数字，那么就交换位置，直至末尾。外层循环每一轮结束后，就能确定一个值是第i+1大的元素，于是后续的元素就不再去交换，所以内层循环的终止条件是len(slice)-(i+1)。","head":[["meta",{"property":"og:url","content":"https://246859.github.io/my-blog-giscus/posts/alg/sort.html"}],["meta",{"property":"og:site_name","content":"寒江蓑笠翁"}],["meta",{"property":"og:title","content":"经典排序算法"}],["meta",{"property":"og:description","content":"经典排序算法 用Go实现经典的几个排序算法 稳定排序 稳定排序指的是排序过后相同元素的相对位置不会发送变化。 冒泡排序 img 从下标0开始，不断将两个数字相比较，如果前一个数大于后一个数字，那么就交换位置，直至末尾。外层循环每一轮结束后，就能确定一个值是第i+1大的元素，于是后续的元素就不再去交换，所以内层循环的终止条件是len(slice)-(i+1)。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-02T06:18:03.000Z"}],["meta",{"property":"article:author","content":"寒江蓑笠翁"}],["meta",{"property":"article:tag","content":"sort"}],["meta",{"property":"article:tag","content":"data struct"}],["meta",{"property":"article:tag","content":"go"}],["meta",{"property":"article:published_time","content":"2022-10-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-02T06:18:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"经典排序算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-10-23T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-02T06:18:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"寒江蓑笠翁\\",\\"url\\":\\"https://mrhope.site\\"}]}"]]},"headers":[{"level":2,"title":"稳定排序","slug":"稳定排序","link":"#稳定排序","children":[{"level":3,"title":"冒泡排序","slug":"冒泡排序","link":"#冒泡排序","children":[]},{"level":3,"title":"插入排序","slug":"插入排序","link":"#插入排序","children":[]},{"level":3,"title":"归并排序","slug":"归并排序","link":"#归并排序","children":[]}]},{"level":2,"title":"不稳定排序","slug":"不稳定排序","link":"#不稳定排序","children":[{"level":3,"title":"选择排序","slug":"选择排序","link":"#选择排序","children":[]},{"level":3,"title":"希尔排序","slug":"希尔排序","link":"#希尔排序","children":[]},{"level":3,"title":"快速排序","slug":"快速排序","link":"#快速排序","children":[]},{"level":3,"title":"计数排序","slug":"计数排序","link":"#计数排序","children":[]},{"level":3,"title":"基数排序","slug":"基数排序","link":"#基数排序","children":[]},{"level":3,"title":"桶排序","slug":"桶排序","link":"#桶排序","children":[]},{"level":3,"title":"堆排序","slug":"堆排序","link":"#堆排序","children":[]},{"level":3,"title":"","slug":"","link":"#","children":[]}]}],"git":{"createdTime":1701497883000,"updatedTime":1701497883000,"contributors":[{"name":"246859","email":"2633565580@qq.com","commits":1}]},"readingTime":{"minutes":2.37,"words":356},"filePathRelative":"posts/alg/sort.md","localizedDate":"2022年10月23日","excerpt":"<h1> 经典排序算法</h1>\\n<p>用Go实现经典的几个排序算法</p>\\n<h2> 稳定排序</h2>\\n<p>稳定排序指的是排序过后相同元素的相对位置不会发送变化。</p>\\n<br>\\n<h3> 冒泡排序</h3>\\n<figure><img src=\\"https://public-1308755698.cos.ap-chongqing.myqcloud.com//img/202312021141370.gif\\" alt=\\"img\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>img</figcaption></figure>\\n<p>从下标0开始，不断将两个数字相比较，如果前一个数大于后一个数字，那么就交换位置，直至末尾。外层循环每一轮结束后，就能确定一个值是第<code>i+1</code>大的元素，于是后续的元素就不再去交换，所以内层循环的终止条件是<code>len(slice)-(i+1)</code>。</p>","autoDesc":true}');export{e as data};
