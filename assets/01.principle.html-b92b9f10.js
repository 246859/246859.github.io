import{_ as a,W as e,X as r,a1 as h}from"./framework-a4c02b8f.js";const d={},i=h('<h1 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则" aria-hidden="true">#</a> 设计原则</h1><p>这六大原则是比较经典的，它们是所有设计模式的基石，也是编码的基本规范，前面讲到不要过度设计，但六大原则是一个优秀的代码应当遵守最基本的规范。</p><h2 id="开闭原则" tabindex="-1"><a class="header-anchor" href="#开闭原则" aria-hidden="true">#</a> 开闭原则</h2><p>这是一个十分经典的原则，也是最基础的原则，就只有10个字的内容，<strong>对拓展开放，对修改关闭</strong>。一个程序应当具有相应的拓展性，假设开发了一个Go第三方依赖库，倘若调用者想要自定义功能只能去修改依赖库的源代码，但是每个人都有不同的需求，难道每个人都要改一遍源代码吗，这么做的结果显然是非常恐怖的，代码会变得异常难以维护。</p><h2 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则" aria-hidden="true">#</a> 单一职责原则</h2><p>一个接口，或则一个结构体，或者一个函数，都应当被封装的只有一个职责。这个原则是为了降低代码耦合度，应当尽可能负责更少的功能，而不是全部糅杂在一起。</p><h2 id="里氏替换原则" tabindex="-1"><a class="header-anchor" href="#里氏替换原则" aria-hidden="true">#</a> 里氏替换原则</h2><p>这个原则的原意会比较晦涩难懂，在实现接口或者”继承“时会用到的比较多，原文是：“如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致”。替换指的是任何实现T类型的对象或者子类，都可以当作成T类型的对象来使用，行为一致指的得是被替换后，原有的功能正常使用，不会有任何变化。</p><p>里氏替换原则本质上就是多态，结合依赖倒转原则一起使用就是面向接口编程的核心思想。</p><h2 id="依赖倒转原则" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则" aria-hidden="true">#</a> 依赖倒转原则</h2><p>依赖倒转原则指的是：针对抽象接口编程，而非针对具体实现。例如在编写一个函数或方法时，对于参数我们都会将其设置为对应的接口类型，而不是接口的实现，这样有利于后续的拓展。</p><h2 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则" aria-hidden="true">#</a> 接口隔离原则</h2><p>接口隔离原则值得是尽量降低接口的耦合度，接口要尽量的小，而不是把所有东西都糅杂到接口里，依赖该接口的调用者，不应当访问到不需要用到的接口方法，接口内不应该存在调用者不需要的接口给方法。</p><h2 id="最少知道法则" tabindex="-1"><a class="header-anchor" href="#最少知道法则" aria-hidden="true">#</a> 最少知道法则</h2><p>又称迪米特法则，接口与接口之间，模块与模块之间，实体与实体之间应当只存在最低限度的认识和相互作用，使得功能相对独立而受到的影响最少。</p><h2 id="合成复用原则" tabindex="-1"><a class="header-anchor" href="#合成复用原则" aria-hidden="true">#</a> 合成复用原则</h2><p>复用时尽可能的使用组合聚合的关系，而不是继承。继承确实可以很简单的复用，但是这会破坏封装性，灵活性低，耦合度高。</p>',17),n=[i];function t(c,s){return e(),r("div",null,n)}const p=a(d,[["render",t],["__file","01.principle.html.vue"]]);export{p as default};
