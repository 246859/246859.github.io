const e=JSON.parse('{"key":"v-b514bb84","path":"/posts/code/pattern/01.principle.html","title":"设计原则","lang":"zh-CN","frontmatter":{"date":"2023-10-01T00:00:00.000Z","article":true,"star":false,"sticky":false,"category":"设计模式","tag":["设计模式","go"],"description":"设计原则 这六大原则是比较经典的，它们是所有设计模式的基石，也是编码的基本规范，前面讲到不要过度设计，但六大原则是一个优秀的代码应当遵守最基本的规范。 开闭原则 这是一个十分经典的原则，也是最基础的原则，就只有10个字的内容，对拓展开放，对修改关闭。一个程序应当具有相应的拓展性，假设开发了一个Go第三方依赖库，倘若调用者想要自定义功能只能去修改依赖库的源代码，但是每个人都有不同的需求，难道每个人都要改一遍源代码吗，这么做的结果显然是非常恐怖的，代码会变得异常难以维护。 单一职责原则","head":[["meta",{"property":"og:url","content":"https://246859.github.io/my-blog-giscus/posts/code/pattern/01.principle.html"}],["meta",{"property":"og:site_name","content":"寒江蓑笠翁"}],["meta",{"property":"og:title","content":"设计原则"}],["meta",{"property":"og:description","content":"设计原则 这六大原则是比较经典的，它们是所有设计模式的基石，也是编码的基本规范，前面讲到不要过度设计，但六大原则是一个优秀的代码应当遵守最基本的规范。 开闭原则 这是一个十分经典的原则，也是最基础的原则，就只有10个字的内容，对拓展开放，对修改关闭。一个程序应当具有相应的拓展性，假设开发了一个Go第三方依赖库，倘若调用者想要自定义功能只能去修改依赖库的源代码，但是每个人都有不同的需求，难道每个人都要改一遍源代码吗，这么做的结果显然是非常恐怖的，代码会变得异常难以维护。 单一职责原则"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-14T01:43:43.000Z"}],["meta",{"property":"article:author","content":"寒江蓑笠翁"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:tag","content":"go"}],["meta",{"property":"article:published_time","content":"2023-10-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-14T01:43:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计原则\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-10-01T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-14T01:43:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"寒江蓑笠翁\\",\\"url\\":\\"https://mrhope.site\\"}]}"]]},"headers":[{"level":2,"title":"开闭原则","slug":"开闭原则","link":"#开闭原则","children":[]},{"level":2,"title":"单一职责原则","slug":"单一职责原则","link":"#单一职责原则","children":[]},{"level":2,"title":"里氏替换原则","slug":"里氏替换原则","link":"#里氏替换原则","children":[]},{"level":2,"title":"依赖倒转原则","slug":"依赖倒转原则","link":"#依赖倒转原则","children":[]},{"level":2,"title":"接口隔离原则","slug":"接口隔离原则","link":"#接口隔离原则","children":[]},{"level":2,"title":"最少知道法则","slug":"最少知道法则","link":"#最少知道法则","children":[]},{"level":2,"title":"合成复用原则","slug":"合成复用原则","link":"#合成复用原则","children":[]}],"git":{"createdTime":1702518223000,"updatedTime":1702518223000,"contributors":[{"name":"246859","email":"2633565580@qq.com","commits":1}]},"readingTime":{"minutes":5.29,"words":794},"filePathRelative":"posts/code/pattern/01.principle.md","localizedDate":"2023年10月1日","excerpt":"<h1> 设计原则</h1>\\n<p>这六大原则是比较经典的，它们是所有设计模式的基石，也是编码的基本规范，前面讲到不要过度设计，但六大原则是一个优秀的代码应当遵守最基本的规范。</p>\\n<h2> 开闭原则</h2>\\n<p>这是一个十分经典的原则，也是最基础的原则，就只有10个字的内容，<strong>对拓展开放，对修改关闭</strong>。一个程序应当具有相应的拓展性，假设开发了一个Go第三方依赖库，倘若调用者想要自定义功能只能去修改依赖库的源代码，但是每个人都有不同的需求，难道每个人都要改一遍源代码吗，这么做的结果显然是非常恐怖的，代码会变得异常难以维护。</p>\\n<h2> 单一职责原则</h2>","autoDesc":true}');export{e as data};
